<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++基础 | MoMoAo🍓</title><meta name="keywords" content="C++"><meta name="author" content="MoMoAo🍓"><meta name="copyright" content="MoMoAo🍓"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="🥧本文汇总C++的数据类型、类、结构体等基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础">
<meta property="og:url" content="https://momoao.github.io/posts/202308241930.html">
<meta property="og:site_name" content="MoMoAo🍓">
<meta property="og:description" content="🥧本文汇总C++的数据类型、类、结构体等基础知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://momoao.github.io/assets/wallpaper/w11.jpg">
<meta property="article:published_time" content="2023-07-10T10:19:03.000Z">
<meta property="article:modified_time" content="2023-08-25T12:42:33.829Z">
<meta property="article:author" content="MoMoAo🍓">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://momoao.github.io/assets/wallpaper/w11.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://momoao.github.io/posts/202308241930"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"这篇文章是","messageNext":"天之前更新的，内容可能比较老了"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-25 20:42:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/map/js/china.js"></script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="MoMoAo🍓" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/tx.jpg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MoMoAo🍓</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">C++基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2023-07-10T10:19:03.000Z" title="发表于 2023-07-10 18:19:03">2023-07-10</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-25T12:42:33.829Z" title="更新于 2023-08-25 20:42:33">2023-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2.3w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>75分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++基础"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>C++基础</h1>
<h1>零碎问题</h1>
<h2 id="指针和引用的区别">指针和引用的区别</h2>
<p>在C++中，指针（Pointers）和引用（References）都是用于处理内存和变量的重要概念，但它们有一些重要的区别。让我来解释一下它们的区别：</p>
<ol>
<li>
<p>内存地址：</p>
<ul>
<li>指针：指针是一个变量，存储的是一个内存地址，指向某个变量或对象在内存中的位置。</li>
<li>引用：引用是某个变量或对象的别名，没有自己的内存地址。它与被引用的变量共享相同的内存地址。</li>
</ul>
</li>
<li>
<p>初始化：</p>
<ul>
<li>指针：指针在定义时需要显式地初始化为一个有效的内存地址，可以是nullptr（空指针）或者指向某个对象。</li>
<li>引用：引用在定义时必须初始化为一个已存在的变量或对象，且不能被重新赋值为引用其他变量。</li>
</ul>
</li>
<li>
<p>空值（null）：</p>
<ul>
<li>指针：指针可以是空指针（nullptr），即不指向任何有效的内存地址。</li>
<li>引用：引用必须始终引用某个已存在的变量或对象，不存在空引用的概念。</li>
</ul>
</li>
<li>
<p>重定向：</p>
<ul>
<li>指针：指针可以在运行时重新指向不同的变量或对象。</li>
<li>引用：一旦引用被初始化，它将一直引用同一个变量或对象，无法改变引用的目标。</li>
</ul>
</li>
<li>
<p>空间占用：</p>
<ul>
<li>指针：指针本身占据内存空间（通常是4个字节或8个字节，取决于系统）。</li>
<li>引用：引用在内存中不占据额外的空间，它只是被引用变量的别名。</li>
</ul>
</li>
<li>
<p>空间符号：</p>
<ul>
<li>指针：使用<code>*</code>来声明指针变量，并使用<code>*</code>来访问指针指向的对象（解引用）。</li>
<li>引用：使用<code>&amp;</code>来声明引用，但在使用时不需要加<code>&amp;</code>符号，直接使用引用即可。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x; <span class="comment">// 指针ptr指向变量x</span></span><br><span class="line"><span class="type">int</span>&amp; ref = x;  <span class="comment">// 引用ref是变量x的别名</span></span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 修改指针ptr指向的变量的值（x变为20）</span></span><br><span class="line">ref = <span class="number">30</span>;  <span class="comment">// 修改引用ref所引用的变量的值（x变为30）</span></span><br></pre></td></tr></table></figure>
<p>总结：<br>
指针和引用在C++中都是非常有用的工具，它们都用于处理变量和内存。选择使用指针还是引用取决于具体的情况和需求。通常情况下，如果你需要在运行时更改指向的对象，或者需要支持空值，使用指针是更好的选择。如果你只需要别名来简化代码并且不需要重新指向其他对象，使用引用可能更方便和安全。</p>
<h2 id="final和const区别">final和const区别</h2>
<p><code>final</code>和<code>const</code>是两个不同的关键字，用于不同的目的和场景。它们之间的区别如下：</p>
<ol>
<li>
<p>用途和作用：</p>
<ul>
<li><code>final</code>关键字用于类、函数和继承关系，用于限制继承、函数重写和继承链的扩展性。</li>
<li><code>const</code>关键字用于声明常量、指示对象为只读，以及修饰函数参数和成员函数，用于控制数据的不可修改性。</li>
</ul>
</li>
<li>
<p>应用范围：</p>
<ul>
<li><code>final</code>关键字适用于类的声明、虚函数的声明和派生类的声明。</li>
<li><code>const</code>关键字适用于变量、函数参数、函数返回类型和成员函数。</li>
</ul>
</li>
<li>
<p>修改限制：</p>
<ul>
<li><code>final</code>关键字用于禁止类被继承、虚函数被重写和派生类的进一步派生。</li>
<li><code>const</code>关键字用于声明常量或指示对象为只读，不能修改被声明为<code>const</code>的对象。</li>
</ul>
</li>
<li>
<p>作用于对象：</p>
<ul>
<li><code>final</code>关键字作用于类和函数，用于限制其可继承性和重写性。</li>
<li><code>const</code>关键字作用于变量和函数，用于声明常量、指示只读性以及限制对被修饰对象的修改。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>final</code>关键字用于限制继承和函数重写的扩展性，而<code>const</code>关键字用于声明常量和指示对象的只读性。它们在用途、应用范围和作用于对象上都有明显的差异。</p>
<h2 id="使用-和-的区别">使用 .和-&gt;的区别</h2>
<p>在C++中，使用<code>.</code>和<code>-&gt;</code>是用于访问指针所指向的对象的成员的两种方式。</p>
<ol>
<li>
<p>点操作符（.）：点操作符用于直接访问对象的成员，它只能用于对象本身，而不能用于指针。如果要使用点操作符，需要将指针解引用为对象。</p>
</li>
<li>
<p>箭头操作符（-&gt;）：箭头操作符用于通过指针间接访问对象的成员，它是指针特有的操作符。使用箭头操作符时，不需要将指针解引用为对象。</p>
</li>
</ol>
<p>下面是一个简单的示例代码，演示了<code>.</code>和<code>-&gt;</code>的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.value = <span class="number">42</span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>();      <span class="comment">// 使用点操作符直接访问对象成员，输出: Value: 42</span></span><br><span class="line"></span><br><span class="line">    MyClass* ptr = &amp;obj;</span><br><span class="line">    ptr-&gt;value = <span class="number">24</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">printValue</span>();     <span class="comment">// 使用箭头操作符通过指针间接访问对象成员，输出: Value: 24</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了一个<code>MyClass</code>类，其中包含一个整型成员变量<code>value</code>和一个成员函数<code>printValue()</code>。在<code>main()</code>函数中，我们创建了一个<code>MyClass</code>对象<code>obj</code>，并通过点操作符直接访问了对象的成员变量<code>value</code>和成员函数<code>printValue()</code>。</p>
<p>然后，我们创建了一个指向<code>obj</code>的指针<code>ptr</code>，并使用箭头操作符通过指针间接访问了对象的成员变量<code>value</code>和成员函数<code>printValue()</code>。注意，使用箭头操作符时，不需要解引用指针。</p>
<p>总结起来：</p>
<ul>
<li>使用<code>.</code>操作符用于直接访问对象的成员，需要对象本身而不是指针。</li>
<li>使用<code>-&gt;</code>操作符用于通过指针间接访问对象的成员，不需要解引用指针。</li>
</ul>
<h2 id="为什么说-bits-stdc-h-是万能头文件">为什么说&lt;bits/stdc++.h&gt;是万能头文件</h2>
<p>在C++编程中，<code>&lt;bits/stdc++.h&gt;</code>是一个非标准头文件，它通常被用于竞赛编程和快速原型开发，被认为是&quot;万能头文件&quot;。这个头文件包含了大量常用的标准C++库的其他头文件，因此在使用它之后，就不需要为每个标准库引入单独的头文件了。</p>
<p>使用<code>&lt;bits/stdc++.h&gt;</code>头文件的好处是它简化了代码的编写，因为只需要包含一个头文件即可使用大部分标准库的功能，不需要考虑具体的头文件路径和引入顺序。这在竞赛编程中尤为方便，因为可以节省编写和调试代码所需的时间。</p>
<p>然而，需要注意的是，<code>&lt;bits/stdc++.h&gt;</code>不是标准C++的一部分，它只是某些编译器（如GCC和MinGW）的扩展。因此，在一些特定的开发环境中，可能无法使用这个头文件。此外，它包含了大量标准库的内容，可能会导致编译时间增加，因此在大型项目或需要精细控制的场景中，最好使用具体的标准库头文件，而不是依赖于<code>&lt;bits/stdc++.h&gt;</code>。</p>
<p>总而言之，尽管<code>&lt;bits/stdc++.h&gt;</code>头文件方便编写快速原型和竞赛代码，但在实际开发中，建议使用精确的标准库头文件来保证代码的可读性和可维护性。</p>
<h2 id="中常量和静态变量的区别">中常量和静态变量的区别</h2>
<p>在C++中，常量和静态变量是两种不同的概念。</p>
<ol>
<li>
<p>常量（Constants）：</p>
<ul>
<li>常量是指在程序中声明的固定值，其值在整个程序执行期间不可改变。</li>
<li>常量可以使用<code>const</code>关键字声明，并且必须在声明时进行初始化。</li>
<li>常量的值在编译时确定，并且不能在程序运行时修改。</li>
<li>常量在内存中通常被视为字面值，并且可能会被编译器进行优化。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>静态变量（Static Variables）：</p>
<ul>
<li>静态变量是指在函数内部或者类的成员变量中声明的变量，在程序执行期间保持其值不变。</li>
<li>静态变量在内存中只有一份拷贝，被所有对象或者函数所共享。</li>
<li>静态变量在函数内部时，只会在第一次执行函数时进行初始化，并且在函数调用结束后不会被销毁。</li>
<li>静态成员变量在类中时，可以通过类名和作用域解析运算符来访问。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  count++;</span><br><span class="line">  cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> instanceCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::instanceCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>总结：<br>
常量是指在程序中声明的固定值，其值在整个程序执行期间不可改变。而静态变量是在函数或类中声明的变量，它们的值在程序执行期间保持不变。常量在声明时必须初始化，而静态变量可以在声明时初始化，也可以在需要的时候进行赋值。常量在内存中通常被视为字面值，而静态变量在内存中只有一份拷贝。</p>
<h2 id="为什么常量引用就可以赋普通数值">为什么常量引用就可以赋普通数值</h2>
<p>在C++中，常量引用可以绑定到普通数值，是因为编译器会进行隐式类型转换。</p>
<p>当一个常量引用被初始化为一个普通数值时，编译器会自动进行类型转换，将普通数值转换为一个临时的匿名常量。这个匿名常量与原始的普通数值具有相同的值，但是它被视为一个常量，因此可以绑定到常量引用。</p>
<p>这种隐式类型转换在编译器层面进行，开发者不需要手动进行类型转换操作。这样的设计使得常量引用能够更灵活地与普通数值进行交互，同时保持了对常量的限制。</p>
<p>以下是一个示例，展示了常量引用绑定到普通数值的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(number);  <span class="comment">// 常量引用绑定到普通数值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>printValue</code>函数接受一个常量引用参数，然后打印该值。在<code>main</code>函数中，我们将一个普通数值<code>number</code>作为参数传递给<code>printValue</code>函数。编译器会进行隐式类型转换，将普通数值<code>number</code>转换为一个匿名常量，并将其绑定到函数中的常量引用参数。</p>
<p>需要注意的是，这种隐式类型转换只适用于常量引用，而不能直接应用于非常量引用。如果尝试将一个非常量引用绑定到普通数值，则会引发编译错误。</p>
<h2 id="c-版本">c++版本</h2>
<p>C++98是C++语言的第一个标准化版本，于1998年发布。在C++98之后，还发布了几个C++标准版本，每个版本都引入了新的特性和语言改进。以下是C++98之后的一些重要版本及其主要特性：</p>
<ol>
<li>
<p>C++03（C++98修正版）：</p>
<ul>
<li>C++03于2003年发布，是对C++98标准的一些小修正和改进。</li>
<li>主要修正了一些语言和库的缺陷，提供了更好的兼容性和稳定性。</li>
</ul>
</li>
<li>
<p>C++11（C++0x）：</p>
<ul>
<li>C++11于2011年发布，是C++标准的重大更新。</li>
<li>引入了许多新的语言特性，如自动类型推导（auto关键字）、统一的初始化语法（初始化列表和花括号初始化）、lambda表达式、右值引用（移动语义）、智能指针、范围-based for循环等。</li>
<li>添加了一些标准库组件，如std::thread（多线程编程）、std::regex（正则表达式库）、std::chrono（时间和时钟库）等。</li>
<li>引入了异常规范的改进和新的关键字（例如noexcept和constexpr）。</li>
</ul>
</li>
<li>
<p>C++14：</p>
<ul>
<li>C++14于2014年发布，是对C++11的一些小改进和扩展。</li>
<li>改进了类型推导规则，简化了代码书写。</li>
<li>增加了二进制字面值、通用的lambda捕获初始化、返回类型推导、constexpr函数的放宽等新特性。</li>
<li>扩展了标准库，包括std::make_unique（智能指针的增强版）、std::user-defined literals（自定义字面值）等。</li>
</ul>
</li>
<li>
<p>C++17：</p>
<ul>
<li>C++17于2017年发布，引入了一些重要的新功能。</li>
<li>增加了结构化绑定（structured bindings）、if语句中的初始化、折叠表达式（fold expressions）等语言特性。</li>
<li>扩展了标准库，包括std::optional（可选值）、std::variant（变体类型）、std::any（类型安全的任意类型容器）等。</li>
</ul>
</li>
<li>
<p>C++20：</p>
<ul>
<li>C++20于2020年发布，是一个较大的标准更新。</li>
<li>引入了一些新的语言特性，如概念（Concepts）、协程（Coroutines）、三方运算符（Three-Way Comparison）等。</li>
<li>扩展了标准库，包括std::span（跨度类型）、std::ranges（范围库）、std::format（格式化字符串）等。</li>
</ul>
</li>
</ol>
<p>每个C++标准版本都带来了新的语言特性和库扩展，以提供更好的编程体验和更强大的功能。开发者可以根据目标平台和</p>
<h2 id="CMake是什么">CMake是什么</h2>
<p>CMake是一个跨平台的开源构建工具，用于管理软件项目的构建过程。它可以生成适用于不同编译器和操作系统的构建配置文件（如Makefile、Visual Studio项目文件等），使得开发者能够在不同的平台上方便地构建和管理项目。</p>
<p>CMake的设计目标是提供一种简化和标准化的构建系统，使得开发者能够更容易地跨平台开发和构建软件。它使用一种声明式的方式来描述项目的构建过程，开发者可以编写CMakeLists.txt文件，其中包含了构建配置和规则。</p>
<p>CMake具有以下特点和功能：</p>
<ol>
<li>
<p>跨平台支持：CMake可以在各种操作系统上工作，包括Windows、macOS、Linux等，以及多种编译器和构建工具。</p>
</li>
<li>
<p>简化的语法：CMake使用一种简化的声明式语法，开发者可以通过编写CMakeLists.txt文件来描述项目的构建规则，包括源文件、编译选项、链接库等。</p>
</li>
<li>
<p>自动检测依赖：CMake能够自动检测项目所依赖的外部库和组件，并生成相应的构建配置，以确保构建过程中的依赖关系得到满足。</p>
</li>
<li>
<p>多种构建系统支持：CMake可以生成各种常见的构建系统配置文件，如Makefile、Ninja、Visual Studio项目文件等，使得开发者可以选择他们熟悉的构建工具进行项目构建。</p>
</li>
<li>
<p>嵌套项目支持：CMake支持管理和构建多个嵌套的子项目，使得大型项目可以被分解为多个模块，并方便地进行组织和构建。</p>
</li>
</ol>
<p>使用CMake，开发者可以根据自己的需求和目标平台，编写CMakeLists.txt文件来定义项目的构建过程。然后，通过运行CMake命令来生成适合于不同平台和编译器的构建配置文件，最后使用相应的构建工具进行项目构建。</p>
<p>总结起来，CMake是一个跨平台的开源构建工具，用于管理软件项目的构建过程。它提供了一种简化和标准化的构建系统，使得开发者能够更容易地跨平台开发和构建软件。</p>
<h2 id="头文件条件编译指令">头文件条件编译指令</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span></span><br><span class="line">什么意思</span><br></pre></td></tr></table></figure>
<p>这段代码是C++中的条件编译指令，用于在编译过程中控制头文件的包含。下面解释每一行的含义：</p>
<ol>
<li>
<p><code>#ifndef EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是条件编译指令的开始部分。<code>#ifndef</code>表示&quot;if not defined&quot;，即如果<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>未定义，执行后续操作。</p>
</li>
<li>
<p><code>#define EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是宏定义指令。它定义了一个名为<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>的宏，并将其设置为非零值。这个宏的作用是用于条件判断，后续可以根据这个宏是否被定义来执行不同的代码。</p>
</li>
<li>
<p><code>#endif //EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是条件编译指令的结束部分。<code>#endif</code>表示结束条件编译块，此处是与<code>#ifndef</code>对应的结束。<code>//EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>是一个注释，用于提供对<code>#ifndef</code>的标识说明。</p>
</li>
</ol>
<p>整个代码的作用是，当<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>宏未定义时，执行后续的代码，即将头文件的内容包含在条件编译块中。这样可以避免重复包含头文件，防止多重定义错误。</p>
<p>常见的做法是将这样的条件编译指令放在头文件的开头和结尾，以确保头文件只被编译一次。这样可以防止在多个源文件中包含同一个头文件时出现重复定义的问题。</p>
<h2 id="Clang-Tidy-Function-‘getId’-should-be-marked-nodiscard">Clang-Tidy: Function ‘getId’ should be marked [[nodiscard]]</h2>
<p>这个提示来自于Clang-Tidy，它建议在函数<code>getId</code>上添加<code>[[nodiscard]]</code>属性。</p>
<p><code>[[nodiscard]]</code>是C++17引入的一种属性，用于指示函数的返回值应该被使用，而不是被忽略。当函数被标记为<code>[[nodiscard]]</code>时，编译器会在函数返回值没有被使用时产生警告。</p>
<p>在你的情况下，Clang-Tidy建议在<code>getId</code>函数上添加<code>[[nodiscard]]</code>属性，这意味着调用该函数后应该使用其返回值。如果忽略了该返回值，编译器会发出警告，提醒开发者检查和处理函数的返回值。</p>
<p>为了解决这个警告，你可以按照建议在<code>getId</code>函数声明或定义的地方添加<code>[[nodiscard]]</code>属性，以明确表示该函数的返回值应该被使用。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; ... &#125;  <span class="comment">// 函数声明或定义处添加[[nodiscard]]属性</span></span><br></pre></td></tr></table></figure>
<p>通过遵循这个提示，可以提高代码的可读性和健壮性，防止因为未使用函数返回值而导致的潜在错误。</p>
<h2 id="Clang-Tidy是什么">Clang-Tidy是什么</h2>
<p>Clang-Tidy是一个静态代码分析工具，用于检查和改进C++代码的质量。它是基于LLVM/Clang项目开发的，可以通过对C++代码进行静态分析和规则检查，提供有关代码潜在问题和改进建议的警告和建议。</p>
<p>Clang-Tidy使用Clang编译器的词法和语法分析功能，对代码进行静态分析，以识别潜在的错误、低效的代码、不规范的编码风格以及其他可能影响代码质量和性能的问题。它基于一组预定义的规则（检查器）执行静态代码分析，并生成相应的警告和建议。</p>
<p>Clang-Tidy的一些主要功能和特点包括：</p>
<ol>
<li>
<p>丰富的检查器集合：Clang-Tidy提供了多个内置的检查器，覆盖了各种代码问题，如潜在的错误、代码风格违规、性能问题等。每个检查器都有一个独立的规则集，可以根据需要启用或禁用。</p>
</li>
<li>
<p>可配置性：Clang-Tidy允许用户通过配置文件或命令行选项自定义检查器的行为。用户可以选择性地启用或禁用特定的检查器、调整警告级别，并提供自定义规则和扩展。</p>
</li>
<li>
<p>集成到构建系统：Clang-Tidy可以与常见的构建系统（如CMake和Make）集成，通过构建工具自动执行静态分析，并将警告和建议集成到编译过程中。</p>
</li>
<li>
<p>自动修复：在某些情况下，Clang-Tidy可以自动修复一些常见的代码问题，如修复不规范的代码风格或潜在的错误。这减少了手动修复的工作量，并提高了代码的一致性。</p>
</li>
</ol>
<p>通过使用Clang-Tidy，开发者可以更早地发现和纠正潜在的代码问题，改进代码质量和可维护性，并遵循良好的编码实践。它可以在开发过程中作为一种辅助工具，帮助开发者编写更高质量、更健壮的C++代码。</p>
<h2 id="C-中域是什么">C++中域是什么</h2>
<p>在C++中，域（Scope）是指程序中定义和访问标识符（变量、函数、类等）的可见性和生命周期的范围。每个标识符都存在于特定的域中，并且只能在其所属的域中被访问和使用。</p>
<p>C++中有以下几种类型的域：</p>
<ol>
<li>
<p>全局域（Global Scope）：</p>
<ul>
<li>全局域是整个程序的最外层域，其中定义的标识符在整个程序中都可见。</li>
<li>全局域中定义的变量和函数可以在程序的任何地方使用。</li>
</ul>
</li>
<li>
<p>命名空间域（Namespace Scope）：</p>
<ul>
<li>命名空间是一种用于组织标识符的机制，在C++中可以通过<code>namespace</code>关键字定义。</li>
<li>在命名空间中定义的标识符只在该命名空间中可见，需要使用命名空间限定符才能访问。</li>
</ul>
</li>
<li>
<p>类域（Class Scope）：</p>
<ul>
<li>类域是指类中定义的成员变量和成员函数的可见范围。</li>
<li>在类中定义的成员变量和成员函数只能在类的成员函数中使用，可以通过成员访问操作符（<code>.</code>或<code>-&gt;</code>）来访问。</li>
</ul>
</li>
<li>
<p>局部域（Local Scope）：</p>
<ul>
<li>局部域是指在函数、代码块或循环结构中定义的标识符的可见范围。</li>
<li>在局部域中定义的变量只在其所属的代码块或函数内部可见，超出该范围后将不再可访问。</li>
</ul>
</li>
<li>
<p>语句域（Statement Scope）：</p>
<ul>
<li>语句域是指在语句中定义的标识符的可见范围。</li>
<li>在语句中定义的变量只在该语句中可见，超出该语句后将不再可访问。</li>
</ul>
</li>
</ol>
<p>每个域都有其特定的可见性和生命周期规则。标识符的可见性决定了它在程序的哪些位置可以被访问，而生命周期则指定了标识符在内存中存在的时间范围。理解和正确使用域是编写正确和可维护的C++程序的重要方面。</p>
<h2 id="常见编译器">常见编译器</h2>
<p>C++有多个常用的编译器可用，包括但不限于以下几种：</p>
<ol>
<li>
<p>GCC（GNU Compiler Collection）：这是一个开源的编译器套件，包含了C++编译器（g++）。它是许多Linux发行版的默认编译器，并且可在其他操作系统上使用。</p>
</li>
<li>
<p>Clang：Clang是LLVM项目的一部分，是一个开源的编译器套件。它提供了高性能和高度可配置的C++编译器。Clang也可以作为一个可替代的编译器选择。</p>
</li>
<li>
<p>Microsoft Visual C++：这是Windows平台上的官方C++编译器。它是Microsoft Visual Studio集成开发环境的一部分，提供了丰富的工具和功能。</p>
</li>
<li>
<p>Intel C++ Compiler：这是Intel提供的针对英特尔体系结构的C++编译器。它专注于优化性能，并且在某些情况下可以生成更高效的代码。</p>
</li>
<li>
<p>Clang-CL：这是基于Clang的微软开发的一种编译器，兼容于Windows平台，支持Microsoft Visual Studio开发环境。</p>
</li>
</ol>
<p>以上是一些常用的C++编译器，每个编译器都有其特点和优势。选择编译器时，可以根据特定的需求、平台和个人偏好做出决策。</p>
<h2 id="MinGW">MinGW</h2>
<p>MinGW（Minimalist GNU for Windows）是一个开源的软件开发工具包，旨在为Windows平台提供GNU工具集和开发环境。它基于GCC（GNU Compiler Collection）和binutils，并包括了一系列的工具，如C/C++编译器、链接器、调试器等。</p>
<p>MinGW的目标是在Windows上提供一个轻量级的开发环境，以便开发人员可以使用类Unix的工具和命令来编译、链接和调试他们的代码。它使用GNU工具链，因此能够提供广泛的开发功能和特性。</p>
<p>MinGW的主要优点之一是它允许开发人员在Windows上使用常见的Unix工具和库，而无需依赖于Windows特定的API和工具。这使得开发人员能够更容易地将他们的代码从Unix/Linux平台移植到Windows平台。</p>
<p>另一个重要的特点是MinGW提供了一个轻量级的替代品，相对于使用完整的Visual Studio开发环境，它可以更快地进行编译和构建。这使得MinGW成为一种流行的选择，特别是对于需要快速原型设计和小型项目开发的开发人员。</p>
<p>总而言之，MinGW是一个提供GNU工具集和开发环境的软件开发工具包，用于在Windows平台上进行C/C++开发。它为开发人员提供了一种在Windows上使用Unix工具和库的简便方式，以及更快的编译和构建速度。</p>
<h2 id="GNU">GNU</h2>
<p>GNU是一个自由软件运动的项目，目标是为用户提供自由的计算机操作系统。GNU项目的全称是“GNU’s Not Unix”，这是一个递归缩写，意思是“GNU不是Unix”。它的目标是创建一个类Unix的操作系统，但不依赖于Unix的代码。</p>
<p>GNU项目始于1983年，由理查德·斯托曼（Richard Stallman）发起。斯托曼意识到许多计算机用户面临私有软件的限制，无法查看、修改和分享软件的源代码。为了解决这个问题，他发起了GNU项目，旨在开发一个完全自由的操作系统。</p>
<p>GNU项目包括了许多关键的组件，如GNU编译器集合（GCC）、GNU调试器（GDB）、GNU Bash shell、GNU核心工具集（Coreutils）等。这些组件形成了一个完整的自由软件堆栈，可用于构建自由操作系统。</p>
<p>然而，GNU项目中唯一尚未完成的部分是操作系统内核。为了填补这个空白，GNU项目与Linux内核相结合，形成了今天被广泛使用的GNU/Linux操作系统。GNU/Linux操作系统的基础是Linux内核，但它包含了许多GNU项目的组件，使得用户能够使用自由软件构建和定制他们的系统。</p>
<p>总而言之，GNU是一个自由软件运动的项目，旨在为用户提供自由的计算机操作系统。它的组件构成了一个完整的自由软件堆栈，并与Linux内核结合形成了GNU/Linux操作系统。GNU项目强调用户自由、开放源代码和共享，对于自由软件的发展和推广做出了重要贡献。</p>
<h2 id="OpenGL">OpenGL</h2>
<p>OpenGL（Open Graphics Library）是一个用于渲染2D和3D图形的跨平台编程接口（API）。它是一个开放标准，由Khronos Group维护和推进。OpenGL提供了一系列的函数，用于操作图形硬件和执行图形计算，使开发人员能够创建高性能的图形应用程序。</p>
<p>OpenGL可以用于各种平台，包括Windows、macOS、Linux以及移动平台如Android和iOS。它与硬件无关，能够利用图形加速硬件（如图形处理器）来实现快速而逼真的图形渲染。</p>
<p>OpenGL提供了一系列功能和操作，包括几何图元绘制、纹理映射、光照、深度测试、着色器编程等。它使用一种状态机模型，通过设置不同的状态来定义绘图操作和渲染效果。开发人员可以使用OpenGL来创建各种类型的图形应用程序，包括游戏、可视化工具、模拟器、CAD软件等。</p>
<p>OpenGL的主要优点包括：</p>
<ol>
<li>
<p>跨平台：OpenGL可在多个平台上使用，使开发人员能够编写一次代码并在不同的系统上运行。</p>
</li>
<li>
<p>高性能：OpenGL能够利用硬件加速来实现高效的图形渲染，提供流畅的用户体验。</p>
</li>
<li>
<p>可扩展性：OpenGL支持扩展，开发人员可以利用额外的功能和特性来满足特定需求。</p>
</li>
<li>
<p>开放标准：OpenGL是一个开放的标准，各个硬件和软件供应商可以实现和支持它，确保了广泛的兼容性和可移植性。</p>
</li>
</ol>
<p>总而言之，OpenGL是一个跨平台的图形渲染API，用于创建高性能的2D和3D图形应用程序。它提供了丰富的功能和操作，可用于绘制几何图元、应用纹理、执行光照和着色器编程等。通过利用硬件加速，OpenGL能够实现快速而逼真的图形渲染，广泛应用于游戏开发、可视化工具、CAD软件等领域。</p>
<h2 id="Iceberg">Iceberg</h2>
<p>在计算机科学中，“Iceberg”（冰山）技术通常指的是一种数据管理和查询优化技术，用于处理大规模数据集中的稀疏数据。</p>
<p>Iceberg技术的目标是提高处理大型数据集中稀疏数据的效率。在许多实际应用中，数据集中只有少部分数据是频繁访问的，而大部分数据则很少被使用。传统的数据存储和查询方法会对整个数据集进行处理，包括那些很少被使用的数据，从而浪费了计算资源和存储空间。</p>
<p>Iceberg技术通过将数据分成热数据（频繁访问的数据）和冷数据（很少访问的数据）两个部分来解决这个问题。热数据通常被保留在高性能的存储介质上，而冷数据则被移动到低成本的存储介质上，如分布式文件系统或对象存储。这样一来，只有热数据需要频繁访问，而冷数据可以以更低的成本存储和管理。</p>
<p>Iceberg技术还可以针对热数据应用各种优化技术，例如数据压缩、索引和分区，以提高查询性能。此外，它还提供了数据版本控制和事务支持，使得数据的更新和变更能够被有效地管理和追踪。</p>
<p>Iceberg技术在大数据处理领域得到了广泛应用，特别是在数据湖和数据仓库的构建和管理中。它提供了一种灵活而高效的方式来处理和查询大规模数据集，同时减少了存储成本和查询时间。</p>
<h2 id="HDFS">HDFS</h2>
<p>HDFS（Hadoop Distributed File System）是Apache Hadoop生态系统中的一项关键技术，它是一种用于存储和处理大规模数据集的分布式文件系统。</p>
<p>HDFS的设计目标是在大规模集群上提供高容错性、高吞吐量和可伸缩性的数据存储解决方案。它基于主从架构，其中包括一个主节点（NameNode）和多个从节点（DataNode）组成。HDFS将数据划分为固定大小的数据块，并将这些数据块存储在从节点上。主节点负责管理文件系统的元数据，如文件的名称、位置和权限等。</p>
<p>HDFS的主要特点包括：</p>
<ol>
<li>
<p>分布式存储：数据被分散存储在多个从节点上，可以横向扩展以适应大规模数据集的存储需求。</p>
</li>
<li>
<p>冗余备份：HDFS会将数据块复制到多个从节点上，以提供数据的冗余备份和容错性。通常，默认情况下，每个数据块会有三个副本存储在不同的从节点上。</p>
</li>
<li>
<p>高容错性：当从节点发生故障或数据损坏时，HDFS能够自动检测和恢复数据，确保数据的可靠性。</p>
</li>
<li>
<p>适合大数据处理：HDFS的设计使其适合处理大规模数据集的工作负载。它通过数据本地性和并行计算来提高数据处理的效率。</p>
</li>
</ol>
<p>HDFS被广泛应用于大数据处理和分析领域。它为许多分布式计算框架（如MapReduce）提供了数据存储和访问的基础，并支持对大规模数据集的高效处理和分析。</p>
<h2 id="Opencv">Opencv</h2>
<p>OpenCV（Open Source Computer Vision）是一个开源的计算机视觉库，旨在提供一系列用于图像处理、计算机视觉和机器学习的函数和工具。它是一个广泛使用的库，可用于开发各种视觉应用程序，包括图像和视频处理、目标检测和跟踪、人脸识别、机器学习等。</p>
<p>OpenCV最初由英特尔公司于1999年发起，后来成为一个跨平台的开源项目。它使用C++语言编写，但也提供了许多其他编程语言的接口，包括Python、Java和MATLAB等，使得开发人员可以方便地在不同的环境中使用OpenCV。</p>
<p>OpenCV提供了大量的函数和算法，用于处理图像和视频数据。它支持基本的图像操作（如裁剪、调整大小、滤波等）、特征提取和描述（如边缘检测、角点检测、直线检测等）、图像匹配和配准、运动估计、三维重建等。此外，OpenCV还包含了许多机器学习算法的实现，如支持向量机（SVM）、随机森林（Random Forests）、神经网络等，用于目标分类和识别。</p>
<p>OpenCV被广泛应用于计算机视觉领域的研究和开发中，它在学术界和工业界都有很高的声誉和应用价值。无论是进行基础的图像处理还是复杂的计算机视觉任务，OpenCV都提供了丰富的功能和工具，使得开发者能够快速实现他们的视觉应用。</p>
<h2 id="命名空间在项目开发中的作用">命名空间在项目开发中的作用</h2>
<p>在项目开发中，命名空间具有以下几个重要的作用：</p>
<ol>
<li>
<p>避免命名冲突：命名空间可以将代码标识符（变量、函数、类等）分组和隔离，避免不同部分的代码之间的命名冲突。不同的命名空间中可以使用相同名称的标识符，因为它们的作用域被限定在各自的命名空间内。</p>
</li>
<li>
<p>提供代码组织和模块化：通过将相关的代码放置在同一个命名空间中，可以提供逻辑上的分组和组织，使得代码结构更加清晰和可维护。命名空间可以按照功能、模块或层次结构进行组织，使得开发人员能够更容易地理解和维护代码。</p>
</li>
<li>
<p>增加可读性和可扩展性：通过在代码中使用命名空间，可以提高代码的可读性和可理解性。命名空间可以为代码添加上下文和语义，使得代码的意图更加清晰。此外，命名空间也为项目的扩展性提供了支持，因为新的代码可以添加到现有的命名空间中，而无需修改或重构现有代码。</p>
</li>
<li>
<p>允许使用相同名称的标识符：不同的命名空间中可以使用相同名称的标识符，而不会发生冲突。这对于与第三方库或其他模块集成时特别有用，可以避免不同模块之间的名称冲突，并支持更好的代码重用和组合。</p>
</li>
<li>
<p>限定标识符的作用域：命名空间通过命名空间限定符（<code>::</code>）来限定标识符的作用域。这可以使得代码更加明确和可控，避免全局作用域的滥用。只有在需要使用特定命名空间中的标识符时，才需要显式地引用它们，提高了代码的可维护性和可读性。</p>
</li>
</ol>
<p>总的来说，命名空间在项目开发中起到了隔离、组织和管理代码的作用。它们提供了一种结构化的方式来处理命名冲突，并提高了代码的可读性、可维护性和可扩展性。通过合理地使用命名空间，可以更好地组织项目代码，减少潜在的问题，并提高团队协作的效率。</p>
<h2 id="explicit">explicit</h2>
<p>在C++中，<code>explicit</code>是一个关键字，用于修饰类的单参数构造函数（或除默认参数外的多参数构造函数）。使用<code>explicit</code>关键字可以防止隐式的类型转换发生。</p>
<p>通常情况下，当我们定义一个只有一个参数的构造函数时，编译器会自动将该构造函数用于隐式类型转换。这意味着，当我们使用该类的对象进行赋值、初始化或作为函数参数时，编译器会自动进行类型转换。</p>
<p>下面是一个示例，展示了没有使用<code>explicit</code>关键字时，构造函数的隐式类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with MyClass object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">5</span>;   <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="built_in">doSomething</span>(<span class="number">10</span>);   <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>MyClass</code>类定义了一个单参数构造函数，该构造函数接受一个<code>int</code>类型的参数。在<code>main()</code>函数中，我们使用整数值进行赋值和函数调用，编译器会自动进行隐式类型转换来创建<code>MyClass</code>对象。</p>
<p>然而，有时候我们希望明确地控制类型转换，避免出现意外的转换行为。这时就可以使用<code>explicit</code>关键字来声明构造函数，并禁止隐式类型转换。</p>
<p>下面是使用<code>explicit</code>关键字修饰构造函数的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> : m_value(value) &#123;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with MyClass object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">5</span>;    <span class="comment">// 错误，禁止隐式类型转换</span></span><br><span class="line">    <span class="built_in">doSomething</span>(<span class="number">10</span>);    <span class="comment">// 错误，禁止隐式类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们在构造函数前面加上了<code>explicit</code>关键字。这意味着构造函数只能被显式调用，而禁止了隐式类型转换。在<code>main()</code>函数中的赋值和函数调用将会导致编译错误。</p>
<p>通过使用<code>explicit</code>关键字，我们可以更加明确地控制对象的创建和类型转换，避免一些潜在的错误和意外行为。但需要注意，使用<code>explicit</code>关键字可能会导致一些代码的冗长性和不便利性，需要根据实际需求和设计考虑是否使用。</p>
<h2 id="构造函数的-后面加上-是什么意思">构造函数的()后面加上;是什么意思</h2>
<p>在C++中，构造函数的()后面加上;是表示一个成员初始化列表（member initializer list）的开始。</p>
<p>构造函数在创建对象时被调用，用于初始化对象的成员变量。成员初始化列表提供了一种在构造函数体之前初始化成员变量的方式。通过在构造函数的定义中使用成员初始化列表，可以直接为成员变量赋值或调用它们的构造函数。</p>
<p>下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，构造函数的定义是 <code>MyClass(int value) : m_value(value) &#123;&#125;</code>。在<code>:</code>之后是成员初始化列表，其中的<code>m_value(value)</code>表示将参数<code>value</code>的值赋给成员变量<code>m_value</code>。这样，在构造函数体之前，成员变量<code>m_value</code>就已经被初始化。</p>
<p>通过使用成员初始化列表，可以在构造函数体之前对成员变量进行初始化，避免在构造函数体中进行赋值操作，提高代码的效率和可读性。此外，对于一些类类型的成员变量，成员初始化列表还可以调用它们的构造函数进行初始化。</p>
<p>需要注意的是，成员初始化列表只能用于构造函数中，用于初始化成员变量，不能用于其他成员函数。并且，成员初始化列表的顺序应该与成员变量在类中声明的顺序一致，以避免出现潜在的问题。</p>
<p>总结起来，构造函数的()后面加上;表示一个成员初始化列表的开始。成员初始化列表用于在构造函数体之前对成员变量进行初始化，提供了一种效率高且可读性好的初始化方式。通过成员初始化列表，可以直接为成员变量赋值或调用它们的构造函数。</p>
<h2 id="NDK">NDK</h2>
<p>C++的NDK（Native Development Kit）是一组工具和库，用于开发使用C++编写的Android应用程序。NDK允许开发人员在Android平台上编写高性能的原生代码，通常用于处理计算密集型任务、访问系统硬件和优化性能。</p>
<p>以下是关于C++的NDK的一些关键概念和使用方法：</p>
<ol>
<li>
<p>NDK的目的：NDK的主要目的是提供一种在Android应用程序中使用C++编写的原生代码的方法。使用C++可以在性能上优化应用程序，处理复杂的计算任务，访问系统级别的API和设备功能，或重用现有的C/C++库。</p>
</li>
<li>
<p>NDK工具链：NDK提供了一套工具链，包括交叉编译器、调试器和构建工具。这些工具链允许将C++代码编译为适用于Android平台的本机机器码。</p>
</li>
<li>
<p>CMake构建系统：NDK推荐使用CMake作为构建系统，用于生成Android应用程序的本机代码。CMake是一个跨平台的构建工具，它可以帮助您定义构建过程和依赖关系，并生成适用于Android的Makefile。</p>
</li>
<li>
<p>JNI接口：在使用NDK开发时，C++代码与Java代码之间的交互通过JNI（Java Native Interface）实现。JNI允许在Java和C++之间进行函数调用和数据传递。</p>
</li>
<li>
<p>支持的ABI：ABI（Application Binary Interface）是指应用程序和操作系统之间的二进制接口规范。NDK支持多个ABI，包括armeabi、armeabi-v7a、arm64-v8a、x86和x86_64。开发人员可以选择适合其应用程序的ABI，以实现最佳的性能和兼容性。</p>
</li>
<li>
<p>使用第三方库：NDK还允许开发人员使用现有的C/C++库，如OpenCV、Boost等。通过在NDK构建脚本中配置和链接这些库，可以轻松地将它们与Android应用程序集成在一起。</p>
</li>
<li>
<p>调试和性能分析：NDK提供了调试工具和性能分析工具，以帮助开发人员调试和优化其原生代码。例如，可以使用ndk-gdb命令行工具进行调试，使用perf工具进行性能分析。</p>
</li>
</ol>
<p>请注意，使用NDK编写原生代码需要一定的C++编程知识和Android开发经验。它主要适用于需要高性能计算、底层硬件访问或与现有C/C++库集成的情况。对于一般的Android应用程序开发，通常建议优先考虑使用Java或Kotlin编写代码。</p>
<h1>数据类型</h1>
<h2 id="基本数据类型">基本数据类型</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083744623.png" alt="image-20230613083744623"></p>
<h2 id="复合数据类型">复合数据类型</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083845493.png" alt="image-20230613083845493"></p>
<h2 id="指针类型">指针类型</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083858532.png" alt="image-20230613083858532"></p>
<h2 id="枚举类型">枚举类型</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083909897.png" alt="image-20230613083909897"></p>
<h2 id="其他数据类型">其他数据类型</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083920385.png" alt="image-20230613083920385"></p>
<h1>类</h1>
<h2 id="例子">例子</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> studentId, <span class="type">const</span> std::string&amp; studentName, <span class="type">int</span> studentAge) &#123;</span><br><span class="line">        id = studentId;</span><br><span class="line">        name = studentName;</span><br><span class="line">        age = studentAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Student ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取学生姓名</span></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置学生姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; studentName)</span> </span>&#123;</span><br><span class="line">        name = studentName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="this">this</h2>
<p>在C++中，关键字<code>this</code>表示当前对象的指针。它是一个隐式的指针，指向调用成员函数的对象本身。通过<code>this</code>指针，可以在类的成员函数中访问和操作当前对象的成员变量和成员函数。</p>
<p>以下是一个简单的示例代码，演示了<code>this</code>关键字的用途：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_value = value;  <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Address: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;  <span class="comment">// 打印this指针的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>();     <span class="comment">// 输出: Value: 42</span></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">24</span>);     <span class="comment">// 使用成员函数设置新的值</span></span><br><span class="line">    obj.<span class="built_in">printValue</span>();     <span class="comment">// 输出: Value: 24</span></span><br><span class="line">    obj.<span class="built_in">printAddress</span>();   <span class="comment">// 打印对象的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>MyClass</code>类包含一个整型成员变量<code>m_value</code>和几个成员函数。在<code>setValue()</code>函数中，使用<code>this</code>指针访问并修改了当前对象的成员变量<code>m_value</code>。<code>printAddress()</code>函数使用<code>this</code>指针打印了当前对象的地址。</p>
<p>在<code>main()</code>函数中，我们创建了一个<code>MyClass</code>对象<code>obj</code>并调用了一系列成员函数。通过使用<code>this</code>指针，我们可以在成员函数中访问和操作对象的成员变量，确保了对当前对象的正确引用。</p>
<p>需要注意的是，<code>this</code>指针在成员函数内部是一个自动提供的指针，无需显式声明或初始化。它是一个常量指针，不允许修改它指向的对象。</p>
<p>总结起来，<code>this</code>关键字在C++中表示当前对象的指针，用于在类的成员函数中访问和操作当前对象的成员变量和成员函数。通过使用<code>this</code>指针，可以确保正确引用当前对象，并进行对象内部的操作和交互。</p>
<h2 id="继承">继承</h2>
<p>在C++中，继承是一种面向对象编程的重要概念，它允许你创建一个新类（称为子类或派生类），该类继承了另一个类（称为基类或父类）的属性和行为。子类可以继承基类的成员变量和成员函数，并且可以扩展或修改它们。以下是关于继承的一些要点：</p>
<ol>
<li>
<p>基类和派生类：</p>
<ul>
<li>基类是已经存在的类，它提供了一组通用的属性和行为。</li>
<li>派生类是从基类派生而来的新类，它继承了基类的属性和行为，并且可以添加自己的属性和行为。</li>
</ul>
</li>
<li>
<p>语法：</p>
<ul>
<li>在C++中，使用冒号 <code>:</code> 来指定派生类继承基类。例如：<code>class Derived : public Base</code> 表示派生类 <code>Derived</code> 继承了基类 <code>Base</code>。</li>
<li>继承关系可以是公有（public）、私有（private）或保护（protected）。公有继承意味着基类的公有成员在派生类中仍然是公有的，私有继承和保护继承会有相应的访问限制。</li>
</ul>
</li>
<li>
<p>继承类型：</p>
<ul>
<li>公有继承（public inheritance）：派生类继承了基类的公有成员和保护成员，但私有成员不可直接访问。</li>
<li>私有继承（private inheritance）：派生类继承了基类的所有成员，但它们都变成了私有成员，只能在派生类内部访问。</li>
<li>保护继承（protected inheritance）：派生类继承了基类的保护成员和公有成员，但它们都变成了保护成员，只能在派生类内部和派生类的子类中访问。</li>
</ul>
</li>
<li>
<p>成员访问权限：</p>
<ul>
<li>派生类可以访问基类的公有和保护成员，但不能直接访问基类的私有成员。</li>
<li>派生类可以通过成员函数和友元函数来访问基类的私有成员。</li>
<li>在派生类中，可以使用作用域解析运算符 <code>::</code> 来引用基类的成员。</li>
</ul>
</li>
<li>
<p>重写和扩展：</p>
<ul>
<li>派生类可以重写（override）基类的成员函数，即在派生类中重新实现基类中已有的函数。这允许派生类提供自己的实现。</li>
<li>派生类还可以添加新的成员函数和数据成员，从而扩展基类的功能。</li>
</ul>
</li>
</ol>
<p>以下是一个简单的示例，演示了继承：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; <span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">Shape</span>(w, h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">Shape</span>(w, h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="继承和访问关系">继承和访问关系</h2>
<table>
<thead>
<tr>
<th></th>
<th>基类的公有成员</th>
<th>基类的保护成员</th>
<th>基类的私有成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>公有继承</td>
<td>可访问</td>
<td>可访问</td>
<td>不可访问</td>
</tr>
<tr>
<td>保护继承</td>
<td>保护</td>
<td>保护</td>
<td>不可访问</td>
</tr>
<tr>
<td>私有继承</td>
<td>私有</td>
<td>私有</td>
<td>不可访问</td>
</tr>
</tbody>
</table>
<h2 id="派生类访问基类私有成员">派生类访问基类私有成员</h2>
<p>在C++中，派生类是基类的扩展，可以继承基类的成员（公有、受保护和私有）。私有成员是基类中具有最高访问权限的成员，只能在基类的成员函数和友元函数中直接访问。然而，派生类可以通过以下两种方式访问基类的私有成员：</p>
<ol>
<li>
<p>成员函数：</p>
<ul>
<li>派生类可以通过继承基类的公有和受保护成员函数，间接地访问基类的私有成员。</li>
<li>由于派生类继承了基类的成员函数，这些成员函数在派生类中仍然可以访问基类的私有成员。</li>
</ul>
</li>
<li>
<p>友元函数：</p>
<ul>
<li>如果基类将派生类声明为友元类，那么派生类的成员函数和友元函数可以直接访问基类的私有成员。</li>
<li>友元函数是在类外部声明的函数，可以访问该类的私有成员，因此通过将派生类声明为基类的友元类，可以使派生类的成员函数和友元函数访问基类的私有成员。</li>
</ul>
</li>
</ol>
<p>通过这两种方式，派生类可以在某种程度上访问基类的私有成员，但需要注意的是，派生类应该尽量遵循封装原则，尽量不直接访问基类的私有成员，以保持类的封装性和数据的安全性。</p>
<p>以下是一个示例，演示了派生类通过成员函数和友元函数访问基类的私有成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Derived</span>;  <span class="comment">// 将Derived声明为Base的友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessBasePrivateMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> val = privateVar;  <span class="comment">// 可以访问基类的私有成员</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&#x27;s privateVar through Derived: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    derived.<span class="built_in">accessBasePrivateMember</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Base</code> 类具有一个私有成员变量 <code>privateVar</code>，而 <code>Derived</code> 类通过公有继承继承了 <code>Base</code> 类，并且将 <code>Derived</code> 声明为 <code>Base</code> 的友元类。因此，<code>Derived</code> 类的成员函数 <code>accessBasePrivateMember()</code> 可以直接访问基类 <code>Base</code> 的私有成员变量 <code>privateVar</code>。</p>
<p>需要注意的是，友元关系是单向的，即在上面的示例中，<code>Derived</code> 类可以访问 <code>Base</code> 类的私有成员，但 <code>Base</code> 类不能访问 <code>Derived</code> 类的私有成员。友元关系应该谨慎使用，以确保访问权限的正确性和安全性。</p>
<h2 id="override">override</h2>
<p>在C++中，<code>override</code> 关键字用于显式地标识派生类中的成员函数，表示该函数是对基类中的虚函数进行重写。<code>override</code> 关键字有助于提高代码的可读性，并在编译时进行检查，以确保正确地重写了基类的虚函数。</p>
<p>使用 <code>override</code> 的一般语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">Derived::function_name</span><span class="params">(parameters)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在派生类中重写基类的虚函数时，使用 <code>override</code> 关键字将其放置在函数声明的末尾。编译器会验证该函数是否正确地重写了基类的虚函数，如果未找到匹配的基类虚函数，或者函数签名不匹配，则会产生编译错误。</p>
<p>下面是一个示例，演示了如何使用 <code>override</code> 关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is the base class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is the derived class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    basePtr-&gt;<span class="built_in">printMessage</span>();  <span class="comment">// 输出: &quot;This is the derived class.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Base</code> 类定义了一个虚函数 <code>printMessage()</code>，而 <code>Derived</code> 类通过公有继承重写了该函数。在 <code>Derived</code> 类中，使用 <code>override</code> 关键字标识了对基类函数的重写。</p>
<p>在 <code>main()</code> 函数中，我们创建了一个指向 <code>Derived</code> 类对象的基类指针 <code>basePtr</code>，并调用了 <code>printMessage()</code> 函数。由于基类指针指向派生类对象，因此调用的是派生类中重写的函数。输出结果为 “This is the derived class.”。</p>
<p>通过使用 <code>override</code> 关键字，可以确保在派生类中正确地重写了基类的虚函数，以实现多态行为。如果派生类中的函数签名与基类虚函数不匹配，编译器将发出错误提示，帮助我们检测潜在的错误。</p>
<h2 id="虚函数">虚函数</h2>
<p>虚函数是在基类中声明为虚函数的成员函数，用于实现多态性（polymorphism）。多态性是面向对象编程的一个重要特性，它允许通过基类的指针或引用来调用派生类的特定实现。</p>
<p>虚函数的作用包括：</p>
<ol>
<li>
<p>实现运行时多态：通过基类的指针或引用调用虚函数时，根据实际对象的类型确定要调用的函数版本。这样可以在运行时确定调用哪个派生类的函数实现，实现了多态性。</p>
</li>
<li>
<p>提供接口的扩展性：通过在基类中声明虚函数，可以让派生类根据需要进行函数的重写，从而实现接口的扩展。这样，基类的指针或引用可以灵活地调用不同派生类的不同实现。</p>
</li>
</ol>
<p>要将函数声明为虚函数，需要在基类中使用 <code>virtual</code> 关键字进行声明。派生类中重写虚函数时，可以使用 <code>override</code> 关键字显式标识。</p>
<p>以下是一个示例，演示了虚函数的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: &quot;Drawing a circle.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Shape</code> 类是一个基类，其中的 <code>draw()</code> 函数被声明为虚函数。<code>Circle</code> 和 <code>Rectangle</code> 类分别是 <code>Shape</code> 类的派生类，并在派生类中重写了 <code>draw()</code> 函数。</p>
<p>在 <code>main()</code> 函数中，我们创建了一个基类指针 <code>shapePtr</code>，并将其指向 <code>Circle</code> 类的对象。通过该指针调用 <code>draw()</code> 函数时，由于函数是虚函数，程序在运行时确定要调用的函数版本，因此调用的是 <code>Circle</code> 类中重写的函数。输出结果为 “Drawing a circle.”。</p>
<p>通过使用虚函数，我们可以根据实际对象的类型来动态选择要调用的函数版本，实现了多态性和接口的扩展性。这是面向对象编程中的重要概念，有助于编写灵活、可扩展的代码。</p>
<h1>const</h1>
<p>在C++中，<code>const</code>是一个关键字，用于声明常量或指示对象为只读。<code>const</code>关键字可以应用于变量、函数参数、函数返回类型和成员函数。</p>
<p>以下是<code>const</code>关键字的使用方法和注意事项：</p>
<ol>
<li>声明常量：<code>const</code>关键字可以用于声明常量，即数值在程序执行期间不可修改的值。常量在声明时必须进行初始化，并且在后续的代码中不能被修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>声明只读变量：将<code>const</code>关键字应用于变量时，表示该变量的值不可被修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* constPtr = &amp;x;  <span class="comment">// 指向常量的指针，不可通过指针修改变量的值</span></span><br><span class="line"><span class="comment">// *constPtr = 10;  // 错误，不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">10</span>;  <span class="comment">// 声明只读变量，不可修改</span></span><br><span class="line"><span class="comment">// y = 20;  // 错误，不可修改</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>函数参数：将参数声明为<code>const</code>可以确保在函数内部不会修改参数的值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value = 10;  // 错误，不可修改</span></span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>函数返回类型：将函数返回类型声明为<code>const</code>表示返回的对象是只读的，不可在调用端进行修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">getValue</span>();</span><br><span class="line"><span class="comment">// getValue() = 10;  // 错误，不可修改返回值</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>声明为<code>const</code>的变量必须在声明时进行初始化，并且不能在后续的代码中修改。</li>
<li>声明为<code>const</code>的对象只能调用其成员函数中被声明为<code>const</code>的函数。</li>
<li><code>const</code>修饰符在指针类型中具有两个作用：<code>const int*</code>表示指向常量的指针，<code>int* const</code>表示常量指针（指针本身是常量）。</li>
<li>当将<code>const</code>修饰符应用于类的成员函数时，表示该函数不会修改类的成员变量。</li>
</ul>
<p>使用<code>const</code>关键字可以增加代码的可读性和安全性，防止不必要的变量修改和意外的副作用。合理使用<code>const</code>可以帮助编译器进行优化，并提供更好的代码维护性。同时，需要注意在使用<code>const</code>修饰时，确保遵守<code>const</code>修饰符的规则，避免出现编译错误。</p>
<h1>final</h1>
<p><code>final</code>是C++11引入的关键字，用于限制类、函数和继承关系的扩展性。以下是<code>final</code>关键字的使用方法和一些注意事项：</p>
<ol>
<li>类的<code>final</code>修饰：将<code>final</code>关键字放在类声明的末尾，表示该类不能被继承。这样可以防止其他类从该类派生，并覆盖或扩展其功能。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  <span class="comment">// 错误，无法从final类Derived继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>函数的<code>final</code>修饰：将<code>final</code>关键字放在虚函数声明的末尾，表示该虚函数不能在派生类中被重写。这样可以确保派生类无法修改基类的特定行为。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 错误，无法重写被声明为final的虚函数foo()</span></span><br><span class="line">    <span class="comment">// void foo() override &#123;</span></span><br><span class="line">    <span class="comment">//     // ...</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>继承关系中的<code>final</code>修饰：将<code>final</code>关键字放在派生类声明的末尾，表示该派生类不能有后续的派生类。这样可以在继承链上指定最后一个派生类，防止进一步的扩展。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> <span class="keyword">final</span> : <span class="keyword">public</span> Derived1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived3</span> : <span class="keyword">public</span> Derived2 &#123;  <span class="comment">// 错误，无法从final类Derived2继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用<code>final</code>关键字的注意事项：</p>
<ul>
<li><code>final</code>关键字用于限制扩展性，应谨慎使用。在设计类和继承关系时，应仔细考虑是否真正需要限制继承和函数重写。</li>
<li>使用<code>final</code>关键字可以增强类的安全性和稳定性，特别是用于基类或核心函数，以防止它们被修改。</li>
<li>避免滥用<code>final</code>关键字，过多地使用可能导致继承层次结构变得过于僵硬和不灵活。</li>
<li>在继承关系中，使用<code>final</code>关键字可以明确地指定最后一个派生类，以确保继承链的终结。</li>
<li><code>final</code>关键字适用于类、虚函数和继承关系，但不适用于非虚普通函数。</li>
<li>在使用<code>final</code>关键字时，应保持代码清晰，以便其他开发人员能够理解和维护代码。</li>
</ul>
<p>总的来说，<code>final</code>关键字提供了一种在类、函数和继承关系中限制扩展性的</p>
<p>机制。适当地使用<code>final</code>可以增强代码的安全性和稳定性，但需要注意不要滥用它，以免造成代码的僵化和不灵活。</p>
<h1>指针和引用的区别</h1>
<p>指针和引用是C++中用于处理内存和对象的重要概念，它们有以下区别：</p>
<ol>
<li>
<p>指针可以被重新赋值，而引用一旦绑定到对象，就不能更改绑定的对象。</p>
</li>
<li>
<p>指针可以是空值（nullptr），即指向空地址，而引用必须在声明时绑定到一个对象。</p>
</li>
<li>
<p>指针可以指向多个不同的对象，而引用只能绑定到一个对象，并且不能更改为引用其他对象。</p>
</li>
<li>
<p>指针可以进行指针运算（如指针加法、指针减法等），而引用没有指针运算。</p>
</li>
<li>
<p>指针可以被重新分配内存，而引用不能。</p>
</li>
<li>
<p>引用通常用作函数的参数或返回类型，以实现传递参数或返回值的效果。指针也可以用于相同的目的，但引用通常更直观和安全。</p>
</li>
</ol>
<p>下面是一些示例代码来说明指针和引用之间的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyPointer</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;  <span class="comment">// 修改指针所指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyReference</span><span class="params">(<span class="type">int</span>&amp; ref)</span> </span>&#123;</span><br><span class="line">    ref = <span class="number">200</span>;  <span class="comment">// 修改引用所绑定的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;num;  <span class="comment">// 指针指向num</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = num;  <span class="comment">// 引用绑定到num</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">modifyPointer</span>(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value after modifying pointer: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">// 输出: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">modifyReference</span>(ref);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value after modifying reference: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">// 输出: 200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了一个整数变量 <code>num</code>，并创建了一个指向该变量的指针 <code>ptr</code> 和一个引用 <code>ref</code>。然后，我们编写了两个函数 <code>modifyPointer()</code> 和 <code>modifyReference()</code>，分别用于修改指针和引用所指向的值。</p>
<p>在 <code>main()</code> 函数中，我们首先通过指针调用 <code>modifyPointer()</code> 函数来修改指针所指向的值，并输出修改后的值。然后，通过引用调用 <code>modifyReference()</code> 函数来修改引用所绑定的值，并再次输出修改后的值。在两次输出中，我们可以看到变量 <code>num</code> 的值被成功修改。</p>
<p>通过比较指针和引用的使用方式和功能，可以选择适合特定情况的方法。指针提供了更大的灵活性，可以用于动态分配内存和处理数据结构，而引用提供了更简洁的语法和更安全的操作，常用于函数参数传递和返回值。</p>
<h1>宏定义</h1>
<p>在C++中，宏定义（Macro Definition）是一种预处理指令，用于在编译之前将代码中的标识符替换为指定的文本。它们是通过预处理器（Preprocessor）在编译阶段执行的，而不是在运行时。</p>
<p>宏定义使用<code>#define</code>指令来创建，语法形式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名称 替换文本</span></span><br></pre></td></tr></table></figure>
<p>其中，宏名称是你自定义的标识符，替换文本是要替换成的代码片段或值。宏名称通常使用大写字母命名，以便与其他标识符区分开来。</p>
<p>宏定义可以用于替换任意代码片段，包括表达式、语句、函数调用等。例如，下面是一个简单的宏定义示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    <span class="type">double</span> area = PI * radius * radius;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，宏定义<code>#define PI 3.14159</code>将标识符<code>PI</code>替换为值<code>3.14159</code>。在<code>main()</code>函数中，我们使用<code>PI</code>宏来计算圆的面积。</p>
<p>宏定义还可以带有参数，称为宏函数（Macro Function）。宏函数的语法与函数类似，可以接受参数并在替换文本中使用它们。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">SQUARE</span>(<span class="number">5</span>);   <span class="comment">// 展开为 ((5) * (5))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，宏函数<code>#define SQUARE(x) ((x) * (x))</code>将传入的参数<code>x</code>平方并返回结果。</p>
<p>需要注意的是，宏定义是简单的文本替换，没有类型检查和作用域限制。它们在预处理阶段直接替换代码，可能导致一些意想不到的行为。因此，在使用宏定义时需要谨慎，避免引入不可预测的问题。</p>
<p>此外，C++中还有一些预定义的宏，如<code>__FILE__</code>（当前源文件名）、<code>__LINE__</code>（当前行号）和<code>__cplusplus</code>（用于检查C++编译环境）等。这些预定义的宏在不同的编译器中可能有所差异，可以根据需要使用它们来获取一些编译时的信息。</p>
<p>总结起来，宏定义是C++中的预处理指令，用于在编译之前将标识符替换为指定的文本。它们可以用于定义常量、简单的代码替换和宏函数等。但需要注意宏定义的潜在问题，如缺乏类型检查和作用域限制。在实际使用中，应该慎重考虑宏</p>
<h1>友元</h1>
<p>在C++中，友元（friend）是一种机制，允许某个类或函数访问其他类的私有成员。友元关系可以用于增强类之间的协作和封装性。当一个类将另一个类声明为友元时，被声明的类就可以访问该类的私有成员。</p>
<p>友元关系有两种形式：类友元和函数友元。</p>
<ol>
<li>类友元：<br>
类友元允许另一个类访问当前类的私有成员。在类定义中声明另一个类为友元时，友元类可以访问当前类的私有和保护成员。这种关系是双向的。</li>
</ol>
<p>下面是一个示例代码，演示了类友元的应用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 前置声明类B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">privateData</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 类B是类A的友元</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Private data in class A: &quot;</span> &lt;&lt; privateData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyPrivateData</span><span class="params">(A&amp; obj, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        obj.privateData = data;  <span class="comment">// 可以访问类A的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，类A将类B声明为友元。类B的成员函数<code>modifyPrivateData()</code>可以访问类A的私有成员<code>privateData</code>。这允许类B修改类A的私有数据。</p>
<ol start="2">
<li>
<p>函数友元：<br>
函数友元允许一个独立的函数访问某个类的私有成员。函数友元不属于任何类，但可以访问被声明为友元的类的私有和保护成员。</p>
<p><strong>这个函数的声明需要在类中，并在声明前加上friend关键字，定义可以在类中或类外，因为友元函数不属于类的成员函数，所以在调用友元函数时不需要声明作用域</strong></p>
</li>
</ol>
<p>下面是一个示例代码，演示了函数友元的应用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">privateData</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">(A&amp; obj)</span></span>;  <span class="comment">// displayPrivateData函数是类A的友元</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Private data in class A: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，函数<code>displayPrivateData()</code>被声明为类A的友元。该函数可以直接访问类A的私有成员<code>privateData</code>。</p>
<p>友元关系的应用方式可以有多种，例如：</p>
<ul>
<li>可以将其他类声明为友元，以便它们可以访问私有成员，从而实现类之间的数据共享或协作。</li>
<li>可以声明一些独立函数作为友元，以便它们可以直接访问类的私有成员，提供额外的功能或实现特定的操作。</li>
</ul>
<p>请注意，友元关系会破坏封装性，因此应谨慎使用。只有在确实需要访问私有成员并且信任友元类或函数时，才应使用友元关系。</p>
<h1>枚举</h1>
<p>在C++中，枚举（enumeration）是一种用于定义命名常量集合的数据类型。枚举提供了一种方便的方式来表示一组相关的离散值，并可以增加代码的可读性和可维护性。</p>
<p>以下是使用枚举的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumName</span> &#123;</span><br><span class="line">    Value1,</span><br><span class="line">    Value2,</span><br><span class="line">    Value3 = <span class="number">10</span>,</span><br><span class="line">    Value4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>EnumName</code> 是枚举类型的名称。<code>Value1</code>、<code>Value2</code>、<code>Value3</code> 和 <code>Value4</code> 是枚举常量，它们代表了枚举类型的不同取值。默认情况下，第一个枚举常量的值为 0，后续的枚举常量的值递增。但是，您也可以为枚举常量指定特定的值（如 <code>Value3 = 10</code>），后续的枚举常量将按照前一个常量的值递增。</p>
<p>枚举的常量可以在程序中直接使用，就像其他常量一样。以下是一个使用枚举的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Day today = Wednesday;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (today == Wednesday) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Today is Wednesday.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Today is not Wednesday.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了一个表示星期几的枚举类型 <code>Day</code>，然后使用枚举类型创建了一个变量 <code>today</code>，并将其赋值为 <code>Wednesday</code>。然后，我们可以使用条件语句来检查 <code>today</code> 是否等于 <code>Wednesday</code>，并输出相应的消息。</p>
<p>枚举可以与整数类型进行隐式转换，也可以通过强制类型转换将整数值转换为枚举类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Day day = <span class="built_in">static_cast</span>&lt;Day&gt;(<span class="number">2</span>);  <span class="comment">// 将整数值 2 转换为 Day 枚举类型</span></span><br></pre></td></tr></table></figure>
<p>枚举类型可以用作函数的参数类型或返回类型，以提供更具可读性的代码。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Day <span class="title">getNextDay</span><span class="params">(Day currentDay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Day&gt;((currentDay + <span class="number">1</span>) % <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数接受一个 <code>Day</code> 类型的参数 <code>currentDay</code>，并返回下一天的枚举值。</p>
<p>需要注意的是，枚举中的常量名称在同一作用域中是唯一的，不能重复定义相同名称的枚举常量。</p>
<p>通过使用枚举，您可以更清晰地表示一组相关的常量，并使代码更易于理解和维护。</p>
<h1>结构体</h1>
<p>在C++中，结构体（struct）是一种用户定义的数据类型，用于组合不同类型的数据成员。它类似于类（class），但有一些区别。下面是关于C++结构体的一些重要信息：</p>
<ol>
<li>定义结构体：结构体定义使用<code>struct</code>关键字，后面紧跟结构体的名称和一对花括号。在花括号中，您可以声明结构体的数据成员。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个名为<code>Person</code>的结构体，它有三个数据成员：<code>age</code>（整数类型），<code>name</code>（字符数组类型），和<code>height</code>（浮点数类型）。</p>
<ol start="2">
<li>创建结构体变量：要使用结构体，您需要创建结构体的一个或多个实例（变量）。创建结构体变量时，可以使用结构体名称后跟变量名称，并用结构体的数据成员初始化它们。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1;</span><br><span class="line">person1.age = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(person1.name, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">person1.height = <span class="number">175.5</span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个名为<code>person1</code>的<code>Person</code>结构体变量，并设置了其成员的值。</p>
<ol start="3">
<li>访问结构体成员：可以使用点（<code>.</code>）运算符来访问结构体变量的成员。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person1.name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; person1.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; person1.height &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>上述代码演示了如何访问<code>person1</code>结构体变量的成员并将其输出。</p>
<ol start="4">
<li>结构体作为函数参数：结构体可以作为函数的参数传递。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonInfo</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; p.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数并传递结构体变量</span></span><br><span class="line"><span class="built_in">printPersonInfo</span>(person1);</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个名为<code>printPersonInfo</code>的函数，它接受一个<code>Person</code>结构体参数，并打印该结构体的成员信息。</p>
<p>这些是关于C++结构体的基本概念和用法。结构体允许您在一个数据类型中组合多个相关数据成员，以便更方便地操作和管理数据。</p>
<h1>共同体</h1>
<p>在C++中，共同体（union）是一种特殊的数据类型，允许在同一内存空间中存储不同类型的数据。与结构体不同，共同体的所有成员共享同一块内存。共同体的大小等于其最大成员的大小。</p>
<p>下面是有关C++共同体的一些重要信息：</p>
<ol>
<li>定义共同体：使用<code>union</code>关键字定义共同体，后跟共同体的名称和一对花括号。在花括号中，您可以声明共同体的成员。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> intValue;</span><br><span class="line">    <span class="type">float</span> floatValue;</span><br><span class="line">    <span class="type">char</span> stringValue[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个名为<code>Data</code>的共同体，它有三个成员：<code>intValue</code>（整数类型），<code>floatValue</code>（浮点数类型），和<code>stringValue</code>（字符数组类型）。</p>
<ol start="2">
<li>使用共同体：可以创建共同体的实例，并对其成员进行赋值。共同体的所有成员将共享同一块内存。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data data;</span><br><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line">data.floatValue = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br><span class="line"><span class="built_in">strcpy</span>(data.stringValue, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String value: &quot;</span> &lt;&lt; data.stringValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个名为<code>data</code>的<code>Data</code>共同体实例，并对其不同的成员赋值。注意，对一个成员的赋值将会影响其他成员的值，因为它们共享同一块内存。</p>
<ol start="3">
<li>访问共同体成员：由于共同体的成员共享同一块内存，只能同时访问一个成员。可以使用点（<code>.</code>）运算符来访问共同体的成员。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">data.floatValue = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(data.stringValue, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String value: &quot;</span> &lt;&lt; data.stringValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，每次访问共同体的不同成员之前，先为该成员赋值，以确保正确访问和解释共同体的内容。</p>
<ol start="4">
<li>共同体的应用：共同体常用于在不同类型之间进行类型转换或节省内存。通过为共同体的不同成员赋值，可以将数据以不同类型进行解释和操作。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Data data;</span><br><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">data.floatValue = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(data.intValue);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，通过将整数值赋给共同体的<code>intValue</code>成员，然后将其强制转换为浮点数类型，可以在不改变内存中的值的情况下以不同类型解释该值。</p>
<p>这些是关于C++</p>
<p>共同体的基本概念和用法。共同体提供了一种在相同内存空间中存储不同类型数据的方法，但需要小心使用，确保正确解释和访问共同体的成员。</p>
<h1>[=]</h1>
<p>在C++中，<code>[=]</code>是一种lambda表达式的捕获列表（Capture List）形式，用于指定lambda表达式中的外部变量的访问方式。</p>
<p>Lambda表达式是C++11引入的一种匿名函数形式，它可以用于定义一个可调用的函数对象。Lambda表达式可以捕获局部变量，即在定义lambda表达式时，可以访问其所在作用域中的变量。</p>
<p>捕获列表<code>[=]</code>表示通过值捕获方式来访问外部变量。具体而言，使用<code>[=]</code>捕获列表会导致lambda表达式内部对外部变量进行值拷贝，以便在lambda表达式执行时使用。</p>
<p>以下是一个使用<code>[=]</code>捕获列表的lambda表达式示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [=]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x + y = &quot;</span> &lt;&lt; x + y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lambda</span>();  <span class="comment">// 输出结果：x + y = 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，lambda表达式使用了<code>[=]</code>捕获列表来捕获外部变量<code>x</code>和<code>y</code>。这意味着lambda表达式内部可以访问并使用这些变量的值。</p>
<p>当执行lambda表达式时，会输出变量<code>x</code>和<code>y</code>的和，即30。这是因为在lambda表达式定义时，通过值捕获方式将<code>x</code>和<code>y</code>的值拷贝到lambda对象中。</p>
<p>需要注意的是，通过值捕获方式捕获的外部变量是只读的，即无法在lambda表达式内部修改这些变量的值。如果希望能够修改外部变量，可以使用引用捕获方式（<code>[&amp;]</code>）来捕获外部变量。</p>
<h1>static_cast</h1>
<p><code>static_cast</code>是C++中的一种类型转换操作符，用于进行静态类型转换。它用于在编译时进行类型转换，编译器在进行类型转换时进行类型检查。<code>static_cast</code>可以用于以下几种转换：</p>
<ol>
<li>相关类型的转换：<code>static_cast</code>可用于相互关联的类型之间的转换，例如数字类型之间的转换（例如，整数到浮点数，浮点数到整数），以及指针和引用之间的转换。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intValue = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> doubleValue = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(intValue);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> intFromFloat = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(floatValue);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;number;</span><br><span class="line"><span class="type">void</span>* voidPtr = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>基类和派生类之间的转换：<code>static_cast</code>可用于基类指针或引用与派生类指针或引用之间的转换。但是，这种转换只有在确保指针或引用指向的对象实际上是派生类对象时才是安全的。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>隐式类型转换的显式化：<code>static_cast</code>可以将编译器隐式执行的类型转换显式化。这可以增加代码的可读性和明确性。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>static_cast</code>并不会执行运行时检查，因此在进行转换时要确保转换是安全的。如果存在不安全的转换，应该使用更严格的转换操作符（如<code>dynamic_cast</code>）来进行类型检查。</p>
<p>另外，<code>static_cast</code>也不能用于将底层const转换为非底层const，或者执行与底层const无关的其他转换。对于这些情况，可以使用<code>const_cast</code>和<code>reinterpret_cast</code>进行转换。</p>
<p>总结来说，<code>static_cast</code>是一种用于静态类型转换的操作符，适用于相关类型之间的转换、基类和派生类之间的转换，以及显式化隐式类型转换。在使用<code>static_cast</code>时，要确保转换是安全的并遵循C++的类型系统规则。</p>
<h1>goto</h1>
<p><code>goto</code>是C++中的一个关键字，用于实现无条件的跳转语句。它可以将程序的控制流直接跳转到指定的标签处。<code>goto</code>语句的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label_name:</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到指定的标签处</span></span><br><span class="line"><span class="keyword">goto</span> label_name;</span><br></pre></td></tr></table></figure>
<p>下面是一些关于<code>goto</code>使用方法和注意事项的说明：</p>
<ol>
<li><code>goto</code>的使用方法：首先，在代码中定义一个标签（label），并在标签后面跟着一个冒号（:）。然后，通过使用<code>goto</code>关键字，将程序的控制流无条件地跳转到标签所在的位置。这种跳转可以在同一个函数内部、跨越多个代码块或函数之间进行。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> jump;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部分代码将被跳过</span></span><br><span class="line"></span><br><span class="line">    jump:</span><br><span class="line">    <span class="comment">// 跳转到这里继续执行</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p><code>goto</code>的注意事项：</p>
<ul>
<li>
<p>避免滥用：<code>goto</code>语句的滥用会导致程序的逻辑变得混乱和难以理解。通常情况下，应该优先使用结构化的控制流语句（如<code>if</code>、<code>while</code>、<code>for</code>等）来实现代码逻辑。</p>
</li>
<li>
<p>防止跨过变量初始化：使用<code>goto</code>语句时要小心，以防止跳过局部变量的初始化过程。如果在跳转前需要对某个变量进行初始化，确保变量的初始化操作位于标签之前。</p>
</li>
<li>
<p>避免跨函数跳转：应避免在不同函数之间使用<code>goto</code>语句进行跳转，因为这会增加代码的复杂性和可读性，并可能导致代码难以维护。</p>
</li>
<li>
<p>保持代码清晰和可读性：使用<code>goto</code>语句时，应该注重代码的清晰性和可读性。给标签和跳转语句起具有描述性的名称，以便于他人理解代码的逻辑。</p>
</li>
<li>
<p>尽量避免使用：由于<code>goto</code>语句可能导致代码难以理解和维护，以及潜在的错误和混乱，建议尽量避免使用<code>goto</code>语句。大多数情况下，结构化的控制流语句可以更好地表达代码的逻辑。</p>
</li>
</ul>
</li>
</ol>
<p>需要注意的是，尽管<code>goto</code>语句在某些情况下可以提供方便，但它往往被认为是一种不良的编程实践，应该谨慎使用。在大多数情况下，更好的方法是使用结构化的控制流语句来组</p>
<p>织代码并保持代码的清晰性和可读性。</p>
<h1>auto</h1>
<p>在C++中，<code>auto</code>关键字用于自动推断变量的类型。通过使用<code>auto</code>关键字，编译器可以根据变量的初始化表达式来推断变量的类型，无需显式指定类型。</p>
<p><code>auto</code>关键字的使用方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variable = value;</span><br></pre></td></tr></table></figure>
<p>其中，<code>variable</code>是变量名，<code>value</code>是变量的初始化表达式。</p>
<p>以下是一些示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;  <span class="comment">// 推断x的类型为int，初始化为10</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>;  <span class="comment">// 推断y的类型为double，初始化为3.14</span></span><br><span class="line"><span class="keyword">auto</span> name = <span class="string">&quot;John&quot;</span>;  <span class="comment">// 推断name的类型为const char*，初始化为指向字符串常量的指针</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">7</span>);  <span class="comment">// 推断result的类型为函数add的返回类型，根据函数定义来推断</span></span><br></pre></td></tr></table></figure>
<p>通过使用<code>auto</code>关键字，可以简化变量声明的过程，特别是当变量的类型较为复杂或难以确定时。编译器会根据初始化表达式的类型推断出变量的类型，并自动进行类型检查。</p>
<p>需要注意的是，<code>auto</code>关键字在变量声明时使用，不能用于函数参数、函数返回类型、类的成员变量等场景。此外，由于类型是在编译时推断的，因此在某些情况下可能会导致代码可读性降低，特别是当初始化表达式较为复杂或类型不明显时。</p>
<p>在C++11之后，引入了更加强大的类型推断功能，例如<code>decltype</code>和<code>auto</code>结合使用，可以更灵活地推断出变量的类型。在C++14中，还引入了<code>decltype(auto)</code>来进行更精确的类型推断。这些功能在一些特定场景下可以提供更灵活和准确的类型推断。</p>
<h1>typeid</h1>
<p>在C++中，<code>typeid</code>是一个运算符，用于获取表达式的类型信息。它返回一个<code>type_info</code>对象，该对象包含有关表达式类型的信息。<code>typeid</code>可以用于以下几种情况：</p>
<ol>
<li>获取类型信息：使用<code>typeid</code>可以获取表达式的类型信息。它可以用于变量、对象、指针、引用以及类的实例等。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(num);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; objType = <span class="built_in">typeid</span>(obj);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; objType.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>类型比较：可以使用<code>typeid</code>来比较两个表达式的类型是否相同。如果类型相同，比较结果为<code>true</code>；否则为<code>false</code>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(a) == <span class="built_in">typeid</span>(b)) &#123;</span><br><span class="line">    <span class="comment">// 类型相同</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>需要包含 <code>&lt;typeinfo&gt;</code> 头文件以使用 <code>typeid</code>。</li>
<li><code>type_info</code> 类型的对象在不同的编译单元中可能具有不同的地址，因此不能将其地址进行比较。</li>
<li><code>type_info</code> 对象的 <code>name()</code> 方法返回一个 <code>const char*</code> 指针，表示类型的名称。该名称的具体格式可能因编译器而异。</li>
<li>由于类型名称的具体格式是由编译器决定的，因此不应依赖于 <code>name()</code> 返回的字符串进行逻辑判断。</li>
</ul>
<p>需要注意的是，<code>typeid</code>主要用于运行时的类型信息，因此它在某些情况下可能会有一些限制。例如，对于多态类的基类指针或引用，<code>typeid</code>将返回指向实际对象的类型信息，而不是指向基类的类型信息。为了正确使用<code>typeid</code>，请确保在使用前已经了解了相关类型的特性和使用约束。</p>
<p>总的来说，<code>typeid</code>运算符可用于获取和比较表达式的类型信息，对于调试、类型检查和运行时多态等方面是非常有用的。</p>
<h1>type_info</h1>
<p><code>type_info</code> 是 C++ 标准库 <code>&lt;typeinfo&gt;</code> 中定义的类，它用于提供有关类型的运行时信息。<code>type_info</code> 类主要用于以下几个方面：</p>
<ol>
<li>获取类型信息：通过使用 <code>typeid</code> 运算符，可以获得表达式的 <code>type_info</code> 对象，从而获取有关类型的信息。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(num);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>类型比较：<code>type_info</code> 对象可以进行类型比较，以检查两个类型是否相同。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(a) == <span class="built_in">typeid</span>(b)) &#123;</span><br><span class="line">    <span class="comment">// 类型相同</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取类型名称：<code>type_info</code> 对象的 <code>name()</code> 方法返回一个 <code>const char*</code> 指针，表示类型的名称。请注意，返回的名称可能具有平台和编译器特定的格式。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(<span class="type">int</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type name: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>需要注意以下几点：</p>
<ul>
<li><code>type_info</code> 类在头文件 <code>&lt;typeinfo&gt;</code> 中定义，因此需要包含该头文件才能使用它。</li>
<li><code>type_info</code> 对象的 <code>name()</code> 方法返回的类型名称不一定是人类可读的，因为它可能是编译器特定的标识符。</li>
<li><code>type_info</code> 的 <code>==</code> 操作符用于比较两个 <code>type_info</code> 对象是否代表相同的类型，而不是比较类型名称。</li>
</ul>
<p>由于 <code>type_info</code> 类提供的信息是在运行时获得的，因此它在某些情况下可能具有一些限制。例如，对于多态类的基类指针或引用，<code>type_info</code> 返回的类型信息将是指向实际对象的类型信息，而不是指向基类的类型信息。</p>
<p>总结来说，<code>type_info</code> 类提供了获取运行时类型信息的功能，并支持类型比较。它对于实现运行时类型检查、多态和其他需要类型信息的场景非常有用。然而，由于类型名称的具体格式是由编译器决定的，因此在使用 <code>type_info</code> 返回的名称时应谨慎对待。</p>
<h1>nullptr</h1>
<p><code>nullptr</code> 是 C++11 引入的关键字，用于表示空指针常量。它是用来明确表示一个指针不指向任何有效对象或函数的特殊值。在之前的 C++ 标准中，通常使用宏定义 <code>NULL</code> 或整数常量 <code>0</code> 来表示空指针。</p>
<p>使用 <code>nullptr</code> 的好处包括：</p>
<ol>
<li>清晰明确：<code>nullptr</code> 显式地表达了指针为空的含义，避免了与整数零的混淆。</li>
<li>类型安全：<code>nullptr</code> 是一个特殊的空指针类型，它不能隐式转换为其他类型，从而避免了类型错误。</li>
<li>减少重载歧义：当存在多个函数重载时，传递 <code>nullptr</code> 可以帮助编译器正确地选择函数重载版本。</li>
</ol>
<p>以下是一些使用 <code>nullptr</code> 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);  <span class="comment">// 调用 foo(char*) 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 指针为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了两个重载的 <code>foo</code> 函数，一个接受 <code>char*</code> 类型的指针，另一个接受 <code>int*</code> 类型的指针。当我们传递 <code>nullptr</code> 给 <code>foo</code> 函数时，编译器会选择接受 <code>char*</code> 类型的版本。此外，我们还使用 <code>==</code> 运算符将指针 <code>ptr</code> 与 <code>nullptr</code> 进行比较，以检查指针是否为空。</p>
<p>总结而言，<code>nullptr</code> 是 C++11 引入的关键字，用于表示空指针常量。它提供了更明确的语义、类型安全和减少重载歧义的优点，使得代码更加清晰和健壮。在编写新的 C++ 代码时，推荐使用 <code>nullptr</code> 来表示空指针。</p>
<h1>简易学生管理系统模板</h1>
<p>下面是一个简易的学生管理系统的示例代码，它包括了学生类和一个管理系统类，可以添加学生、显示所有学生和查找学生等功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age, <span class="type">const</span> std::string&amp; id)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age), <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getID</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    std::string id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentManagementSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addStudent</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age, <span class="type">const</span> std::string&amp; id)</span> </span>&#123;</span><br><span class="line">        <span class="function">Student <span class="title">student</span><span class="params">(name, age, id)</span></span>;</span><br><span class="line">        students.<span class="built_in">push_back</span>(student);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Student added successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayAllStudents</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (students.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No students found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;All students:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; student : students) &#123;</span><br><span class="line">                student.<span class="built_in">displayInfo</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchStudent</span><span class="params">(<span class="type">const</span> std::string&amp; id)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; student : students) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.<span class="built_in">getID</span>() == id) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Student found:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                student.<span class="built_in">displayInfo</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Student not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Student&gt; students;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StudentManagementSystem system;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加学生</span></span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>, <span class="string">&quot;1001&quot;</span>);</span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">19</span>, <span class="string">&quot;1002&quot;</span>);</span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">21</span>, <span class="string">&quot;1003&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有学生</span></span><br><span class="line">    system.<span class="built_in">displayAllStudents</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找学生</span></span><br><span class="line">    system.<span class="built_in">searchStudent</span>(<span class="string">&quot;1002&quot;</span>);</span><br><span class="line">    system.<span class="built_in">searchStudent</span>(<span class="string">&quot;1004&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>Student</code> 类表示学生，具有姓名、年龄和学号等属性，并提供了获取和显示学生信息的成员函数。</p>
<p><code>StudentManagementSystem</code> 类表示学生管理系统，它包含一个学生列表（使用 <code>std::vector&lt;Student&gt;</code> 存储学生），提供了添加学生、显示所有学生和查找学生的成员函数。</p>
<p>在 <code>main()</code> 函数中，我们创建了一个 <code>StudentManagementSystem</code> 对象 <code>system</code>，并使用其成员函数来添加学生、显示所有学生和查找学生。输出结果为添加的学生信息、所有学生信息以及查找到的学生信息（如果存在）。</p>
<p>请注意，上述代码是一个简易的示例，没有包括错误处理和持久化存储等完整的功能。在实际开发中，可能需要更多的功能和更复杂的设计来满</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++基础</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://momoao.github.io/posts/202308241930.html">https://momoao.github.io/posts/202308241930.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>MoMoAo🍓</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-07-10</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-08-25</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>C++</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://momoao.github.io/assets/wxcollection.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wxcollection.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://momoao.github.io/assets/zfbcollection.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/zfbcollection.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/202308241636.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w16.jpg" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++QT</div></div></a></div><div class="next-post pull-right"><a href="/posts/202308241933.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w19.jpg" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CentOS</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/202308241636.html" title="C++QT"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-27</div><div class="title">C++QT</div></div></a></div><div><a href="/posts/202308241921.html" title="C++核心编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-25</div><div class="title">C++核心编程</div></div></a></div><div><a href="/posts/202308241942.html" title="QT飞机大战源码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-25</div><div class="title">QT飞机大战源码</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">C++基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">零碎问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%92%8Cconst%E5%8C%BA%E5%88%AB"><span class="toc-text">final和const区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">使用 .和-&gt;的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-bits-stdc-h-%E6%98%AF%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">为什么说&lt;bits&#x2F;stdc++.h&gt;是万能头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%B8%B8%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">中常量和静态变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%B5%8B%E6%99%AE%E9%80%9A%E6%95%B0%E5%80%BC"><span class="toc-text">为什么常量引用就可以赋普通数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E7%89%88%E6%9C%AC"><span class="toc-text">c++版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMake%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">CMake是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-text">头文件条件编译指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clang-Tidy-Function-%E2%80%98getId%E2%80%99-should-be-marked-nodiscard"><span class="toc-text">Clang-Tidy: Function ‘getId’ should be marked [[nodiscard]]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clang-Tidy%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Clang-Tidy是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">C++中域是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">常见编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MinGW"><span class="toc-text">MinGW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GNU"><span class="toc-text">GNU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenGL"><span class="toc-text">OpenGL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iceberg"><span class="toc-text">Iceberg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDFS"><span class="toc-text">HDFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Opencv"><span class="toc-text">Opencv</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">命名空间在项目开发中的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit"><span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84-%E5%90%8E%E9%9D%A2%E5%8A%A0%E4%B8%8A-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-text">构造函数的()后面加上;是什么意思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NDK"><span class="toc-text">NDK</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">复合数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">指针类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">其他数据类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%B3%E7%B3%BB"><span class="toc-text">继承和访问关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-text">派生类访问基类私有成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#override"><span class="toc-text">override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">虚函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">final</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">指针和引用的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">宏定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">友元</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">共同体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">[&#x3D;]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">goto</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">auto</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">typeid</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">type_info</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">nullptr</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">简易学生管理系统模板</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>带上信仰，去寻找属于你自己的国度吧！哪怕倾尽一生。✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="https://MoMoAo.github.io" title="MoMoAo🍓"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://MoMoAo.github.io/assets/tx.jpg" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租🥂"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://MoMoAo.github.io/assets/ggw.png" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租🥂"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://MoMoAo.github.io/assets/ggw.png" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租🥂"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://MoMoAo.github.io/assets/ggw.png" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租🥂"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://MoMoAo.github.io/assets/ggw.png" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租🥂"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://MoMoAo.github.io/assets/ggw.png" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2023</b></span><span><b>&nbsp;&nbsp;By MoMoAo🍓</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://MoMoAo.github.io/categories/操作系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 MoMoAoの操作系统基础笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://MoMoAo.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 MoMoAoの数据库笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://MoMoAo.github.io/categories/工具/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 MoMoAoの工具演示笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://MoMoAo.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241950.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w10.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241950.html&quot;);" href="javascript:void(0);" alt="">网络协议概述</a><div class="blog-slider__text">🥧本文汇总常见网络协议的概述和基础知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241950.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308242004.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308242004.html&quot;);" href="javascript:void(0);" alt="">正则表达式</a><div class="blog-slider__text">🥧本文汇总正则表达式的写法和常用的正则表达式</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308242004.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241554.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241554.html&quot;);" href="javascript:void(0);" alt="">VSCode中C++环境配置</a><div class="blog-slider__text">🥧本文汇总VSCode中C++环境的配置和使用</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241554.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308301711.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w14.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308301711.html&quot;);" href="javascript:void(0);" alt="">SpringBoot初识</a><div class="blog-slider__text">🍔本文汇总SpringBoot的基础知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308301711.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308281529.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w20.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308281529.html&quot;);" href="javascript:void(0);" alt="">Spring</a><div class="blog-slider__text">🍔本文汇总Spring和SpringMVC的开发步骤</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308281529.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241921.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241921.html&quot;);" href="javascript:void(0);" alt="">Shell编程</a><div class="blog-slider__text">🥧本文汇总Shell编程的基础</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241921.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241944.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w16.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241944.html&quot;);" href="javascript:void(0);" alt="">Redis</a><div class="blog-slider__text">🥧本文汇总Redis的安装和使用</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241944.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241942.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241942.html&quot;);" href="javascript:void(0);" alt="">QT飞机大战源码</a><div class="blog-slider__text">🥧使用QT写的飞机大战的纯源码</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241942.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308281527.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308281527.html&quot;);" href="javascript:void(0);" alt="">Mybatis</a><div class="blog-slider__text">🍔本文汇总使用Mybatis开发的基本步骤，简易提交看Spring的相关笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308281527.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308281533.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308281533.html&quot;);" href="javascript:void(0);" alt="">Java反射</a><div class="blog-slider__text">🍔本文汇总Java反射的知识点</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308281533.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241921.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241921.html&quot;);" href="javascript:void(0);" alt="">C++核心编程</a><div class="blog-slider__text">🥧本文汇总C++的内存、引用、文件操作、模板、STL、多线程等核心编程部分</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241921.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241940.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241940.html&quot;);" href="javascript:void(0);" alt="">Hexo</a><div class="blog-slider__text">🥧本文汇总Hexo博客框架的安装和使用方法</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241940.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308290811.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w19.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308290811.html&quot;);" href="javascript:void(0);" alt="">JavaScript</a><div class="blog-slider__text">🍔本文汇总JavaScript的基础知识点</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308290811.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241935.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w11.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241935.html&quot;);" href="javascript:void(0);" alt="">Git</a><div class="blog-slider__text">🥧本文汇总Git的使用方法</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241935.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241933.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w19.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241933.html&quot;);" href="javascript:void(0);" alt="">CentOS</a><div class="blog-slider__text">🥧本文汇总CentOS的安装、常用指令、常用第三方软件</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241933.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241930.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w11.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241930.html&quot;);" href="javascript:void(0);" alt="">C++基础</a><div class="blog-slider__text">🥧本文汇总C++的数据类型、类、结构体等基础知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241930.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/202308241636.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w16.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/202308241636.html&quot;);" href="javascript:void(0);" alt="">C++QT</a><div class="blog-slider__text">🍔本文汇总QT编程的基础内容，和QTCreator的基本使用</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/202308241636.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://momoao.github.io/assets/wallpaper/w5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>