<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MoMoAo🍓</title>
  
  <subtitle>MoMoAo&#39;s Blog</subtitle>
  <link href="https://momoao.github.io/atom.xml" rel="self"/>
  
  <link href="https://momoao.github.io/"/>
  <updated>2023-10-22T08:39:08.339Z</updated>
  <id>https://momoao.github.io/</id>
  
  <author>
    <name>MoMoAo🍓</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL查询</title>
    <link href="https://momoao.github.io/posts/202310221559.html"/>
    <id>https://momoao.github.io/posts/202310221559.html</id>
    <published>2023-10-22T08:19:03.000Z</published>
    <updated>2023-10-22T08:39:08.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL查询"><a href="#MySQL查询" class="headerlink" title="MySQL查询"></a>MySQL查询</h1><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="../assets/image/MySQL%E6%9F%A5%E8%AF%A2_Image/image-20231022160421110.png" alt="image-20231022160421110"></p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p><img src="../assets/image/MySQL%E6%9F%A5%E8%AF%A2_Image/image-20231022160605948.png" alt="image-20231022160605948"></p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>一个学生可以选多门课</p><p>一门课可以被多个学生选行·</p><p><img src="../assets/image/MySQL%E6%9F%A5%E8%AF%A2_Image/image-20231022160748200.png" alt="image-20231022160748200"></p><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>因为数据过多，将一个表拆分成两个表</p><p><img src="../assets/image/MySQL%E6%9F%A5%E8%AF%A2_Image/image-20231022161533960.png" alt="image-20231022161533960"></p><h2 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h2><p><img src="../assets/image/MySQL%E6%9F%A5%E8%AF%A2_Image/image-20231022163004033.png" alt="image-20231022163004033"></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p><img src="../assets/image/MySQL%E6%9F%A5%E8%AF%A2_Image/image-20231022163013211.png" alt="image-20231022163013211"></p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>相当于A、B交集部分数据</p><p><img src="../assets/image/MySQL%E6%9F%A5%E8%AF%A2_Image/image-20231022163246721.png" alt="image-20231022163246721"></p><h3 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h3><p><img src="../assets/image/MySQL%E6%9F%A5%E8%AF%A2_Image/image-20231022163432872.png" alt="image-20231022163432872"></p><h3 id="显示内连接"><a href="#显示内连接" class="headerlink" title="显示内连接"></a>显示内连接</h3><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>当前表与自身的连接查询，自连接必须使用表别名</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h2 id="多表查询案例"><a href="#多表查询案例" class="headerlink" title="多表查询案例"></a>多表查询案例</h2>]]></content>
    
    
    <summary type="html">🥧本文汇总MySQL查询方面的精讲，多表查询等</summary>
    
    
    
    <category term="数据库" scheme="https://momoao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://momoao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JUC</title>
    <link href="https://momoao.github.io/posts/202310201322.html"/>
    <id>https://momoao.github.io/posts/202310201322.html</id>
    <published>2023-10-20T05:19:03.000Z</published>
    <updated>2023-10-20T06:17:20.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="Ai总结"><a href="#Ai总结" class="headerlink" title="Ai总结"></a>Ai总结</h2><h3 id="Java有哪些实现多线程的方式"><a href="#Java有哪些实现多线程的方式" class="headerlink" title="Java有哪些实现多线程的方式"></a>Java有哪些实现多线程的方式</h3><p>Java中有多种方式来实现多线程，主要包括以下几种：</p><ol><li><p>继承Thread类：<br>您可以创建一个类，继承自<code>java.lang.Thread</code>类，然后重写<code>run()</code>方法，在<code>run()</code>方法中定义线程的任务。之后，您可以创建该类的实例并调用<code>start()</code>方法来启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口：<br>可以创建一个类，实现<code>java.lang.Runnable</code>接口，然后实现<code>run()</code>方法。再创建该类的实例，并将其作为参数传递给<code>Thread</code>类的构造函数，然后启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并启动线程</span></span><br><span class="line"><span class="type">MyRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p>使用匿名内部类：<br>可以使用匿名内部类的方式来实现线程，将<code>Runnable</code>接口的<code>run()</code>方法在<code>Thread</code>类的构造函数中使用匿名内部类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p>使用线程池：<br>Java提供了<code>java.util.concurrent</code>包，其中包括<code>Executor</code>框架和线程池，用于更高级的线程管理。通过线程池，可以有效地管理和重用线程，减少线程创建和销毁的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure></li><li><p>使用Callable和Future：<br><code>java.util.concurrent</code>包还提供了<code>Callable</code>和<code>Future</code>接口，允许线程执行有返回值的任务，并能够获取任务的执行结果。</p></li></ol><p>这些是Java中实现多线程的一些常见方式。您可以根据需要选择适合您的特定情况的方式。无论使用哪种方式，都需要注意线程同步、线程间通信和异常处理等多线程编程的相关问题。</p>]]></content>
    
    
    <summary type="html">🥧本文汇总JAVA的并发编程知识</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://momoao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>黑马头条课堂笔记</title>
    <link href="https://momoao.github.io/posts/202310151032.html"/>
    <id>https://momoao.github.io/posts/202310151032.html</id>
    <published>2023-10-15T00:19:03.000Z</published>
    <updated>2023-10-20T08:55:30.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑马头条课堂笔记"><a href="#黑马头条课堂笔记" class="headerlink" title="黑马头条课堂笔记"></a>黑马头条课堂笔记</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>功能架构图</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015103451690.png" alt="image-20231015103451690"></p><h4 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h4><h5 id="基础层"><a href="#基础层" class="headerlink" title="基础层"></a>基础层</h5><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015103520443.png" alt="image-20231015103520443"></p><h4 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h4><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015103533029.png" alt="image-20231015103533029"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015103548300.png" alt="image-20231015103548300"></p><h3 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h3><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015104152072-16973377123771.png" alt="image-20231015104152072"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull nacos/nacos-server:<span class="number">1</span>.<span class="number">2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> --env <span class="attribute">MODE</span>=standalone --name nacos <span class="attribute">--restart</span>=always  -d -p 8848:8848 nacos/nacos-server:1.2.0</span><br></pre></td></tr></table></figure><h3 id="初识工程搭建"><a href="#初识工程搭建" class="headerlink" title="初识工程搭建"></a>初识工程搭建</h3><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015104905957.png" alt="image-20231015104905957"></p><p>异常处理</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015105351328.png" alt="image-20231015105351328"></p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>需求分析</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015105413371.png" alt="image-20231015105413371"></p><p>表结构分析</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015105550366.png" alt="image-20231015105550366"></p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015110938216.png" alt="image-20231015110938216"></p><p>手动加密</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111006632.png" alt="image-20231015111006632"></p><p>登录过程</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111037075.png" alt="image-20231015111037075"></p><p>用户端</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111129672.png" alt="image-20231015111129672"></p><p>运营端</p><p>所有微服务都是这个结构</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111138620.png" alt="image-20231015111138620"></p><p>接口定义</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111335892.png" alt="image-20231015111335892"></p><p>思路分析</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111410160.png" alt="image-20231015111410160"></p><h3 id="接口工具"><a href="#接口工具" class="headerlink" title="接口工具"></a>接口工具</h3><h4 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h4><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。postman被500万开发者和超100,000家公司用于每月访问1.3亿个API。</p><p>官方网址：<a href="https://www.postman.com/">https://www.postman.com/</a></p><h4 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h4><p>项目基于前后端分离的架构进行开发，前后端分离架构总体上包括前端和服务端，通常是多人协作开发</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111531874.png" alt="image-20231015111531874"></p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<a href="https://swagger.io/)。">https://swagger.io/)。</a> 它的主要作用是：</p><ol><li>使得前后端分离开发更加方便，有利于团队协作</li><li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p></li><li><p>功能测试 </p></li></ol><h4 id="knife4j"><a href="#knife4j" class="headerlink" title="knife4j"></a>knife4j</h4><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p><p>gitee地址：<a href="https://gitee.com/xiaoym/knife4j">https://gitee.com/xiaoym/knife4j</a><br>官方文档：<a href="https://doc.xiaominfo.com/">https://doc.xiaominfo.com/</a><br>效果演示：<a href="http://knife4j.xiaominfo.com/doc.html">http://knife4j.xiaominfo.com/doc.html</a> </p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><h4 id="app端网关"><a href="#app端网关" class="headerlink" title="app端网关"></a>app端网关</h4><p>概述</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111659242.png" alt="image-20231015111659242"></p><p>项目中网关的服务工程结构</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111718366.png" alt="image-20231015111718366"></p><h4 id="认证过滤器"><a href="#认证过滤器" class="headerlink" title="认证过滤器"></a>认证过滤器</h4><p>全局过滤器实现jwt校验</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111901046.png" alt="image-20231015111901046"></p><h3 id="前端集成"><a href="#前端集成" class="headerlink" title="前端集成"></a>前端集成</h3><h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h4><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231015111928487.png" alt="image-20231015111928487"></p><h4 id="启动app前端工程"><a href="#启动app前端工程" class="headerlink" title="启动app前端工程"></a>启动app前端工程</h4><h3 id="用户微服务搭建"><a href="#用户微服务搭建" class="headerlink" title="用户微服务搭建"></a>用户微服务搭建</h3><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231018095829026.png" alt="image-20231018095829026"></p><h2 id="Freemarker"><a href="#Freemarker" class="headerlink" title="Freemarker"></a>Freemarker</h2><p>FreeMarker（又称作FreeMarker Template Engine）是一个流行的模板引擎，用于生成文本输出，通常用于Web应用程序中生成HTML、XML、JSON等动态内容。它是一个开源项目，Java编写，可以集成到Java应用程序中，也有各种其他语言的端口。</p><p>freemarker作为SpringMVC视图输出</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="基础语法种类"><a href="#基础语法种类" class="headerlink" title="基础语法种类"></a>基础语法种类</h4><p>注释、插值、FTL指令、文本</p><p><img src="../assets/image/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231020154940360.png" alt="image-20231020154940360"></p><h4 id="集合指令"><a href="#集合指令" class="headerlink" title="集合指令"></a>集合指令</h4><p>集合指令-List</p><h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h4 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h4><h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><h2 id="Ai总结"><a href="#Ai总结" class="headerlink" title="Ai总结"></a>Ai总结</h2><h3 id="Fegin"><a href="#Fegin" class="headerlink" title="Fegin"></a>Fegin</h3><p>Feign是一个基于HTTP的客户端库，它是Netflix开发的，用于简化HTTP客户端的开发。Feign的主要目标是使编写HTTP客户端变得更加简单、优雅和声明式，尤其适用于微服务架构中的服务之间通信。以下是关于Feign的重要信息：</p><p><strong>特点和优势：</strong></p><ol><li><p><strong>声明式API</strong>：Feign允许你定义HTTP客户端的请求接口，就像定义服务接口一样。这使得客户端代码更加直观和易于理解，无需编写大量的HTTP请求和响应的处理代码。</p></li><li><p><strong>集成性</strong>：Feign集成了多种HTTP客户端实现（如Apache HttpClient、OkHttp），因此你可以选择最适合你的项目的实现。</p></li><li><p><strong>服务发现</strong>：在微服务架构中，Feign通常与服务注册和发现工具（如Eureka、Consul）集成，可以通过服务名来发现和调用其他微服务，而无需硬编码URL。</p></li><li><p><strong>负载均衡</strong>：Feign可以与负载均衡器（如Ribbon）集成，自动分发请求到可用的服务实例，提高了应用的可用性和性能。</p></li><li><p><strong>请求和响应编码</strong>：Feign支持请求和响应的编码和解码，包括JSON、XML等。它可以与各种序列化和反序列化库集成，如Jackson、Gson等。</p></li></ol><p><strong>如何使用Feign：</strong></p><ol><li><p><strong>添加依赖</strong>：首先，你需要在项目中添加Feign的依赖。在Maven中，可以通过以下方式添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建Feign客户端接口</strong>：定义一个接口，用于声明需要调用的远程服务的方法。这个接口上使用<code>@FeignClient</code>注解来指定要访问的服务名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;my-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/resource&quot;)</span></span><br><span class="line">    Resource <span class="title function_">getResource</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Feign客户端</strong>：在应用程序中注入Feign客户端接口，并直接调用它的方法。Feign将负责发出HTTP请求，将响应反序列化为Java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyServiceClient myServiceClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> myServiceClient.getResource();</span><br><span class="line">    <span class="comment">// 处理资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Feign使HTTP客户端的开发过程变得更加简单和易于维护，特别适用于微服务架构中的服务之间通信，帮助开发者避免了大量的手动HTTP请求和响应处理代码。它的集成性和声明式API使得构建分布式系统更加便捷。</p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>Nacos（前身为阿里巴巴的Dubbo Nacos）是一个开源的动态服务发现、配置管理和服务管理平台，它提供了一种简单而强大的方式来实现微服务架构中的服务注册、发现、配置和管理。Nacos支持多种编程语言和多种云环境，并且适用于各种类型的应用，包括云原生应用、微服务架构、容器化应用等。</p><p>以下是Nacos的关键特点和功能：</p><ol><li><p><strong>服务注册和发现</strong>：Nacos允许服务提供者在启动时注册其服务，并允许服务消费者动态地发现可用的服务。这有助于构建弹性的、可扩展的微服务架构。</p></li><li><p><strong>动态配置管理</strong>：Nacos提供了配置管理功能，允许将应用程序的配置信息存储在Nacos服务器上，并在运行时动态获取和更新配置。这可以帮助应用程序实现配置热更新。</p></li><li><p><strong>服务和实例管理</strong>：Nacos允许管理各个服务的状态、元数据和实例的健康状态，以确保高可用性和可靠性。</p></li><li><p><strong>命名空间和多环境支持</strong>：Nacos支持多个命名空间，允许在不同环境（如开发、测试、生产）中管理不同的配置和服务注册信息。</p></li><li><p><strong>健康检查和故障转移</strong>：Nacos可以定期检查服务的健康状态，并在服务不可用时触发故障转移。这有助于维护可靠的服务治理。</p></li><li><p><strong>多语言和多框架支持</strong>：Nacos提供了多种客户端SDK和适配器，适用于不同编程语言和框架，包括Java、Go、Python、Node.js等。</p></li><li><p><strong>可视化管理界面</strong>：Nacos提供了一个用户友好的Web界面，用于管理服务、配置和实例，以及查看服务的拓扑图。</p></li><li><p><strong>云原生和容器化支持</strong>：Nacos被设计为云原生应用和容器化环境的一部分，它可以轻松与Kubernetes、Docker等集成。</p></li><li><p><strong>集群和高可用性</strong>：Nacos支持构建多节点的Nacos集群，以确保高可用性和可扩展性。</p></li></ol><p>Nacos的架构基于三大组件：命名服务、动态配置和元数据管理。它适用于各种应用场景，包括微服务架构、云原生应用、容器编排和DevOps。</p><p>总的来说，Nacos是一个功能丰富的服务发现和配置管理平台，使微服务架构更加容易实现和管理。它是云原生应用开发的有力工具，有助于构建高度可扩展和可维护的分布式系统。</p>]]></content>
    
    
    <summary type="html">🥧黑马头条课堂笔记</summary>
    
    
    
    <category term="项目" scheme="https://momoao.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="Springcloud" scheme="https://momoao.github.io/tags/Springcloud/"/>
    
    <category term="Springboot" scheme="https://momoao.github.io/tags/Springboot/"/>
    
    <category term="Nacos" scheme="https://momoao.github.io/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://momoao.github.io/posts/202310120920.html"/>
    <id>https://momoao.github.io/posts/202310120920.html</id>
    <published>2023-10-10T10:19:03.000Z</published>
    <updated>2023-10-12T02:42:59.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><div class="note info flat"><p>参考：笔记参考黑马程序员微服务框架笔记</p></div><p><a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">黑马程序员-微服务框架</a></p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h3 id="卸载旧版"><a href="#卸载旧版" class="headerlink" title="卸载旧版"></a>卸载旧版</h3><p>首先如果系统中已经存在旧的Docker，则先卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine</span><br></pre></td></tr></table></figure><h3 id="配置docket的yum库"><a href="#配置docket的yum库" class="headerlink" title="配置docket的yum库"></a>配置docket的yum库</h3><p>首先要安装一个yum工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>安装成功后，执行命令，配置Docker的yum源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="安装docker-1"><a href="#安装docker-1" class="headerlink" title="安装docker"></a>安装docker</h3><p>执行命令，安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h3 id="启动和校验"><a href="#启动和校验" class="headerlink" title="启动和校验"></a>启动和校验</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h3><p>这里以阿里云镜像加速为例。</p><h4 id="注册阿里云账号"><a href="#注册阿里云账号" class="headerlink" title="注册阿里云账号"></a>注册阿里云账号</h4><p>首先访问阿里云网站:</p><p><a href="https://www.aliyun.com/">https://www.aliyun.com/</a></p><p>注册一个账号。</p><h4 id="开通镜像服务"><a href="#开通镜像服务" class="headerlink" title="开通镜像服务"></a>开通镜像服务</h4><p>在首页的产品中，找到阿里云的<strong>容器镜像服务</strong>：</p><p><img src="../assets/image/Docker_Image/image-20231012094400418.png" alt="image-20231012094400418"></p><p>点击后进入控制台</p><p><img src="../assets/image/Docker_Image/image-20231012094415099.png" alt="image-20231012094415099"></p><p>首次可能需要选择立刻开通，然后进入控制台。</p><h4 id="配置镜像加速-1"><a href="#配置镜像加速-1" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h4><p>找到<strong>镜像工具</strong>下的<strong>镜像**</strong>加速器**：</p><p><img src="../assets/image/Docker_Image/image-20231012094429046.png" alt="image-20231012094429046"></p><p>页面向下滚动，即可找到配置的文档说明：</p><p><img src="../assets/image/Docker_Image/16970750731111.png" alt="img"></p><p>具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制内容，注意把其中的镜像加速地址改成你自己的</span></span><br><span class="line"><span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://xxxx.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启Docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Ai总结"><a href="#Ai总结" class="headerlink" title="Ai总结"></a>Ai总结</h2><h3 id="Docker中常见的概念"><a href="#Docker中常见的概念" class="headerlink" title="Docker中常见的概念"></a>Docker中常见的概念</h3><p>Docker 是一种容器化平台，涉及许多常见的概念和组件。以下是一些在 Docker 中常见的关键概念：</p><ol><li><p><strong>容器（Container）</strong>：容器是 Docker 中的基本单元，用于封装应用程序和其依赖项，以便在不同环境中进行部署和运行。容器提供了隔离、轻量级和可移植的环境。</p></li><li><p><strong>镜像（Image）</strong>：镜像是容器的模板，包含了运行容器所需的文件系统、库和配置。容器是从镜像创建的实例。镜像通常存储在仓库中，如 Docker Hub，可以共享和下载。</p></li><li><p><strong>Dockerfile</strong>：Dockerfile 是一个文本文件，包含了构建 Docker 镜像所需的指令。你可以使用 Dockerfile 定义镜像的构建过程，包括基础镜像、文件复制、命令执行等。</p></li><li><p><strong>仓库（Repository）</strong>：仓库是存储 Docker 镜像的地方，可以包含多个镜像标签。Docker Hub 是一个公共 Docker 仓库，还可以配置私有仓库以存储自定义镜像。</p></li><li><p><strong>容器注册表（Registry）</strong>：容器注册表是存储 Docker 镜像的服务器。Docker Hub 是一个常见的公共容器注册表，但你也可以自己搭建私有注册表。</p></li><li><p><strong>Docker Compose</strong>：Docker Compose 是一个用于定义和运行多容器应用程序的工具。它允许你在一个文件中定义多个容器的配置和关系，然后使用一个命令来启动整个应用程序。</p></li><li><p><strong>Docker Swarm</strong>：Docker Swarm 是 Docker 的集群和编排工具，用于将多个 Docker 主机组织为一个单一的集群，以实现容器的负载均衡和高可用性。</p></li><li><p><strong>Docker 客户端和守护程序</strong>：Docker 客户端是用户与 Docker 交互的命令行工具，而 Docker 守护程序是后台服务，负责管理容器的创建、运行和销毁。</p></li><li><p><strong>网络（Network）</strong>：Docker 允许你创建自定义网络以隔离容器，还支持将容器连接到主机网络或其他网络。这有助于容器之间通信和访问外部网络。</p></li><li><p><strong>卷（Volume）</strong>：Docker 卷用于在容器之间共享数据，或将数据持久化。它们是容器中的目录或文件，可以在容器之间或与主机之间共享。</p></li><li><p><strong>Compose 文件</strong>：Compose 文件是 Docker Compose 的配置文件，其中包含了应用程序的定义、服务配置和关系。这些文件通常以 <code>docker-compose.yml</code> 命名。</p></li><li><p><strong>Swarm 服务（Service）</strong>：在 Docker Swarm 中，服务是定义应用程序的单元。它包括容器的镜像、副本数、网络配置和其他参数。</p></li></ol><p>这些概念是 Docker 中的基础，了解它们将有助于你更好地理解和管理 Docker 容器化环境。 Docker 提供了广泛的文档和社区资源，以帮助你更深入地学习这些概念和如何使用 Docker。</p>]]></content>
    
    
    <summary type="html">🥧本文汇总Docker的安装、使用和基础知识点</summary>
    
    
    
    <category term="工具" scheme="https://momoao.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Docker" scheme="https://momoao.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://momoao.github.io/posts/202310161341.html"/>
    <id>https://momoao.github.io/posts/202310161341.html</id>
    <published>2023-10-10T10:19:03.000Z</published>
    <updated>2023-10-16T07:58:06.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1>]]></content>
    
    
    <summary type="html">🥧本文汇总Maven的安装和使用</summary>
    
    
    
    <category term="工具" scheme="https://momoao.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Maven" scheme="https://momoao.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Mysql优化</title>
    <link href="https://momoao.github.io/posts/202310090917.html"/>
    <id>https://momoao.github.io/posts/202310090917.html</id>
    <published>2023-10-09T00:19:03.000Z</published>
    <updated>2023-10-22T05:04:50.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql优化"><a href="#Mysql优化" class="headerlink" title="Mysql优化"></a>Mysql优化</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009092427508.png" alt="image-20231009092427508"></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009092807083.png" alt="image-20231009092807083"></p><p>缺点</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009093012133.png" alt="image-20231009093012133"></p><h3 id="红黑树（平衡二叉树）"><a href="#红黑树（平衡二叉树）" class="headerlink" title="红黑树（平衡二叉树）"></a>红黑树（平衡二叉树）</h3><p>如果连续两个节点只有一个子节点，就会自动进行平衡</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009093152914.png" alt="image-20231009093152914"></p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009093315712.png" alt="image-20231009093315712"></p><h3 id="B树（平衡多路树）"><a href="#B树（平衡多路树）" class="headerlink" title="B树（平衡多路树）"></a>B树（平衡多路树）</h3><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009093747603.png" alt="image-20231009093747603"></p><p>结构</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009094040528.png" alt="image-20231009094040528"></p><p>例如：一个三阶B树，当一个节点的数据为2时，在来新的数据就会创建新的子节点</p><p>缺点：对一个范围内的所有数据进行查找很麻烦</p><p>例如：找1~5的数据，就会从1开始找一个一个找，直到找到5</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009094339955.png" alt="image-20231009094339955"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009094416308.png" alt="image-20231009094416308"></p><p>将所有数据都存在叶子结点</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009094440684.png" alt="image-20231009094440684"></p><ul><li>优点：<ul><li>因为只有叶子节点才存数据，所以其他节点可以拥有更多的空间存储索引</li><li>因为每个节点索引的增多，所以查找字数就变少了</li><li>查找原理<ul><li>找到一个磁盘页就将这个磁盘页传输到内存中，然后在内存中进行判断</li><li>又因为磁盘页中只有索引，所以传输到内存中的速度就变快了，可以更快的进行查找，最终找到数据</li></ul></li><li>因为叶子节点之间是双链表结构，所以范围查找时，可以更快的找到范围内的所有数据</li></ul></li></ul><h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><p>B+树具有以下优势：</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009100023370.png" alt="image-20231009100023370"></p><h3 id="如果表没有主键索引，还会创建B-树吗"><a href="#如果表没有主键索引，还会创建B-树吗" class="headerlink" title="如果表没有主键索引，还会创建B+树吗"></a>如果表没有主键索引，还会创建B+树吗</h3><p>会的！</p><p>底层会有一个隐藏索引叫row-id</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009100120652.png" alt="image-20231009100120652"></p><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009100315895.png" alt="image-20231009100315895"></p><p>只有Memory支持Hash索引</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009100328482.png" alt="image-20231009100328482"></p><p>索引原理</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009100353313.png" alt="image-20231009100353313"></p><ul><li>优点<ul><li>查询效率高</li></ul></li><li>缺点<ul><li>不支持范围查询和排序</li></ul></li></ul><h2 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h2><p>聚集索引：索引和数据存储在一起</p><p>非聚集索引：索引和数据不存储在一起</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009101137281.png" alt="image-20231009101137281"></p><p>非聚集索引的叶子节点不存数据，存储指针，指向数据块的某行</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009101501849.png" alt="image-20231009101501849"></p><h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>都是非聚集索引</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009101811893.png" alt="image-20231009101811893"></p><p>例如：</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009101904247.png" alt="image-20231009101904247"></p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009101929869.png" alt="image-20231009101929869"></p><p>查找的时候就会比普通查找更快</p><p>普通查找：查找每一条数据直到找到对应的age</p><p>索引查找：在age的索引表中找到对应主键的值即可找到所以数据</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009102011065.png" alt="image-20231009102011065"></p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引是一个好的现象</p><p>如果只查找主键，还是通过age索引查找，拿到主键直接返回即可</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009102157757.png" alt="image-20231009102157757"></p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009102301020.png" alt="image-20231009102301020"></p><p>覆盖索引的关键在于，这个索引表中包含了查询中的所有列，而不仅仅是用于查找的列。这意味着数据库可以从索引本身中获取查询所需的数据，而无需查找实际的数据行。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>是二级索引的优化</p><p>不使用索引下推时：</p><p>根据name和age查询所有数据，因为name和age是二级索引，可以根据索引查找id，但是要回n次表，才能查出所有数据</p><p>每一次找到二级索引都要进行回表操作</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009102531986.png" alt="image-20231009102531986"></p><h3 id="索引下推作用"><a href="#索引下推作用" class="headerlink" title="索引下推作用"></a>索引下推作用</h3><p>在二级索引表中查出符合条件的所有id，一起进行回表操作，这样就会将回表的次数由n次变为一次</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009102920735.png" alt="image-20231009102920735"></p><h2 id="单列、组合索引"><a href="#单列、组合索引" class="headerlink" title="单列、组合索引"></a>单列、组合索引</h2><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>单列索引是基于单个表列的索引，用于加速对单个列的搜索和排序</p><p>提问：如果列是字符串，这个列变为索引的时候也是也能排序吗</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009124718785.png" alt="image-20231009124718785"></p><p>在创建数据库时指定排序规则也可以实现支持中文的排序</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009124753360.png" alt="image-20231009124753360"></p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009125038927.png" alt="image-20231009125038927"></p><p>所以索引页也会形成B+树的格式</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009125057311.png" alt="image-20231009125057311"></p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009125136271.png" alt="image-20231009125136271"></p><p>会先按照第一个列来排序</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009125225612.png" alt="image-20231009125225612"></p><p>所以，当联合索引的第一个列是a时，只能在条件为a开头的任意组合条件时使用这个索引</p><p>因为只有第一列是有序的，而其他索引列是无需的，只有有序的才能在B+树中通过二分法查找到对应的数据</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009125419742.png" alt="image-20231009125419742"></p><h3 id="分别的使用场景和优势、"><a href="#分别的使用场景和优势、" class="headerlink" title="分别的使用场景和优势、"></a>分别的使用场景和优势、</h3><h4 id="联合索引的优势"><a href="#联合索引的优势" class="headerlink" title="联合索引的优势"></a>联合索引的优势</h4><p>减少开销</p><p>可以减少磁盘的开销，创建一个联合索引（a,b,c）相当于创建了(a)  (a,b)  (a,c)  (a,b,c)四个，</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009130121755.png" alt="image-20231009130121755"></p><p>覆盖索引</p><p>如创建联合索引(a,b,c)</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009130231667.png" alt="image-20231009130231667"></p><p>效率高</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009144048185.png" alt="image-20231009144048185"></p><h2 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h2><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009145310249.png" alt="image-20231009145310249"></p><p>什么时候用好</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009145542541.png" alt="image-20231009145542541"></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009145724838.png" alt="image-20231009145724838"></p><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>含义</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009154025546.png" alt="image-20231009154025546"></p><p>作用</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009154235795.png" alt="image-20231009154235795"></p><p>用法</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009154246445.png" alt="image-20231009154246445"></p><p>explain查出的数据的含义</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009155057037.png" alt="image-20231009155057037"></p><h3 id="id列、table列"><a href="#id列、table列" class="headerlink" title="id列、table列"></a>id列、table列</h3><p>先执行id大的，id相同时，先执行下方的</p><p>可以看见先扫描的products表，后扫描的orders表</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009164908787.png" alt="image-20231009164908787"></p><p>使用union关键字</p><p>id为null时最后执行</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231009181539069.png" alt="image-20231009181539069"></p><p>打开衍生表合并优化之后，发现之前id为1和2的语句，都变为了1，这是因为衍射表合并优化</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h3><p>每一次insert都要建立链接，所以尽量批量插入</p><ul><li>批量插入<ul><li>一次数据500~1000条较为合适</li><li>数据量很大时，可以分为多批插入</li></ul></li><li>手动提交事务<ul><li>因为事务默认提交，所以每次执行SQL语句都会开启事务、提交事务，较为浪费资源</li><li>使用start transaction和commit来手动提交事务</li></ul></li><li>主键顺序插入<ul><li>多条数据插入时，要按主键的顺序排列后写到SQL语句中，在进行插入</li></ul></li></ul><h3 id="load指令"><a href="#load指令" class="headerlink" title="load指令"></a>load指令</h3><p>同样是插入insert和load同样插入100w条数据，insert耗时15分钟，load耗时16秒</p><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下：</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010080320476.png" alt="image-20231010080320476"></p><p>指令演示</p><p><code>–-local-infile</code>代表客户端连接服务端时加载本地文件</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –-<span class="keyword">local</span>-<span class="keyword">infile</span> -<span class="keyword">u</span> root -p</span><br></pre></td></tr></table></figure><p>设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global local_infile <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>加载本地文件<code>/root/sql1.log</code>每列数据用<code>，</code>分割，每行数据用<code>\n</code>分割</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> ;</span><br></pre></td></tr></table></figure><p>完成数据插入</p><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p><p>InnoDB的逻辑结构图：</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010081714528.png" alt="image-20231010081714528"></p><p>看单位换算出，一个区中有64个页</p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接</p><ul><li><p>页分裂</p><ul><li><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行</p><p>溢出)，根据主键排列。</p><ul><li>InnoDB 存储引擎默认情况下支持的最大行大小是约 8,060 字节，所以一行数据的大小不会超过16k</li></ul></li></ul></li></ul><h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><h4 id="主键顺序插入效果"><a href="#主键顺序插入效果" class="headerlink" title="主键顺序插入效果"></a>主键顺序插入效果</h4><p>从磁盘中申请页， 主键顺序插入</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082532578.png" alt="image-20231010082532578"></p><p>第一个页没有满，继续往第一页插入</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082553216.png" alt="image-20231010082553216"></p><p>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082605517.png" alt="image-20231010082605517"></p><p>当第二页写满了，再往第三页写入</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082614342.png" alt="image-20231010082614342"></p><h4 id="主键乱序插入效果"><a href="#主键乱序插入效果" class="headerlink" title="主键乱序插入效果"></a>主键乱序插入效果</h4><p> 加入1#,2#页都已经写满了，存放了如图所示的数据</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082626266.png" alt="image-20231010082626266"></p><p>此时再插入id为50的记录，我们来看看会发生什么现象会再次开启一个页，写入新的页中吗？</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082640495.png" alt="image-20231010082640495"></p><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082708315.png" alt="image-20231010082708315"></p><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082730339.png" alt="image-20231010082730339"></p><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082753793.png" alt="image-20231010082753793"></p><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082834103.png" alt="image-20231010082834103"></p><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>目前表中已有数据的索引结构(叶子节点)如下：</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082929944.png" alt="image-20231010082929944"></p><p>当我们对已有数据进行删除时，具体的效果如下:</p><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010082944510.png" alt="image-20231010082944510"></p><p>当我们继续删除2#的数据记录</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010083006977.png" alt="image-20231010083006977"></p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010083035107.png" alt="image-20231010083035107"></p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010083048428.png" alt="image-20231010083048428"></p><p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010083102535.png" alt="image-20231010083102535"></p><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。<ul><li>使用UUID作为主键会导致索引树的高度增加，因为UUID的随机性会使得索引树实现平衡后，也更加深。</li><li>UUID通常比整数主键更大，占用更多的存储空间。这会导致B+树像内存传输磁盘页时造成更大的开销</li></ul></li><li>业务操作时，避免对主键的修改。<ul><li>会改变B+树的结构，造成额外的性能开销</li></ul></li></ul><h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><ul><li><p>MySQL的排序，有两种方式</p><ul><li>（使用字段排序）Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>（使用索引排序）Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li></ul></li><li><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序</p><p>操作时，尽量要优化为 Using index</p></li></ul><h3 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age ;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084216298.png" alt="image-20231010084216298"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age, phone ;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084234907.png" alt="image-20231010084234907"></p><p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。</p><h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h3><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_age_phone_aa <span class="keyword">on</span> tb_user(age,phone);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084330857.png" alt="image-20231010084330857"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age , phone;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084348514.png" alt="image-20231010084348514"></p><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能就是比较高的了</p><h5 id="创建索引后，根据age-phone进行降序排序"><a href="#创建索引后，根据age-phone进行降序排序" class="headerlink" title="创建索引后，根据age, phone进行降序排序"></a>创建索引后，根据age, phone进行降序排序</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> , phone <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084431468.png" alt="image-20231010084431468"></p><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name <span class="keyword">DESC</span>)</span><br></pre></td></tr></table></figure><h3 id="根据age-phone进行降序一个升序，一个降序"><a href="#根据age-phone进行降序一个升序，一个降序" class="headerlink" title="根据age, phone进行降序一个升序，一个降序"></a>根据age, phone进行降序一个升序，一个降序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , phone <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084611840.png" alt="image-20231010084611840"></p><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现Using filesort。</p><p>使用<code>show index from tb_user</code>可以查看到索引是升序还是降序</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084626269.png" alt="image-20231010084626269"></p><p>为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序，phone 倒序排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_age_phone_ad <span class="keyword">on</span> tb_user(age <span class="keyword">asc</span> ,phone <span class="keyword">desc</span>);</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084804616.png" alt="image-20231010084804616"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , phone <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084820923.png" alt="image-20231010084820923"></p><p>升序/降序联合索引结构图示:</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084942346.png" alt="image-20231010084942346"></p><p><strong>注意：在保证age升序的情况下，phone只在一个子节点内是降序的</strong></p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010084946212.png" alt="image-20231010084946212"></p><h3 id="order-by优化原则"><a href="#order-by优化原则" class="headerlink" title="order by优化原则:"></a>order by优化原则:</h3><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)</li></ul><h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><p>在没有索引的情况下，执行如下SQL，查询执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> profession , <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession ;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010085308765.png" alt="image-20231010085308765"></p><p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession , age , status); </span><br></pre></td></tr></table></figure><p>紧接着，再执行前面相同的SQL查看执行计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> profession , <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession ;</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010085410024.png" alt="image-20231010085410024"></p><p>再执行如下的分组查询SQL，查看执行计划：</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010085422099.png" alt="image-20231010085422099"></p><p>这里没有使用最左前缀</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010085431922.png" alt="image-20231010085431922"></p><p>我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作，在联合索引中，也是符合最左前缀法则的。</p><h4 id="所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能："><a href="#所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：" class="headerlink" title="所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能："></a>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</h4><ul><li>在分组操作时，可以通过索引来提高效率。<ul><li>注意：联合索引要使用最左前缀</li></ul></li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>我们一起来看看执行limit分页查询耗时对比：</p><p><img src="../assets/image/Mysql%E4%BC%98%E5%8C%96_Image/image-20231010090658656.png" alt="image-20231010090658656"></p><p>通过测试我们会看到，越往后，分页查询效率越低，这就是分页查询的问题所在。</p><p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 </p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku t , (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><p>覆盖索引（Covering Index）是一种特殊类型的索引，它包含了查询所需的所有列，从而避免了对实际数据行的查找。这种索引能够直接满足查询的需求，而不需要访问表中的实际数据行，因此可以显著提高查询性能。</p><h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><h2 id="Ai总结"><a href="#Ai总结" class="headerlink" title="Ai总结"></a>Ai总结</h2><h3 id="红黑树是怎么保证平衡的"><a href="#红黑树是怎么保证平衡的" class="headerlink" title="红黑树是怎么保证平衡的"></a>红黑树是怎么保证平衡的</h3><p>红黑树是一种自平衡的二叉搜索树，它通过一系列的规则来保证树的高度始终保持在一个相对较小的范围内，从而保证了基本的查找、插入和删除操作的性能在最坏情况下也能保持在对数时间复杂度内。</p><p>红黑树的平衡性主要依赖于以下五个性质：</p><ol><li><p><strong>每个节点要么是红色，要么是黑色。</strong></p></li><li><p><strong>根节点是黑色的。</strong></p></li><li><p><strong>每个叶子节点（NIL节点，空节点）是黑色的。</strong></p></li><li><p><strong>如果一个节点是红色的，那么它的子节点必须是黑色的。</strong></p></li><li><p><strong>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点，这个数目被称为黑高度。</strong></p></li></ol><p>这些规则确保了红黑树在任何情况下，从根节点到叶子节点的最长路径不会超过最短路径的两倍。这使得红黑树保持了相对平衡，从而保证了对数时间的操作复杂度。</p><p>当插入或删除一个节点时，红黑树可能会发生变化，需要通过旋转和重新着色等操作来保持这些性质。</p><p>具体的操作可以分为以下几种情况：</p><ol><li><p><strong>左旋（Left Rotation）</strong></p></li><li><p><strong>右旋（Right Rotation）</strong></p></li><li><p><strong>变色（Color Flip）</strong></p></li><li><p><strong>插入</strong></p></li><li><p><strong>删除</strong></p></li></ol><p>这些操作保证了红黑树的平衡性，使其在插入和删除等动态操作时能够保持较好的性能。</p><p>需要注意的是，虽然红黑树可以保证相对平衡，但它不是绝对平衡的，因此在某些特定情况下，可能会有其他平衡树结构更适合的场景。</p><h3 id="explain关键字"><a href="#explain关键字" class="headerlink" title="explain关键字"></a>explain关键字</h3><p><code>EXPLAIN</code> 是一个在 MySQL 中用于查询优化的关键字。当你执行一条 SQL 查询语句时，可以在查询前加上 <code>EXPLAIN</code> 关键字，MySQL 将会解释该查询的执行计划，而不会实际执行查询，从而帮助你分析和优化查询性能。</p><p><code>EXPLAIN</code> 返回一个查询执行计划的结果集，这个结果集包含有关查询执行的详细信息，包括以下关键信息：</p><ol><li><p><strong>执行顺序：</strong> 查询执行计划中的每个步骤的执行顺序。</p></li><li><p><strong>访问类型：</strong> 每个步骤的数据访问方式，例如全表扫描、索引扫描、范围扫描等。</p></li><li><p><strong>扫描的表：</strong> 在查询执行中涉及的表的名称。</p></li><li><p><strong>扫描的行数：</strong> 每个步骤扫描的行数估计值。</p></li><li><p><strong>使用的索引：</strong> 如果查询使用了索引，将显示使用的索引名称。</p></li><li><p><strong>额外信息：</strong> 提供有关查询执行的其他信息，如使用了临时表、文件排序等。</p></li></ol><p>通过分析 <code>EXPLAIN</code> 的输出，你可以了解到查询的执行计划，识别性能瓶颈，并决定是否需要进行索引优化、重写查询或者调整数据库表结构等操作来提高查询性能。</p><p>以下是一个简单的示例，演示如何使用 <code>EXPLAIN</code> 关键字：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> your_table <span class="keyword">WHERE</span> column1 <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行上述查询后，你将会得到一个包含查询执行计划的结果集，从中可以了解到查询的执行方式和可能的优化机会。</p><p><code>EXPLAIN</code> 是一个非常有用的工具，特别是在处理复杂查询或需要优化性能的查询时。它可以帮助数据库管理员和开发人员更好地理解数据库引擎是如何执行查询的，从而做出有针对性的性能优化决策。</p><h3 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h3><p>MySQL中可以创建自定义排序规则，这样你可以实现特定的排序需求。自定义排序规则通常通过使用<code>COLLATE</code>子句来实现，<code>COLLATE</code>子句允许你指定用于排序和比较的字符集以及排序规则。</p><p>以下是如何创建自定义排序规则的示例以及它们的区别：</p><ol><li><p><strong>默认排序规则（Binary Sorting）：</strong> 默认情况下，MySQL 使用二进制排序规则，它将字符按其字节值进行排序。这意味着大写字母会排在小写字母前，而不考虑它们的字母顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> user_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> name;</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义排序规则（Case-Insensitive Sorting）：</strong> 如果你想进行不区分大小写的排序，可以使用<code>COLLATE</code>子句来指定一个不区分大小写的排序规则，如<code>utf8_general_ci</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> user_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> name <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义排序规则（Accent-Insensitive Sorting）：</strong> 如果你需要进行不区分重音符号（diacritics）的排序，也可以使用自定义排序规则，如<code>utf8_general_ci</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> user_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> name <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure></li></ol><p>中文列也能实现排序，但需要特别注意的是，中文排序需要使用支持中文字符集的排序规则。通常，UTF-8字符集的一些排序规则可以用于中文排序。例如，<code>utf8_general_ci</code>排序规则可以用于不区分大小写和不区分重音符号的中文排序。</p><p>要注意的是，如果你需要更精细的中文排序，可能需要使用特定的中文排序规则，例如<code>utf8_unicode_ci</code>或<code>utf8mb4_unicode_ci</code>。这些规则考虑了中文字符的字母顺序和重音符号，可以更准确地满足中文排序需求。</p><p>总之，MySQL允许你创建自定义排序规则，以满足不同语言和排序需求。你可以根据具体情况选择合适的字符集和排序规则来实现你的排序需求，包括中文列的排序。</p><h3 id="MySQL8-0中的降序索引和索引的区别"><a href="#MySQL8-0中的降序索引和索引的区别" class="headerlink" title="MySQL8.0中的降序索引和索引的区别"></a>MySQL8.0中的降序索引和索引的区别</h3><p>MySQL 8.0 中的降序索引和普通索引主要有以下区别：</p><ol><li><p><strong>索引排序方式：</strong></p><ul><li><strong>普通索引（升序索引）：</strong> 默认情况下，MySQL的索引是升序的，这意味着索引会按照从小到大的顺序存储数据。</li><li><strong>降序索引：</strong> 降序索引是一种特殊的索引，它会按照从大到小的顺序存储数据。</li></ul></li><li><p><strong>查询性能：</strong></p><ul><li><strong>普通索引（升序索引）：</strong> 当您使用普通索引进行查询时，MySQL可以更有效地利用索引来提高查询性能，特别是在执行范围查询（例如<code>WHERE</code>子句中使用<code>BETWEEN</code>或<code>&gt;</code>和<code>&lt;</code>等条件）时。</li><li><strong>降序索引：</strong> 降序索引在某些特定情况下可能会降低查询性能，因为它不如升序索引那样有效地支持升序的查询。如果您的查询通常需要按升序排序结果，使用降序索引可能导致性能下降。</li></ul></li><li><p><strong>语法和创建方式：</strong></p><ul><li><strong>普通索引（升序索引）：</strong> 普通索引是默认的索引类型，您可以使用<code>CREATE INDEX</code>语句或在表定义中的列上使用<code>INDEX</code>关键字来创建它们。</li><li><strong>降序索引：</strong> 若要创建降序索引，您需要明确指定<code>DESC</code>关键字，例如：<code>CREATE INDEX index_name ON table_name (column_name DESC)</code>。</li></ul></li><li><p><strong>使用场景：</strong></p><ul><li><strong>普通索引（升序索引）：</strong> 普通索引通常适用于大多数查询场景，尤其是在需要升序排序结果或执行范围查询时。</li><li><strong>降序索引：</strong> 降序索引适用于一些特殊需求，例如需要按降序排序的查询，或者某些特殊的应用场景。</li></ul></li></ol><p>总之，普通索引和降序索引的主要区别在于索引的排序方式以及对查询性能的影响。在选择索引类型时，应根据您的具体需求和查询模式来决定使用哪种类型的索引。通常情况下，普通索引（升序索引）是默认和常用的索引类型，而降序索引则是用于特殊情况的选项。</p><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p><code>EXPLAIN</code> 是 MySQL 中用于查询优化的关键工具之一。执行 <code>EXPLAIN</code> 查询可以让您查看 MySQL 查询优化器的执行计划，以便更好地理解查询是如何执行的，并帮助您进行性能调优。<code>EXPLAIN</code> 查询返回一组列，每列都提供了有关查询执行计划的重要信息。以下是 <code>EXPLAIN</code> 查询返回的列的含义：</p><ol><li><p><strong>id（标识符）：</strong> 这是查询的标识符，通常是一个整数。在复杂查询中，您可能会看到多个查询步骤，每个步骤都有一个唯一的标识符。这些标识符的值按照查询执行的顺序递增。</p></li><li><p><strong>select_type（查询类型）：</strong> 这是描述查询类型的列。可能的值包括：</p><ul><li><code>SIMPLE</code>：简单查询，不包含子查询或联接。</li><li><code>PRIMARY</code>：最外层查询。</li><li><code>SUBQUERY</code>：子查询。</li><li><code>DERIVED</code>：派生表，通常是从子查询或临时表中派生出的结果。</li><li><code>UNION</code>：联合查询。</li><li><code>UNION RESULT</code>：联合查询的结果。</li><li><code>DEPENDENT SUBQUERY</code>：依赖于外部查询的子查询。</li><li>等等。</li></ul></li><li><p><strong>table（表名）：</strong> 这是查询涉及的表的名称。如果查询涉及多个表，您会看到多个表名以逗号分隔。</p></li><li><p><strong>partitions（分区）：</strong> 如果查询使用了分区表，这一列会显示查询涉及的分区。</p></li><li><p><strong>type（访问类型）：</strong> 这是查询执行的访问方式，通常表示了如何访问表来检索数据。可能的值包括：</p><ul><li><code>ALL</code>：全表扫描，查询将检索整个表。</li><li><code>INDEX</code>：使用索引扫描来检索数据。</li><li><code>RANGE</code>：使用索引范围扫描。</li><li><code>REF</code>：使用非唯一索引来查找单个行。</li><li><code>FULLTEXT</code>：使用全文索引。</li><li><code>CONST</code>：使用常量值。</li><li><code>SYSTEM</code>：系统表的访问。</li><li>等等。</li></ul></li><li><p><strong>possible_keys（可能的索引）：</strong> 这列显示了可能用于查询的索引列表。这些索引是优化器考虑使用的潜在索引。多个索引以逗号分隔。</p></li><li><p><strong>key（实际使用的索引）：</strong> 这是查询实际使用的索引，如果没有使用索引，则为 <code>NULL</code>。</p></li><li><p><strong>key_len（索引长度）：</strong> 这是使用的索引的长度，通常以字节为单位表示。</p></li><li><p><strong>ref（索引之间的比较值）：</strong> 如果查询涉及多个表，这列显示了用于比较的列或常量值。</p></li><li><p><strong>rows（扫描的行数）：</strong> 这是估计的查询执行过程中扫描的行数。它不一定是准确的，但可以用于评估查询的相对成本。</p></li><li><p><strong>filtered（过滤率）：</strong> 这是一个估计值，表示优化器根据索引选择的行数占总行数的百分比。它用于评估查询的选择性。</p></li><li><p><strong>Extra（附加信息）：</strong> 这列包含了额外的执行计划信息，可能包括排序方式、使用的临时表、使用的文件排序、使用的索引类型等等。</p></li></ol><p>通过分析 <code>EXPLAIN</code> 查询的输出，您可以更好地理解查询的执行计划，识别潜在的性能问题，并根据需要进行索引优化、查询重写或其他性能调整。这些列提供了有关查询执行的详细信息，有助于优化查询性能。</p><h4 id="Extra中可能得值"><a href="#Extra中可能得值" class="headerlink" title="Extra中可能得值"></a>Extra中可能得值</h4><p>在 MySQL 的 <code>EXPLAIN</code> 查询输出中，<code>Extra</code> 列包含了一些额外的执行计划信息，用于提供有关查询执行的进一步上下文。这些额外的信息有助于理解查询执行计划中的一些细节和特殊情况。以下是一些可能包含在 <code>Extra</code> 列中的信息：</p><ol><li><p><strong>Using index：</strong> 表示查询使用了覆盖索引（Covering Index），这意味着查询的结果可以直接从索引中获取，而不需要访问表的实际数据行。这通常会提高查询性能，因为它减少了磁盘I/O操作。</p></li><li><p><strong>Using where：</strong> 表示在查询执行中使用了 <code>WHERE</code> 子句进行条件过滤。这是大多数查询的正常行为。</p></li><li><p><strong>Using filesort：</strong> 表示查询执行中需要进行文件排序，通常是因为没有合适的索引来支持排序操作，或者 <code>ORDER BY</code> 子句包含复杂的排序条件。</p></li><li><p><strong>Using join buffer：</strong> 表示在连接操作中使用了连接缓冲区。这通常发生在连接表的大小较大或连接操作复杂的情况下。</p></li><li><p><strong>Impossible WHERE：</strong> 表示查询的 <code>WHERE</code> 子句包含了不可能满足的条件，因此查询不会返回任何结果。这可以帮助您识别查询条件是否正确。</p></li><li><p><strong>Select tables optimized away：</strong> 表示查询优化器已经优化掉了不需要的表，这通常发生在没有使用的表或没有连接条件的表。</p></li><li><p><strong>No tables used：</strong> 表示查询没有使用任何表，通常是由于 <code>SELECT</code> 子句中没有指定表或查询条件被优化掉了。</p></li><li><p><strong>Distinct：</strong> 表示查询执行中使用了 <code>DISTINCT</code> 关键字来去重结果集。</p></li><li><p><strong>Full scan on NULL key：</strong> 表示查询执行中发生了对索引上的 NULL 键的完整扫描。</p></li><li><p><strong>Range checked for each record：</strong> 表示在查询执行中对每个记录都进行了范围检查，通常发生在使用范围条件的查询。</p></li><li><p><strong>Using temporary：</strong> 如前面提到的，在排序、分组和连接等操作中，可能需要使用临时表来处理中间结果。</p></li><li><p><strong>Using filesort：</strong> 表示查询执行中需要使用文件排序来满足排序操作的要求。</p></li><li><p><strong>Using index condition：</strong> 表示查询执行中使用了索引条件推送优化，其中一部分查询过滤操作可以在索引层面执行，而不需要访问表的实际数据。</p></li></ol><p>这些是一些常见的 <code>Extra</code> 列中可能包含的信息。理解 <code>Extra</code> 列中的内容可以帮助您更好地理解查询的执行计划，识别潜在的性能问题，并根据需要进行查询优化。不同的 <code>Extra</code> 信息可能需要不同的优化策略。</p>]]></content>
    
    
    <summary type="html">🥧本文汇总Mysql优化的基础知识</summary>
    
    
    
    <category term="数据库" scheme="https://momoao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://momoao.github.io/tags/MySQL/"/>
    
    <category term="优化" scheme="https://momoao.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="https://momoao.github.io/posts/202310071028.html"/>
    <id>https://momoao.github.io/posts/202310071028.html</id>
    <published>2023-10-07T00:19:03.000Z</published>
    <updated>2023-10-07T02:37:30.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h2 id="常用结构"><a href="#常用结构" class="headerlink" title="常用结构"></a>常用结构</h2><p><img src="../assets/image/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6_Image/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.png" alt="Java集合框架"></p><h2 id="Ai总结"><a href="#Ai总结" class="headerlink" title="Ai总结"></a>Ai总结</h2>]]></content>
    
    
    <summary type="html">🥧本文汇总Java集合框架的基础知识点</summary>
    
    
    
    <category term="框架" scheme="https://momoao.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus</title>
    <link href="https://momoao.github.io/posts/202309142103.html"/>
    <id>https://momoao.github.io/posts/202309142103.html</id>
    <published>2023-09-14T10:19:03.000Z</published>
    <updated>2023-10-18T11:26:10.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h1><div class="note info flat"><p>参考：学习参考B站尚硅谷-MyBatisPlus教程</p></div><p><a href="https://baomidou.com/pages/24112f/">MyBatis-Plus官网文档</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>MyBatis-Plus</strong>（简称 MP）是一个 <strong>MyBatis**</strong>的增强工具<strong>，在 MyBatis 的基础上</strong>只做增强不做改变**，为</p><p><strong>简化开发、提高效率而生</strong>。</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230915155128685.png" alt="image-20230915155128685"></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h3><p><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</p><p><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</p><p><strong>强大的</strong> <strong>CRUD</strong> <strong>操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分</p><p>CRUD 操作，更有强大的条件构造器，满足各类使用需求</p><p><strong>支持</strong> <strong>Lambda</strong> <strong>形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p><p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由</p><p>配置，完美解决主键问题</p><p><strong>支持</strong> <strong>ActiveRecord</strong> <strong>模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强</p><p>大的 CRUD 操作</p><p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</p><p><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、</p><p>Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p><p><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等</p><p>同于普通 List 查询</p><p><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、</p><p>Postgre、SQLServer 等多种数据库</p><p><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出</p><p>慢查询</p><p><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防</p><p>误操作</p><h3 id="支持数据库"><a href="#支持数据库" class="headerlink" title="支持数据库"></a>支持数据库</h3><p>任何能使用MyBatis进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下</p><p>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，</p><p>ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</p><p>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据</p><p>库，瀚高数据库</p><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><p><img src="../assets/image/MyBatis-Plus_Image/image-20230915155214820.png" alt="image-20230915155214820"></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>IDE：idea 2022.3</p><p>JDK：JDK8+</p><p>构建工具：maven 3.5.4</p><p>MySQL版本：MySQL 8.3</p><p>Spring Boot：2.6.3</p><p>MyBatis-Plus：3.5.1</p><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>在ioc容器中只能存在类对应的bean不能存在接口对应的bean</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>使用MySQL创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `mybatis_plus` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;</span><br><span class="line">use `mybatis_plus`;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">`id` bigint(20) NOT NULL COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">`name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">`email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user (id, name, age, email) VALUES</span><br><span class="line">(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),</span><br><span class="line">(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),</span><br><span class="line">(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),</span><br><span class="line">(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),</span><br><span class="line">(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;);</span><br></pre></td></tr></table></figure><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p>使用IDEA创建SpringBoot工程</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230915151757559.png" alt="image-20230915151757559"></p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230915151831974.png" alt="image-20230915151831974"></p><p>引入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置application-yml"><a href="#配置application-yml" class="headerlink" title="配置application.yml"></a>配置application.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment"># 配置连接数据库的各个信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;userSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mysql123456</span></span><br></pre></td></tr></table></figure><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><p>在Spring Boot启动类中添加@MapperScan注解，扫描mapper包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisplusApplication</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisplusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加实体"><a href="#添加实体" class="headerlink" title="添加实体"></a>添加实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时自动生成无参构造</span></span><br><span class="line"><span class="comment">//@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//所有参数的有参构造</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor</span></span><br><span class="line"><span class="comment">//@Getter</span></span><br><span class="line"><span class="comment">//@Setter</span></span><br><span class="line"><span class="comment">//@EqualsAndHashCode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="添加Mapper"><a href="#添加Mapper" class="headerlink" title="添加Mapper"></a>添加Mapper</h3><p>BaseMapper接口由MaBatis-plus提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数</span></span><br><span class="line">        <span class="comment">//相当于select (所有列名，并非*) from User</span></span><br><span class="line">        List&lt;User&gt; list = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发现    private UserMapper userMapper;这行报错，是因为UserMapper 是一个接口，系统会画红线提示：“无法自动装配，找不到‘UserMapper’的bean”，这是因为UserMapper 不是一个类，为了解决这个问题要在UserMapper 接口的定义上加一个@Repository注解</p><p>将这个接口标识为持久层组件（类也可以用这个注解进行标识）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加日志功能"><a href="#添加日志功能" class="headerlink" title="添加日志功能"></a>添加日志功能</h3><p>在yml配置文件中添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>添加这个功能后输出的日志中将出现MyBatis-Plus自动生成并执行的SQL语句</p><h3 id="CRUD测试"><a href="#CRUD测试" class="headerlink" title="CRUD测试"></a>CRUD测试</h3><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//实现新增用户信息</span></span><br><span class="line">    <span class="comment">//INSERT INTO user ( id, name, age, email ) VALUES ( ?, ?, ?, ? )</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">//user.setId(100L);</span></span><br><span class="line">    user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">23</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;zhangsan@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>一共有5种方法</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230915175602725.png" alt="image-20230915175602725"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过id删除用户信息</span></span><br><span class="line">    <span class="comment">//DELETE FROM user WHERE id=?</span></span><br><span class="line">    <span class="comment">//注意这里因为ID的值超出了int的范围，所以要加一个L，表示这个数字是一个长整数</span></span><br><span class="line">    <span class="comment">/*int result = userMapper.deleteById(1492767055210991617L);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;result:&quot;+result);*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据map集合中所设置的条件删除用户信息</span></span><br><span class="line">    <span class="comment">//DELETE FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    <span class="comment">/*Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">        map.put(&quot;name&quot;, &quot;张三&quot;);</span></span><br><span class="line"><span class="comment">        map.put(&quot;age&quot;, 23);</span></span><br><span class="line"><span class="comment">        int result = userMapper.deleteByMap(map);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;result:&quot;+result);*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过多个id实现批量删除</span></span><br><span class="line">    <span class="comment">//DELETE FROM user WHERE id IN ( ? , ? , ? )</span></span><br><span class="line">    List&lt;Long&gt; list = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code> 是 Java 中的一个接口，用于标记类的实例可以被序列化（即，可以将对象转换为字节序列以便于存储或传输），并在需要时可以反序列化（将字节序列重新转换为对象）。<code>Serializable</code> 接口在 Java 标准库中位于 <code>java.io</code> 包中。</p><h4 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//修改用户信息</span></span><br><span class="line">    <span class="comment">//UPDATE user SET name=?, email=? WHERE id=?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">4L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;lisi@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE<span class="built_in"> user </span><span class="built_in">SET</span> <span class="attribute">name</span>=?, <span class="attribute">email</span>=? WHERE <span class="attribute">id</span>=?</span><br><span class="line">==&gt; Parameters: 李四(String), lisi@atguigu.com(String), 4(Long)</span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>Serializable类型的参数代表这个参数必须是可序列化的</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230915181717416.png" alt="image-20230915181717416"></p><ol><li>根据id查询</li><li>根据id查询多个用户（利用的<code>where id in (?,?,?)</code>的方式）</li><li>根据Map<String,Object>中的具体参数查询用户</li><li>查询所有信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//通过id查询用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM user WHERE id=?</span></span><br><span class="line">    <span class="comment">/*User user = userMapper.selectById(1L);</span></span><br><span class="line"><span class="comment">    System.out.println(user);*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据多个id查询多个用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )</span></span><br><span class="line">    <span class="comment">/*List&lt;Long&gt; list = Arrays.asList(1L, 2L, 3L);</span></span><br><span class="line"><span class="comment">    List&lt;User&gt; users = userMapper.selectBatchIds(list);</span></span><br><span class="line"><span class="comment">    users.forEach(System.out::println);*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据map集合中的条件查询用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    <span class="comment">/*Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">    map.put(&quot;name&quot;, &quot;Jack&quot;);</span></span><br><span class="line"><span class="comment">    map.put(&quot;age&quot;, 20);</span></span><br><span class="line"><span class="comment">    List&lt;User&gt; users = userMapper.selectByMap(map);</span></span><br><span class="line"><span class="comment">    users.forEach(System.out::println);*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询所有数据</span></span><br><span class="line">    <span class="comment">//SELECT id,name,age,email FROM user</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">    <span class="comment">/*Map&lt;String, Object&gt; map = userMapper.selectMapById(1L);</span></span><br><span class="line"><span class="comment">    System.out.println(map);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> id,name,age,email <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: </span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>    Columns: id, name, age, email</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">1</span>, Jone, <span class="number">18</span>, test1<span class="variable">@baomidou</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">2</span>, Jack, <span class="number">20</span>, test2<span class="variable">@baomidou</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">3</span>, Tom, <span class="number">28</span>, test3<span class="variable">@baomidou</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">4</span>, 李四, <span class="number">21</span>, lisi<span class="variable">@atguigu</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">5</span>, Billie, <span class="number">24</span>, test5<span class="variable">@baomidou</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>      Total: <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="自定义CRUD"><a href="#自定义CRUD" class="headerlink" title="自定义CRUD"></a>自定义CRUD</h3><p>在resources目录下创建一个mapper目录（必须是mapper），创建映射文件UserMapper.xml</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230915183357703.png" alt="image-20230915183357703"></p><p>给UserMapper类增加内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询用户信息为map集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">selectMapById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将自己定义的方法在UserMapper.xml文件中进行实现，之后就可以用了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatisplus.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Map&lt;String, Object&gt; selectMapById(Long id);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMapById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age,email from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通用Service"><a href="#通用Service" class="headerlink" title="通用Service"></a>通用Service</h3><p>说明:</p><p>通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆，泛型 T 为任意实体对象</p><p>建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承</p><p>Mybatis-Plus 提供的基类</p><p>官网地址：<a href="https://baomidou.com/pages/49cc81/#service-crud-%E6%8E%A5%E5%8F%A3">https://baomidou.com/pages/49cc81/#service-crud-%E6%8E%A5%E5%8F%A3</a></p><p>MyBatis-Plus中有一个接口 IService和其实现类 ServiceImpl，封装了常见的业务层逻辑</p><p>详情查看源码IService和ServiceImpl</p><h4 id="创建Service接口和实现类"><a href="#创建Service接口和实现类" class="headerlink" title="创建Service接口和实现类"></a>创建Service接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* UserService继承IService模板提供的基础功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现接口的时候记得继承ServiceImpl，因为接口中有好多方法都没实现，所以要继承ServiceImpl，其中有所有实现好的方法</p><p>注解@Service用于将类标识为一个服务层的组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试通用Service"><a href="#测试通用Service" class="headerlink" title="测试通用Service"></a>测试通用Service</h3><h4 id="查询总记录数"><a href="#查询总记录数" class="headerlink" title="查询总记录数"></a>查询总记录数</h4><p>count()的实现在ServiceImpl中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//查询总记录数</span></span><br><span class="line">        <span class="comment">//SELECT COUNT( * ) FROM user</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数：&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量添加"><a href="#批量添加" class="headerlink" title="批量添加"></a>批量添加</h4><p>BaseMapper<T>接口只提供底层数据操作方式，所以IService<T>提供一些高级的业务操作</p><p>saveBatch()的实现在ServiceImpl中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertMore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//批量添加</span></span><br><span class="line">        <span class="comment">//INSERT INTO user ( id, name, age ) VALUES ( ?, ?, ? )</span></span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setName(<span class="string">&quot;ybc&quot;</span>+i);</span><br><span class="line">            user.setAge(<span class="number">20</span>+i);</span><br><span class="line">            list.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> userService.saveBatch(list);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BaseMapper-和IService-的关系和使用总结"><a href="#BaseMapper-和IService-的关系和使用总结" class="headerlink" title="BaseMapper\和IService\的关系和使用总结"></a>BaseMapper\<T>和IService\<T>的关系和使用总结</h3><p>使用方式不同</p><h4 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h4><p>写一个自己的接口继承BaseMapper并指定要进行操作的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解用于将接口标识为组件</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询用户信息为map集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">selectMapById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mapper（必须是这个目录）中写xml定义自己声明的方法selectMapById()</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230915190350792.png" alt="image-20230915190350792"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatisplus.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Map&lt;String, Object&gt; selectMapById(Long id);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMapById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age,email from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后就可以用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = userMapper.selectMapById(<span class="number">1L</span>);</span><br><span class="line">      System.out.println(map);</span><br></pre></td></tr></table></figure><h4 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h4><p>类ServiceImpl对BaseMapper接口根据IService接口进行了增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span>&lt;M <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;T&gt;, T&gt; <span class="keyword">implements</span> <span class="title class_">IService</span>&lt;T&gt; &#123;</span><br><span class="line">    ...这里实现了很多高级的业务方法，比BaseMapper中的功能更强大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义自己的接口继承IService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现自己定义的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以使用ServiceImpl中的高级业务方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//查询总记录数</span></span><br><span class="line">        <span class="comment">//SELECT COUNT( * ) FROM user</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数：&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AI总结"><a href="#AI总结" class="headerlink" title="AI总结"></a>AI总结</h4><p><code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 是 MyBatis-Plus 框架中的两个重要接口，它们通常用于协助开发者在Java应用中进行数据持久化操作。这两个接口的关系如下：</p><ol><li><p><strong><code>IService&lt;T&gt;</code> 接口</strong>：</p><ul><li><p><code>IService&lt;T&gt;</code> 是 MyBatis-Plus 框架提供的一个高级服务接口，用于定义数据访问服务的一些通用方法。通常情况下，<code>IService&lt;T&gt;</code> 的实现类用于封装业务逻辑，并提供对数据持久化的高级操作。</p></li><li><p><code>IService&lt;T&gt;</code> 接口提供了一系列用于数据操作的方法，例如插入、更新、删除、查询等。这些方法的参数和返回值通常都与实体类 <code>T</code> 相关，用于完成数据操作。</p></li><li><p>开发者可以根据具体的业务需求，自定义实现 <code>IService&lt;T&gt;</code> 接口的类，以提供特定业务逻辑的数据操作。</p></li></ul></li><li><p><strong><code>BaseMapper&lt;T&gt;</code> 接口</strong>：</p><ul><li><p><code>BaseMapper&lt;T&gt;</code> 是 MyBatis-Plus 框架提供的一个基础数据访问接口，用于定义通用的数据访问方法，这些方法包括插入、更新、删除、查询等。</p></li><li><p><code>BaseMapper&lt;T&gt;</code> 接口中的方法通常是直接与底层数据库操作相关的，例如增、删、改、查的方法。这些方法的参数和返回值也与实体类 <code>T</code> 相关。</p></li><li><p><code>BaseMapper&lt;T&gt;</code> 接口的实现类通常是由 MyBatis-Plus 自动生成的，这些实现类会根据实体类的定义自动生成 SQL 语句，从而实现了通用的数据访问操作。</p></li></ul></li><li><p><strong>关系</strong>：</p><ul><li><p><code>IService&lt;T&gt;</code> 接口和 <code>BaseMapper&lt;T&gt;</code> 接口通常一起使用。<code>IService&lt;T&gt;</code> 接口定义了一些高级的业务逻辑操作，而 <code>BaseMapper&lt;T&gt;</code> 接口提供了底层的数据操作方法。</p></li><li><p><code>IService&lt;T&gt;</code> 接口的实现类通常会调用 <code>BaseMapper&lt;T&gt;</code> 接口中的方法来完成数据持久化操作。这样，开发者可以在 <code>IService&lt;T&gt;</code> 的实现类中封装更高级的业务逻辑，而底层的数据操作则委托给 <code>BaseMapper&lt;T&gt;</code>。</p></li><li><p>通过结合使用 <code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code>，开发者可以更轻松地实现业务逻辑和数据访问的分离，提高代码的可维护性和可扩展性。</p></li></ul></li></ol><p>综上所述，<code>IService&lt;T&gt;</code> 和 <code>BaseMapper&lt;T&gt;</code> 是 MyBatis-Plus 框架中用于业务逻辑和数据持久化操作的两个关键接口，它们协同工作以实现数据操作和业务逻辑的分离和重用。这有助于简化代码，提高开发效率。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>操作的表名由实体类的名字决定，但是可以通过注解进行更改</p><h3 id="指定所有表的前缀"><a href="#指定所有表的前缀" class="headerlink" title="指定所有表的前缀"></a>指定所有表的前缀</h3><p>在配置文件中添加表名的前缀</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">table-prefix:</span> <span class="string">t_</span> </span><br></pre></td></tr></table></figure><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>更改实体类对应的表名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h3><p>MyBatis-Plus只能默认将id作为主键，如果改名为uid将不会自动赋值，需要使用注解特别声明</p><p>使用注解@TableId将把这个属性对应的字段作为主键，例如：数据库中主键叫uid，这里也叫uid，就可以使用@TableId将这个属性对应的字段标识为主键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将属性所对应的字段指定为主键</span></span><br><span class="line"><span class="meta">@TableId</span></span><br><span class="line"><span class="keyword">private</span> Long uid</span><br></pre></td></tr></table></figure><p>也可以在类中不进行更改，仍然使用id，但是 想对应数据库中的uid，就需要特别声明</p><p>(不特意设置属性，默认为value)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>除了上面这个指定以外还想要指定主键生成策略：</p><p>默认的生成策略：雪花算法</p><p>IdType.AUTO：自动递增，并不是雪花算法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@TableId注解的value属性用于指定主键的字段</span></span><br><span class="line"><span class="comment">//@TableId注解的type属性设置主键生成策略</span></span><br><span class="line"><span class="comment">//@TableId(value = &quot;uid&quot;, type = IdType.AUTO)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>常用生成策略</p><div class="table-container"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>IdType.ASSIGN_ID（默认）</td><td>基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td></tr><tr><td>IdType.AUTO</td><td>使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，</td></tr></tbody></table></div><p>也可以通过全局配置，配置所有实例的id的生成策略</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。</p><p>数据库的扩展方式主要包括：业务分库、主从复制，数据库分表。</p><h5 id="数据库分表"><a href="#数据库分表" class="headerlink" title="数据库分表"></a>数据库分表</h5><p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务</p><p>继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，</p><p>如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进</p><p>行拆分。</p><p>单表数据拆分有两种方式：垂直分表和水平分表。示意图如下：</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230916153953975.png" alt="image-20230916153953975"></p><h5 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h5><p>垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。</p><p>例如，前面示意图中的 nickname 和 description 字段，假设我们是一个婚恋网站，用户在筛选其他用</p><p>户的时候，主要是用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展</p><p>示，一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外</p><p>一张表中，这样在查询 age 和 sex 时，就能带来一定的性能提升。</p><h5 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h5><p>水平分表适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表，这个数字可以</p><p>作为参考，但并不是绝对标准，关键还是要看表的访问性能。对于一些比较复杂的表，可能超过 1000</p><p>万就要分表了；而对于一些简单的表，即使存储数据超过 1 亿行，也可以不分表。</p><p>但不管怎样，当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性</p><p>能瓶颈或者隐患。</p><p>水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处理</p><h6 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h6><p>①以最常见的用户 ID 为例，可以按照 1000000 的范围大小进行分段，1 ~ 999999 放到表 1中，</p><p>1000000 ~ 1999999 放到表2中，以此类推。</p><p>②复杂点：分段大小的选取。分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会</p><p>导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适</p><p>的分段大小。</p><p>③优点：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，</p><p>只需要增加新的表就可以了，原有的数据不需要动。</p><p>④缺点：分布不均匀。假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1 条，而</p><p>另外一个分段实际存储的数据量有 1000 万条。</p><h6 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h6><p>①同样以用户 ID 为例，假如我们一开始就规划了 10 个数据库表，可以简单地用 user_id % 10 的值来</p><p>表示数据所属的数据库表编号，ID 为 985 的用户放到编号为 5 的子表中，ID 为 10086 的用户放到编号</p><p>为 6 的子表中。</p><p>②复杂点：初始表数量的确定。表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。</p><p>③优点：表分布比较均匀。</p><p>④缺点：扩充新的表很麻烦，所有数据都要重分布。</p><h6 id="雪花算法-1"><a href="#雪花算法-1" class="headerlink" title="雪花算法"></a>雪花算法</h6><p>雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的</p><p>主键的有序性。</p><p>①核心思想：</p><p>长度共64bit（一个long型）。</p><p>首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负</p><p>数是1，所以id一般是正数，最高位是0。</p><p>41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。</p><p>10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。</p><p>12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230916154134835.png" alt="image-20230916154134835"></p><p>②优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。</p><h3 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//指定属性所对应的字段名</span></span><br><span class="line"><span class="meta">@TableField(&quot;user_name&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><h3 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a><strong>@TableLogic</strong></h3><p>使用这个注解时，注意表中要有这个列，isDeleted对应的表中列名是is_deleted（int）</p><p>0表示还存在     1表示被删除  【如果这个字段是null，那么等效于1】</p><p><strong>如果实例类中有这个注解和属性，在执行删除操作时，会将表中对应的字段的is_deleted改为0，而不是物理删除数据</strong></p><p><strong>并且查询的时候，会自动在where添加条件<code>is_deleted=0</code>，表示没有被逻辑删除的字段</strong></p><p><code>@TableLogic</code> 注解通常与实体类的字段一起使用，用于标记哪个字段表示逻辑删除状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer isDeleted;</span><br></pre></td></tr></table></figure><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</p><p>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库</p><p>中仍旧能看到此条数据记录</p><p>使用场景：可以进行数据恢复</p><h4 id="实现逻辑删除"><a href="#实现逻辑删除" class="headerlink" title="实现逻辑删除"></a>实现逻辑删除</h4><p><strong>step1**</strong>：**数据库中创建逻辑删除状态列，设置默认值为0</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230916165948632.png" alt="image-20230916165948632"></p><p><strong>step2**</strong>：**实体类中添加逻辑删除属性</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230916170003305.png" alt="image-20230916170003305"></p><p><strong>step3**</strong>：**测试</p><p>测试删除功能，真正执行的是修改</p><p>UPDATE t_user SET is_deleted=1 WHERE id=? AND is_deleted=0</p><p>测试查询功能，被逻辑删除的数据默认不会被查询</p><p>SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0</p><h2 id="条件构造器和常用接口"><a href="#条件构造器和常用接口" class="headerlink" title="条件构造器和常用接口"></a>条件构造器和常用接口</h2><h3 id="wapper介绍"><a href="#wapper介绍" class="headerlink" title="wapper介绍"></a>wapper介绍</h3><p>(wapper==包装器（条件构造器）)</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230916171406754.png" alt="image-20230916171406754"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Wrapper</span> ： 条件构造抽象类，最顶端父类</span><br><span class="line">    AbstractWrapper ： 用于查询条件封装，生成 <span class="keyword">sql</span> 的 <span class="keyword">where</span> 条件</span><br><span class="line">    QueryWrapper ： 查询条件封装</span><br><span class="line">    UpdateWrapper ： <span class="keyword">Update</span> 条件封装</span><br><span class="line">    AbstractLambdaWrapper ： 使用Lambda 语法</span><br><span class="line">        LambdaQueryWrapper ：用于Lambda语法使用的查询<span class="keyword">Wrapper</span></span><br><span class="line">        LambdaUpdateWrapper ： Lambda 更新封装<span class="keyword">Wrapper</span></span><br></pre></td></tr></table></figure><details class="folding-tag" yellow><summary> 查看AbstractWrapper抽象类结构 </summary>              <div class='content'>              <p><img src="../assets/image/MyBatis-Plus_Image/AbstractWrapper.png" alt="AbstractWrapper"></p>              </div>            </details><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a><strong>QueryWrapper</strong></h3><h4 id="组件查询条件"><a href="#组件查询条件" class="headerlink" title="组件查询条件"></a>组件查询条件</h4><p>在条件构造器中，构造条件,然后查询时使用这个包装器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户名包含a，年龄在20到30之间，邮箱信息不为null的用户信息</span></span><br><span class="line">    <span class="comment">//SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (user_name LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">        .between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">        .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: <span class="keyword">SELECT</span> id,<span class="type">name</span>,age,email,is_deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> is_deleted=<span class="number">0</span> <span class="keyword">AND</span> (<span class="type">name</span> <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> age <span class="keyword">BETWEEN</span> ? <span class="keyword">AND</span> ? <span class="keyword">AND</span> email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line">==&gt; Parameters: %Jack%(String), <span class="number">20</span>(<span class="type">Integer</span>), <span class="number">30</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    <span class="keyword">Columns</span>: id, <span class="type">name</span>, age, email, is_deleted</span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">2</span>, Jack, <span class="number">20</span>, test2@baomidou.com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="组装排序条件"><a href="#组装排序条件" class="headerlink" title="组装排序条件"></a>组装排序条件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户信息，按照年龄的降序排序，若年龄相同，则按照id升序排序</span></span><br><span class="line">    <span class="comment">//SELECT uid AS id,user_name AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,uid ASC</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">        .orderByAsc(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> id,name,age,email,is_deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> is_deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>,id <span class="keyword">ASC</span></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: </span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>    Columns: id, name, age, email, is_deleted</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">2</span>, Jack, <span class="number">20</span>, test2<span class="variable">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>      Total: <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="条件的优先级"><a href="#条件的优先级" class="headerlink" title="条件的优先级"></a>条件的优先级</h4><p>这里前两个条件之间是<code>并且</code>，可以翻译为and，又因为在两个条件之间会默认加and，所以不会刻意声明，但是<code>或</code>需要刻意声明</p><p>update（）中需要两个参数，要将根据右边的包装器查到的数据改为左边的实例类的对象的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将（年龄大于20并且用户名中包含有Tom）或邮箱为null的用户信息修改</span></span><br><span class="line">    <span class="comment">//UPDATE t_user SET user_name=?, email=? WHERE is_deleted=0 AND (age &gt; ? AND user_name LIKE ? OR email IS NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">        .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">        .or()</span><br><span class="line">        .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: <span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name=?, email=? <span class="keyword">WHERE</span> is_deleted=<span class="number">0</span> <span class="keyword">AND</span> (age &gt; ? <span class="keyword">AND</span> name <span class="keyword">LIKE</span> ? <span class="keyword">OR</span> email <span class="keyword">IS</span> <span class="literal">NULL</span>)</span><br><span class="line">==&gt; Parameters: 小明(<span class="keyword">String</span>), test@atguigu.com(<span class="keyword">String</span>), <span class="number">20</span>(Integer), %Tom%(<span class="keyword">String</span>)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里的and需要特殊声明是因为，第一个条件是一体，后两个条件是一体</p><p>当使用了<code>and()</code>或者<code>or()</code>方法的时候如果条件中有lambda表达式，那么lambda表达式优先执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有o并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    <span class="comment">//lambda中的条件优先执行</span></span><br><span class="line">    <span class="comment">//UPDATE t_user SET user_name=?, email=? WHERE is_deleted=0 AND (user_name LIKE ? AND (age &gt; ? OR email IS NULL))</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">        .and(i-&gt;i.gt(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>).or().isNotNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;test@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sql语句中也可以看到，and两边加了<code>()</code>的一边会先执行</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: <span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name=?, email=? <span class="keyword">WHERE</span> is_deleted=<span class="number">0</span> <span class="keyword">AND</span> (name <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> (age &gt; ? <span class="keyword">OR</span> email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>))</span><br><span class="line">==&gt; Parameters: 小红(<span class="keyword">String</span>), test@atguigu.com(<span class="keyword">String</span>), %o%(<span class="keyword">String</span>), <span class="number">20</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="组装select子句"><a href="#组装select子句" class="headerlink" title="组装select子句"></a>组装select子句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询用户的用户名、年龄、邮箱信息</span></span><br><span class="line">    <span class="comment">//SELECT name,age,email FROM t_user WHERE is_deleted=0</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="comment">//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> name,age,email <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> is_deleted<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: </span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>    Columns: name, age, email</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: 小红, <span class="number">18</span>, test<span class="variable">@atguigu</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: Jack, <span class="number">20</span>, test2<span class="variable">@baomidou</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: 小明, <span class="number">28</span>, test<span class="variable">@atguigu</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: 李四, <span class="number">21</span>, lisi<span class="variable">@atguigu</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: Billie, <span class="number">24</span>, test5<span class="variable">@baomidou</span>.com</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>      Total: <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="实现子查询"><a href="#实现子查询" class="headerlink" title="实现子查询"></a>实现子查询</h4><p><code>queryWrapper.inSql(&quot;id&quot;, &quot;select id from user where id &lt;= 100&quot;);</code></p><p>意思是：id要在后面查到的结果集中存在==<code>id IN (select id from user where id &lt;= 100)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询id小于等于100的用户信息</span></span><br><span class="line">    <span class="comment">//SELECT id,user_name AS name,age,email,is_deleted FROM user WHERE is_deleted=0 AND (id IN (select id from user where id &lt;= 100))</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt;= 100&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,age,email,is_deleted FROM user WHERE is_deleted=<span class="number">0</span> AND (id <span class="title function_">IN</span> <span class="params">(select id from user where id &lt;= <span class="number">100</span>)</span>)</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, name, age, email, is_deleted</span><br><span class="line">&lt;==        Row: <span class="number">1</span>, 小红, <span class="number">18</span>, test<span class="meta">@atguigu</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">2</span>, Jack, <span class="number">20</span>, test2<span class="meta">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">3</span>, 小明, <span class="number">28</span>, test<span class="meta">@atguigu</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">4</span>, 李四, <span class="number">21</span>, lisi<span class="meta">@atguigu</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">5</span>, Billie, <span class="number">24</span>, test5<span class="meta">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a><strong>UpdateWrapper</strong></h3><p>使用<code>UpdateWrapper</code>进行update操作时，需要将修改的数据写到一个实例类的对象中</p><p>但在<code>UpdateWrapper</code>中可以直接使用<code>set()</code>设置想要修改的数据</p><p>这里的<code>update()</code>的第一个参数是null，也是因为上面这个原因，之前这个参数是实例类的对象，但是这里用<code>set()</code>已经设置过了，所以不需要实例类对象了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).or().isNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    updateWrapper.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小黑&quot;</span>).set(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: <span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name=?,email=? <span class="keyword">WHERE</span> is_deleted=<span class="number">0</span> <span class="keyword">AND</span> (name <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> (age &gt; ? <span class="keyword">OR</span> email <span class="keyword">IS</span> <span class="literal">NULL</span>))</span><br><span class="line">==&gt; Parameters: 小黑(<span class="keyword">String</span>), abc@atguigu.com(<span class="keyword">String</span>), %a%(<span class="keyword">String</span>), <span class="number">20</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a><strong>condition</strong></h3><p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//SELECT id,name,age,email,is_deleted FROM user WHERE is_deleted=0 AND (name LIKE ? AND age &gt;= ? AND age &lt;= ?)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//这样判断字符串是否为空更好</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(username))&#123;</span><br><span class="line">        <span class="comment">//isNotBlank判断某个字符创是否不为空字符串、不为null、不为空白符</span></span><br><span class="line">        queryWrapper.like(<span class="string">&quot;name&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageBegin != <span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.ge(<span class="string">&quot;age&quot;</span>, ageBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ageEnd != <span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.le(<span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: <span class="keyword">SELECT</span> id,<span class="type">name</span>,age,email,is_deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> is_deleted=<span class="number">0</span> <span class="keyword">AND</span> (<span class="type">name</span> <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> age &gt;= ? <span class="keyword">AND</span> age &lt;= ?)</span><br><span class="line">==&gt; Parameters: %a%(String), <span class="number">20</span>(<span class="type">Integer</span>), <span class="number">30</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    <span class="keyword">Columns</span>: id, <span class="type">name</span>, age, email, is_deleted</span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">2</span>, Jack, <span class="number">21</span>, abc@atguigu.com, <span class="number">0</span></span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">4</span>, Alita, <span class="number">21</span>, lisi@atguigu.com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>上面这种写法比较麻烦，<code>AbstractWrapper</code>的一些方法具有很好的重载，这些重载方法的第一个参数是布尔类型，只有布尔类型为true时才会把后面的条件组装进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username), <span class="string">&quot;name&quot;</span>, username)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>ageBegin</code>是<code>null</code>所以不进行组装</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: <span class="keyword">SELECT</span> id,<span class="type">name</span>,age,email,is_deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> is_deleted=<span class="number">0</span> <span class="keyword">AND</span> (<span class="type">name</span> <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> age &lt;= ?)</span><br><span class="line">==&gt; Parameters: %a%(String), <span class="number">30</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    <span class="keyword">Columns</span>: id, <span class="type">name</span>, age, email, is_deleted</span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">2</span>, Jack, <span class="number">21</span>, abc@atguigu.com, <span class="number">0</span></span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">4</span>, Alita, <span class="number">21</span>, lisi@atguigu.com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a><strong>LambdaQueryWrapper</strong></h3><p>这里的<code>User::getName</code>代表User实例类中Name属性对应的字段，上面的代码演示中是直接写字段名，不方便进行修改如果这样写，当数据库表中的列改名时，只需要在实例类的对应的属性上改注解参数就行，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//这个注解用于改主键的别名</span></span><br><span class="line"><span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//指定属性所对应的字段名</span></span><br><span class="line">   <span class="meta">@TableField(&quot;user_name&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><p>如果符合<code>StringUtils.isNotBlank(username)</code>条件，就组装到sql中：<code>username</code>like<code>User::getName</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageBegin</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">ageEnd</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username)</span><br><span class="line">        .ge(ageBegin != <span class="literal">null</span>, User::getAge, ageBegin)</span><br><span class="line">        .le(ageEnd != <span class="literal">null</span>, User::getAge, ageEnd);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: <span class="keyword">SELECT</span> id,<span class="type">name</span>,age,email,is_deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> is_deleted=<span class="number">0</span> <span class="keyword">AND</span> (<span class="type">name</span> <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> age &lt;= ?)</span><br><span class="line">==&gt; Parameters: %a%(String), <span class="number">30</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    <span class="keyword">Columns</span>: id, <span class="type">name</span>, age, email, is_deleted</span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">2</span>, Jack, <span class="number">21</span>, abc@atguigu.com, <span class="number">0</span></span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">4</span>, Alita, <span class="number">21</span>, lisi@atguigu.com, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="LambdaUpdateWrapper"><a href="#LambdaUpdateWrapper" class="headerlink" title="LambdaUpdateWrapper"></a><strong>LambdaUpdateWrapper</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .and(i -&gt; i.gt(User::getAge, <span class="number">20</span>).or().isNull(User::getEmail));</span><br><span class="line">    updateWrapper.set(User::getName, <span class="string">&quot;小黑&quot;</span>).set(User::getEmail,<span class="string">&quot;abc@atguigu.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;result：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==&gt;  Preparing: <span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name=?,email=? <span class="keyword">WHERE</span> is_deleted=<span class="number">0</span> <span class="keyword">AND</span> (name <span class="keyword">LIKE</span> ? <span class="keyword">AND</span> (age &gt; ? <span class="keyword">OR</span> email <span class="keyword">IS</span> <span class="literal">NULL</span>))</span><br><span class="line">==&gt; Parameters: 小黑(<span class="keyword">String</span>), abc@atguigu.com(<span class="keyword">String</span>), %a%(<span class="keyword">String</span>), <span class="number">20</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p><h4 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h4><p>(Interceptor==拦截器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描mapper接口所在的包</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">//添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>参数中写的是第二页，但是在转换为SQL语句时会变为3，因为SQL语句中要的是索引（从0开始）（自动转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//显示第二页，每页最多3条数据</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> is_deleted <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: </span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>    Columns: total</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">5</span></span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>      Total: <span class="number">1</span></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>  Preparing: <span class="keyword">SELECT</span> id,name,age,email,is_deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> is_deleted<span class="operator">=</span><span class="number">0</span> LIMIT ?,?</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> Parameters: <span class="number">3</span>(Long), <span class="number">3</span>(Long)</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>    Columns: id, name, age, email, is_deleted</span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">4</span>, 小黑, <span class="number">21</span>, abc<span class="variable">@atguigu</span>.com, <span class="number">0</span></span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>        <span class="type">Row</span>: <span class="number">5</span>, Billie, <span class="number">24</span>, test5<span class="variable">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span>      Total: <span class="number">2</span></span><br></pre></td></tr></table></figure><details class="folding-tag" yellow><summary> 查看Page类、IPage接口之间的关系 </summary>              <div class='content'>              <p><img src="../assets/image/MyBatis-Plus_Image/Page-16949520639831.png" alt="Page"></p>              </div>            </details><details class="folding-tag" yellow><summary> 查看Page类结构 </summary>              <div class='content'>              <p><img src="../assets/image/MyBatis-Plus_Image/Page.png" alt="Page"></p>              </div>            </details><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//获取所在页的所有数据，返回的是List&lt;user&gt;</span></span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">    <span class="comment">//获取总页数</span></span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    <span class="comment">//获取总记录数</span></span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    <span class="comment">//获取有没有下一页</span></span><br><span class="line">    System.out.println(page.hasNext());</span><br><span class="line">    <span class="comment">//判断是否有上一页</span></span><br><span class="line">    System.out.println(page.hasPrevious());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[User(<span class="attribute">id</span>=4, <span class="attribute">name</span>=小黑, <span class="attribute">age</span>=21, <span class="attribute">email</span>=abc@atguigu.com, <span class="attribute">isDeleted</span>=0), User(<span class="attribute">id</span>=5, <span class="attribute">name</span>=Billie, <span class="attribute">age</span>=24, <span class="attribute">email</span>=test5@baomidou.com, <span class="attribute">isDeleted</span>=0)]</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="xml自定义分页"><a href="#xml自定义分页" class="headerlink" title="xml自定义分页"></a>xml自定义分页</h4><p>自定义分页方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过年龄查询用户信息并分页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page MyBatis-Plus所提供的分页对象，必须位于第一个参数的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Page&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SQL片段，记录基础字段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;BaseColumns&quot;</span>&gt;</span>id,username,age,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Page&lt;User&gt; selectPageVo(@Param(&quot;page&quot;) Page&lt;User&gt; page, @Param(&quot;age&quot;) Integer age);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select uid,user_name,age,email from user where age &gt; #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mybatis-plus</span><span class="punctuation">:</span></span><br><span class="line"><span class="comment"># 配置类型别名所对应的包</span></span><br><span class="line">  <span class="attribute">type-aliases-package</span><span class="punctuation">:</span> <span class="string">com.atguigu.mybatisplus.pojo</span></span><br></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小</p><p>李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太</p><p>高，可能会影响销量。又通知小王，你把商品价格降低30元。</p><p>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王</p><p>也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50=150元存入了数据</p><p>库；小王将商品减了30元，并将100-30=70元存入了数据库。是的，如果没有锁，小李的操作就</p><p>完全被小王的覆盖了。</p><p>现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1</p><p>万多。</p><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p>上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过</p><p>了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。</p><p>如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证</p><p>最终的价格是120元。</p><h4 id="模拟修改冲突"><a href="#模拟修改冲突" class="headerlink" title="模拟修改冲突"></a>模拟修改冲突</h4><h5 id="数据库中增加商品表"><a href="#数据库中增加商品表" class="headerlink" title="数据库中增加商品表"></a>数据库中增加商品表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_product</span><br><span class="line">(</span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">    VERSION <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_product (id, <span class="type">NAME</span>, price) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;外星人笔记本&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h5 id="添加实体-1"><a href="#添加实体-1" class="headerlink" title="添加实体"></a>添加实体</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatisplus.entity;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加mapper"><a href="#添加mapper" class="headerlink" title="添加mapper"></a>添加mapper</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里可能报错，但是可以正常运行，报错是因为IDEA找不到ProductMapper的Bean，在接口ProductMapper上使用注解@Repository把接口@Repository标识为持久层组件即可不报错</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConcurrentUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1、小李</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p1</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李取出的价格：&quot;</span> + p1.getPrice());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、小王</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p2</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王取出的价格：&quot;</span> + p2.getPrice());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//3、小李将价格加了50元，存入了数据库</span></span><br><span class="line">    p1.setPrice(p1.getPrice() + <span class="number">50</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> productMapper.updateById(p1);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李修改结果：&quot;</span> + result1);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4、小王将商品减了30元，存入了数据库</span></span><br><span class="line">    p2.setPrice(p2.getPrice() - <span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> productMapper.updateById(p2);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王修改结果：&quot;</span> + result2);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后的结果</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p3</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//价格覆盖，最后的结果：70</span></span><br><span class="line">    System.out.println(<span class="string">&quot;最后的结果：&quot;</span> + p3.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乐观锁实现流程"><a href="#乐观锁实现流程" class="headerlink" title="乐观锁实现流程"></a>乐观锁实现流程</h4><p>数据库中添加version字段</p><p>取出记录时，获取当前version</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,`name`,price,`version` <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>更新时，version + 1，如果where语句中的version版本不对，则更新失败</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> product <span class="keyword">SET</span> price<span class="operator">=</span>price<span class="operator">+</span><span class="number">50</span>, `version`<span class="operator">=</span>`version` <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span>`version`<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="Mybatis-Plus-实现乐观锁"><a href="#Mybatis-Plus-实现乐观锁" class="headerlink" title="Mybatis-Plus**实现乐观锁**"></a><strong>Mybatis-Plus**</strong>实现乐观锁**</h4><h5 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a><strong>修改实体类</strong></h5><p>price是这个员工取出的价格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatisplus.entity;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.Version;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加乐观锁插件配置"><a href="#添加乐观锁插件配置" class="headerlink" title="添加乐观锁插件配置"></a><strong>添加乐观锁插件配置</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描mapper接口所在的包</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span></span><br><span class="line">        <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">//添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试修改冲突"><a href="#测试修改冲突" class="headerlink" title="测试修改冲突"></a><strong>测试修改冲突</strong></h5><p>小李查询商品信息：</p><p>SELECT id,name,price,version FROM t_product WHERE id=?</p><p>小王查询商品信息：</p><p>SELECT id,name,price,version FROM t_product WHERE id=?</p><p>小李修改商品价格，自动将version+1</p><p>UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</p><p>Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>小王修改商品价格，此时version已更新，条件不成立，修改失败</p><p>UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</p><p>Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer)</p><p>最终，小王修改失败，查询价格：150</p><p>SELECT id,name,price,version FROM t_product WHERE id=?</p><h5 id="优化流程"><a href="#优化流程" class="headerlink" title="优化流程"></a><strong>优化流程</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConcurrentVersionUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//小李取数据</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p1</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//小王取数据</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p2</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//小李修改 + 50</span></span><br><span class="line">    p1.setPrice(p1.getPrice() + <span class="number">50</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> productMapper.updateById(p1);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李修改的结果：&quot;</span> + result1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//小王修改 - 30</span></span><br><span class="line">    p2.setPrice(p2.getPrice() - <span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> productMapper.updateById(p2);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王修改的结果：&quot;</span> + result2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result2 == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//失败重试，重新获取version并更新</span></span><br><span class="line">    p2 = productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        p2.setPrice(p2.getPrice() - <span class="number">30</span>);</span><br><span class="line">    result2 = productMapper.updateById(p2);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;小王修改重试的结果：&quot;</span> + result2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//老板看价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p3</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板看价格：&quot;</span> + p3.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">JDBC <span class="keyword">Connection</span> [HikariProxyConnection@<span class="number">850429804</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@<span class="number">2</span>aaf152b] will <span class="keyword">not</span> be managed <span class="keyword">by</span> Spring</span><br><span class="line"></span><br><span class="line">【小李取数据】</span><br><span class="line">==&gt;  Preparing: <span class="keyword">SELECT</span> id,<span class="type">name</span>,price,<span class="keyword">version</span> <span class="keyword">FROM</span> t_product <span class="keyword">WHERE</span> id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    <span class="keyword">Columns</span>: id, <span class="type">name</span>, price, <span class="keyword">version</span></span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">1</span>, 外星人笔记本, <span class="number">100</span>, <span class="number">1</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">282</span>ffbf5]</span><br><span class="line">小李查询的商品价格：<span class="number">100</span></span><br><span class="line"></span><br><span class="line">【小王取数据】</span><br><span class="line">Creating a <span class="built_in">new</span> SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">47406941</span>] was <span class="keyword">not</span> registered <span class="keyword">for</span> synchronization because synchronization <span class="keyword">is</span> <span class="keyword">not</span> active</span><br><span class="line">JDBC <span class="keyword">Connection</span> [HikariProxyConnection@<span class="number">1642905321</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@<span class="number">2</span>aaf152b] will <span class="keyword">not</span> be managed <span class="keyword">by</span> Spring</span><br><span class="line">==&gt;  Preparing: <span class="keyword">SELECT</span> id,<span class="type">name</span>,price,<span class="keyword">version</span> <span class="keyword">FROM</span> t_product <span class="keyword">WHERE</span> id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    <span class="keyword">Columns</span>: id, <span class="type">name</span>, price, <span class="keyword">version</span></span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">1</span>, 外星人笔记本, <span class="number">100</span>, <span class="number">1</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">47406941</span>]</span><br><span class="line">小王查询的商品价格：<span class="number">100</span></span><br><span class="line"></span><br><span class="line">【小李修改数据并写入（成功）】</span><br><span class="line">Creating a <span class="built_in">new</span> SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">2440022</span>a] was <span class="keyword">not</span> registered <span class="keyword">for</span> synchronization because synchronization <span class="keyword">is</span> <span class="keyword">not</span> active</span><br><span class="line">JDBC <span class="keyword">Connection</span> [HikariProxyConnection@<span class="number">1399691256</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@<span class="number">2</span>aaf152b] will <span class="keyword">not</span> be managed <span class="keyword">by</span> Spring</span><br><span class="line">==&gt;  Preparing: <span class="keyword">UPDATE</span> t_product <span class="keyword">SET</span> <span class="type">name</span>=?, price=?, version=? <span class="keyword">WHERE</span> id=? <span class="keyword">AND</span> version=?</span><br><span class="line">==&gt; Parameters: 外星人笔记本(String), <span class="number">150</span>(<span class="type">Integer</span>), <span class="number">2</span>(<span class="type">Integer</span>), <span class="number">1</span>(Long), <span class="number">1</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">2440022</span>a]</span><br><span class="line"></span><br><span class="line">【小王修改并写入（失败）因为版本号对不上】</span><br><span class="line">【因为写入的时候和自己当时查的版本号对不上，所以在自己修改数据的时候有人更改了数据】</span><br><span class="line">Creating a <span class="built_in">new</span> SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">123</span>d7057] was <span class="keyword">not</span> registered <span class="keyword">for</span> synchronization because synchronization <span class="keyword">is</span> <span class="keyword">not</span> active</span><br><span class="line">JDBC <span class="keyword">Connection</span> [HikariProxyConnection@<span class="number">488928549</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@<span class="number">2</span>aaf152b] will <span class="keyword">not</span> be managed <span class="keyword">by</span> Spring</span><br><span class="line">==&gt;  Preparing: <span class="keyword">UPDATE</span> t_product <span class="keyword">SET</span> <span class="type">name</span>=?, price=?, version=? <span class="keyword">WHERE</span> id=? <span class="keyword">AND</span> version=?</span><br><span class="line">==&gt; Parameters: 外星人笔记本(String), <span class="number">70</span>(<span class="type">Integer</span>), <span class="number">2</span>(<span class="type">Integer</span>), <span class="number">1</span>(Long), <span class="number">1</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    Updates: <span class="number">0</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">123</span>d7057]</span><br><span class="line"></span><br><span class="line">【小王重新查数据】</span><br><span class="line">Creating a <span class="built_in">new</span> SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">32e652</span>b6] was <span class="keyword">not</span> registered <span class="keyword">for</span> synchronization because synchronization <span class="keyword">is</span> <span class="keyword">not</span> active</span><br><span class="line">JDBC <span class="keyword">Connection</span> [HikariProxyConnection@<span class="number">1268786037</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@<span class="number">2</span>aaf152b] will <span class="keyword">not</span> be managed <span class="keyword">by</span> Spring</span><br><span class="line">==&gt;  Preparing: <span class="keyword">SELECT</span> id,<span class="type">name</span>,price,<span class="keyword">version</span> <span class="keyword">FROM</span> t_product <span class="keyword">WHERE</span> id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    <span class="keyword">Columns</span>: id, <span class="type">name</span>, price, <span class="keyword">version</span></span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">1</span>, 外星人笔记本, <span class="number">150</span>, <span class="number">2</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">32e652</span>b6]</span><br><span class="line"></span><br><span class="line">【小王修改数据并写入（成功）】</span><br><span class="line">Creating a <span class="built_in">new</span> SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">3289079</span>a] was <span class="keyword">not</span> registered <span class="keyword">for</span> synchronization because synchronization <span class="keyword">is</span> <span class="keyword">not</span> active</span><br><span class="line">JDBC <span class="keyword">Connection</span> [HikariProxyConnection@<span class="number">855277727</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@<span class="number">2</span>aaf152b] will <span class="keyword">not</span> be managed <span class="keyword">by</span> Spring</span><br><span class="line">==&gt;  Preparing: <span class="keyword">UPDATE</span> t_product <span class="keyword">SET</span> <span class="type">name</span>=?, price=?, version=? <span class="keyword">WHERE</span> id=? <span class="keyword">AND</span> version=?</span><br><span class="line">==&gt; Parameters: 外星人笔记本(String), <span class="number">120</span>(<span class="type">Integer</span>), <span class="number">3</span>(<span class="type">Integer</span>), <span class="number">1</span>(Long), <span class="number">2</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">3289079</span>a]</span><br><span class="line"></span><br><span class="line">【老板查询数据（和想象一样）】</span><br><span class="line">Creating a <span class="built_in">new</span> SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">12</span>a14b74] was <span class="keyword">not</span> registered <span class="keyword">for</span> synchronization because synchronization <span class="keyword">is</span> <span class="keyword">not</span> active</span><br><span class="line">JDBC <span class="keyword">Connection</span> [HikariProxyConnection@<span class="number">1760443245</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@<span class="number">2</span>aaf152b] will <span class="keyword">not</span> be managed <span class="keyword">by</span> Spring</span><br><span class="line">==&gt;  Preparing: <span class="keyword">SELECT</span> id,<span class="type">name</span>,price,<span class="keyword">version</span> <span class="keyword">FROM</span> t_product <span class="keyword">WHERE</span> id=?</span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(<span class="type">Integer</span>)</span><br><span class="line">&lt;==    <span class="keyword">Columns</span>: id, <span class="type">name</span>, price, <span class="keyword">version</span></span><br><span class="line">&lt;==        <span class="keyword">Row</span>: <span class="number">1</span>, 外星人笔记本, <span class="number">120</span>, <span class="number">3</span></span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.<span class="keyword">session</span>.defaults.DefaultSqlSession@<span class="number">12</span>a14b74]</span><br><span class="line">老板查询的商品价格：<span class="number">120</span></span><br></pre></td></tr></table></figure><h2 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h2><p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现</p><h3 id="数据库表添加字段sex"><a href="#数据库表添加字段sex" class="headerlink" title="数据库表添加字段sex"></a><strong>数据库表添加字段</strong>sex</h3><p><img src="../assets/image/MyBatis-Plus_Image/image-20230919100412431.png" alt="image-20230919100412431"></p><h3 id="创建通用枚举类型"><a href="#创建通用枚举类型" class="headerlink" title="创建通用枚举类型"></a><strong>创建通用枚举类型</strong></h3><p>因为枚举中全是常量，所以只用@Getter就可以了</p><p>这里两个属性，第一个必须叫sex，要和数据库表中列名一样，第二个可以改名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatisplus.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Date:2022/2/15</span></span><br><span class="line"><span class="comment"> * Author:ybc</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MALE(<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">    FEMALE(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span> <span class="comment">//将注解所标识的属性的值存储到数据库中</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line"></span><br><span class="line">    SexEnum(Integer sex, String sexName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例类也要增加SexEnum属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatisplus.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.mybatisplus.enums.SexEnum;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.*;</span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Date:2022/2/12</span></span><br><span class="line"><span class="comment"> * Author:ybc</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//设置实体类所对应的表名</span></span><br><span class="line"><span class="comment">//@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将属性所对应的字段指定为主键</span></span><br><span class="line">    <span class="comment">//@TableId注解的value属性用于指定主键的字段</span></span><br><span class="line">    <span class="comment">//@TableId注解的type属性设置主键生成策略</span></span><br><span class="line">    <span class="comment">//@TableId(value = &quot;uid&quot;, type = IdType.AUTO)</span></span><br><span class="line"><span class="comment">//    @TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定属性所对应的字段名</span></span><br><span class="line"><span class="comment">//    @TableField(&quot;user_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SexEnum sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDeleted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置扫描通用枚举"><a href="#配置扫描通用枚举" class="headerlink" title="配置扫描通用枚举"></a><strong>配置扫描通用枚举</strong></h3><p>不加这个包就会导致错误：Incorrect integer value:’MALE’ for column ‘sex’ at row 1</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"> <span class="attr">type-enums-package:</span> <span class="string">com.atguigu.mybatisplus.enums</span></span><br></pre></td></tr></table></figure><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a><strong>测试</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusEnumTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">33</span>);</span><br><span class="line">        user.setSex(SexEnum.MALE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a><strong>代码生成器</strong></h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a><strong>引入依赖</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="快速生成"><a href="#快速生成" class="headerlink" title="快速生成"></a><strong>快速生成</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastAutoGeneratorTest</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FastAutoGenerator.create(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis_plus?characterEncoding=utf-8&amp;userSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                .globalConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.author(<span class="string">&quot;atguigu&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                            <span class="comment">//.enableSwagger() // 开启 swagger 模式</span></span><br><span class="line">                            .fileOverride() <span class="comment">// 覆盖已生成文件</span></span><br><span class="line">                            .outputDir(<span class="string">&quot;D://mybatis_plus&quot;</span>); <span class="comment">// 指定输出目录</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .packageConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.parent(<span class="string">&quot;com.atguigu&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                            .moduleName(<span class="string">&quot;mybatisplus&quot;</span>) <span class="comment">// 设置父包模块名</span></span><br><span class="line">                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, <span class="string">&quot;D://mybatis_plus&quot;</span>)); <span class="comment">// 设置mapperXml生成路径</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.addInclude(<span class="string">&quot;t_user&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">                            .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;c_&quot;</span>); <span class="comment">// 设置过滤表前缀</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .templateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>()) <span class="comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据user表可以生成以下内容</p><p><img src="../assets/image/MyBatis-Plus_Image/image-20230919114349036.png" alt="image-20230919114349036"></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>SpringBoot版本</p> <div class="row">    <embed src="https://blog.tianao.top/assets/files/MyBatisPlus(SpringBoot).pdf" width="100%" height="550" type="application/pdf"></div><p>Spring版本</p> <div class="row">    <embed src="https://blog.tianao.top/assets/files/MyBatisPlus(Spring).pdf" width="100%" height="550" type="application/pdf"></div><h1 id="AI总结-1"><a href="#AI总结-1" class="headerlink" title="AI总结"></a>AI总结</h1><p>MyBatis-Plus 是 MyBatis 的一个增强工具包，它简化了在 Java 应用中使用 MyBatis 进行数据库访问的开发工作。MyBatis-Plus 提供了一些方便的功能和特性，使开发人员更轻松地与数据库交互，减少了编写样板代码的工作。以下是 MyBatis-Plus 的主要特点和功能：</p><ol><li><p><strong>基于 MyBatis</strong>：MyBatis-Plus 是 MyBatis 的扩展，它充分利用了 MyBatis 的核心功能，因此与 MyBatis 高度兼容，可以与现有的 MyBatis 项目集成。</p></li><li><p><strong>代码生成器</strong>：MyBatis-Plus 提供了一个代码生成器，可以根据数据库表结构自动生成实体类、Mapper 接口和XML映射文件，减少了手动编写这些文件的工作量。这个功能在快速开发原型或新项目时特别有用。</p></li><li><p><strong>强大的查询构建器</strong>：MyBatis-Plus 提供了一个强大的查询构建器，允许开发人员以面向对象的方式构建数据库查询，而不必编写复杂的 SQL。这使得构建复杂查询变得更加容易。</p></li><li><p><strong>通用 CRUD 操作</strong>：MyBatis-Plus 提供了通用的 CRUD（增删改查）操作方法，无需编写SQL语句，您可以轻松地执行数据库操作，包括插入、更新、删除和查询。</p></li><li><p><strong>分页查询支持</strong>：MyBatis-Plus 内置了分页查询的支持，可以方便地进行分页查询操作。</p></li><li><p><strong>条件构造器</strong>：MyBatis-Plus 提供了条件构造器，允许您以一种更加直观的方式构建复杂的查询条件，避免手动拼接 SQL 语句。</p></li><li><p><strong>逻辑删除</strong>：MyBatis-Plus 支持逻辑删除，可以通过标记删除标志而不是物理删除来删除记录，从而保留数据的完整性。</p></li><li><p><strong>自动填充</strong>：MyBatis-Plus 允许您在插入或更新记录时自动填充某些字段，例如创建时间或修改时间字段，减少了手动设置这些字段的工作。</p></li><li><p><strong>乐观锁支持</strong>：MyBatis-Plus 支持乐观锁，用于处理并发更新操作，以避免数据冲突。</p></li><li><p><strong>多数据源支持</strong>：MyBatis-Plus 提供了对多数据源的支持，可以在一个应用程序中轻松管理多个数据库连接。</p></li></ol><p>总之，MyBatis-Plus 是一个强大的数据库访问工具，它简化了与数据库的交互，减少了开发工作量，并提供了许多有用的功能和特性。它广泛用于 Java 项目中，特别是基于 MyBatis 的数据库访问层的开发。如果您正在开发一个使用 MyBatis 的 Java 应用程序，MyBatis-Plus 可能是一个有价值的工具包，可以提高开发效率并改善代码质量。 </p>]]></content>
    
    
    <summary type="html">🍔本文汇总MyBatis-Plus的使用和基础知识</summary>
    
    
    
    <category term="框架" scheme="https://momoao.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="MyBatis" scheme="https://momoao.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>三级网络技术</title>
    <link href="https://momoao.github.io/posts/202309121527.html"/>
    <id>https://momoao.github.io/posts/202309121527.html</id>
    <published>2023-09-11T07:30:03.000Z</published>
    <updated>2023-09-24T06:35:29.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机三级网络技术"><a href="#计算机三级网络技术" class="headerlink" title="计算机三级网络技术"></a>计算机三级网络技术</h1><h1 id="得分结构"><a href="#得分结构" class="headerlink" title="得分结构"></a>得分结构</h1><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230908154557976.png" alt="image-20230908154557976"></p><h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230908162909118.png" alt="image-20230908162909118"></p><h3 id="RPR"><a href="#RPR" class="headerlink" title="RPR"></a>RPR</h3><ul><li>可以为不同的业务数据分配不同的优先级</li><li>能在50ms的时间内隔离出现故障的结点和光纤段</li><li>内环和外环都可以用于传输数据分组和控制分组</li><li>是一种用于直接在光纤上高效传输IP分组的传输技术</li><li>数据帧由目的结点回收</li><li>在每一个节点都执行SRP公平算法</li><li>两个RPR节点之间的裸光纤最大长度为100公里</li><li>将沿<strong>顺时针</strong>传输的光纤叫做<strong>外环</strong>，将沿<strong>逆时针</strong>传输的光纤叫做<strong>内环</strong>。内环和外环可以用<strong>统计复用</strong>的方式传输IP分组<ul><li>内环和外环都可以传输数据分组和控制分组</li></ul></li></ul><h3 id="ITU"><a href="#ITU" class="headerlink" title="ITU"></a>ITU</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911165341499.png" alt="image-20230911165341499"></p><p>OC-3：155.52Mbps</p><p>OC-12：622.08Mbps</p><p>OC-24：1.244Gbps</p><p>OC-48：2.488Gbps</p><p>OC-192：9.954Gbps</p><h3 id="HFC"><a href="#HFC" class="headerlink" title="HFC"></a>HFC</h3><ul><li>==光纤同轴电缆混合网</li><li>是一个双向传输系统</li><li>光纤结点通过同轴电缆下引线为用户提供服务</li><li>为有线电视用户提供一种Internet接入方式</li></ul><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>双冒号压缩：不能省略非全0段的0</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911170901677.png" alt="image-20230911170901677"></p><h3 id="IEEE802-11"><a href="#IEEE802-11" class="headerlink" title="IEEE802.11"></a>IEEE802.11</h3><ul><li>各种协议传输最大速率<ul><li>802.11b：11Mbps，最大容量33</li><li>802.11a：54Mbps（工作频段5GHz，采用了多载波调制技术）最大容量432<ul><li>802.11j：是802.11a的补充，在4.9GHz~5.0GHz这个无线频率范围内增加信道</li><li>802.11g：54Mbps（工作频段2.4 GHz ），最大容量132</li></ul></li><li>802.11n：600Mbps</li></ul></li></ul><h3 id="IEEE802-16"><a href="#IEEE802-16" class="headerlink" title="IEEE802.16"></a>IEEE802.16</h3><p>提供宽带城域网用户访问Internet所需要的路    服务</p><p>传输速率：32~134Mbps</p><p>使用无线频段10~66GHz</p><p>与之对应的论坛组织WiMAX</p><h3 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h3><p>光以太网用光信号来传输数据，以信元为单位传输数据的是ATM网</p><ul><li>能够根据用户的需求分配带宽</li><li>具有保护用户和网络资源安全的认证和授权功能</li><li>提供分级的QoS服务</li><li>支持MPLS（多协议标记交换）协议</li></ul><h3 id="无线接入技术"><a href="#无线接入技术" class="headerlink" title="无线接入技术"></a>无线接入技术</h3><ul><li>分类<ul><li>无线局域网接入（IEEE  802.11标准）<ul><li>WLAN</li></ul></li><li>无线城域网接入（IEEE  802.16标准）<ul><li>WiMAX<ul><li>可以在50km内提供70Mbit/s的速度</li></ul></li></ul></li><li>Ad hoc接入</li></ul></li></ul><p>WLAN 、WiMAX、Wi Fi 、WMAN、Ad hoc</p><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><ul><li>分类<ul><li>数字用户线xDSL技术</li><li>光纤同轴电缆混合网HFC技术</li><li>光纤接入技术</li><li>无线接入技术<ul><li>无线局域网接入</li><li>无线城域网接入</li><li>无线Ad hoc接入</li></ul></li><li>局域网接入技术</li></ul></li></ul><h3 id="QoS"><a href="#QoS" class="headerlink" title="QoS"></a>QoS</h3><p>QoS（Quality of Service）是一种网络技术，用于管理和控制网络上的数据流，以确保不同类型的数据流能够在网络中得到适当的带宽、延迟、丢包率等服务质量参数。QoS技术的主要目标是满足网络上不同应用和服务的性能需求，并确保关键应用的良好运行。</p><p>属于QoS技术的有</p><ul><li>Diffserv（区分服务）</li><li>RSVP（资源预留）</li><li>MPLS（多协议标记交换）</li></ul><h3 id="APON"><a href="#APON" class="headerlink" title="APON"></a>APON</h3><p>光纤接入技术</p><h3 id="HFC-1"><a href="#HFC-1" class="headerlink" title="HFC"></a>HFC</h3><p>接入方式采用共享式的传输方式，所有电缆调制解调器信号的发送、接收使用同一个上行和下行通道。因此HFC网上的用户越多，每个用户实际可用的带宽就越窄</p><p><strong>组成</strong>：有线电视头端、长距离干线、放大器、馈线、下引线</p><p><strong>传输速率</strong>:10~36Mbps</p><p>HFC通过电缆调制解调器将用户计算机与同轴电缆连接起来</p><h3 id="光纤传输系统"><a href="#光纤传输系统" class="headerlink" title="光纤传输系统"></a>光纤传输系统</h3><p>中继距离可达100公里以上</p><h3 id="Cable-Modem"><a href="#Cable-Modem" class="headerlink" title="Cable Modem"></a>Cable Modem</h3><p>利用频分复用(FDM)的方法，将信道分为上行信道和下行信道</p><p>把用户计算机和有线电视同轴电缆连接起来</p><p>传输速率可达10~36Mbps</p><h3 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h3><p>不提供用户访问Internet所需的路由服务</p><p>基本功能</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911175749527.png" alt="image-20230911175749527"></p><h3 id="核心交换层"><a href="#核心交换层" class="headerlink" title="核心交换层"></a>核心交换层</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911182423848.png" alt="image-20230911182423848"></p><h3 id="宽带城域网"><a href="#宽带城域网" class="headerlink" title="宽带城域网"></a>宽带城域网</h3><p>结构（三个平台一个出口）</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911175533514.png" alt="image-20230911175533514"></p><p>光以太网</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911180322849.png" alt="image-20230911180322849"></p><p>带内管理：利用传统电信网进行的网络管理，如数据通信网（DCN）或公共交换电话网（PSTN）拨号，对网络设备进行配置</p><p>带外管理：利用IP协议进行的网络管理，利用的是SNMP协议    </p><h3 id="服务器技术"><a href="#服务器技术" class="headerlink" title="服务器技术"></a>服务器技术</h3><ul><li>服务器磁盘性能表现在磁盘存储容量与I/O速度</li><li>服务器<strong>可靠性</strong>通常用平均无故障时间（MTBF），用平均维修时间（MTBR）来度量系统<strong>可维护性</strong>，而<strong>可用性=MTBF/(MTBF+MTBR)</strong></li></ul><h3 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h3><p>主要用于广域网中（而非城域网）</p><h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p>使用一对铜双绞线</p><p>ADSL Modem（解调器）用于连接计算机</p><p>提供非对称带宽特性</p><ul><li>上行速度：64Kbit/s ~ 640Kbit/s</li><li>下行速度：500Kbit/s ~ 7Mbit/s </li></ul><p>在现有用户电话线上支持电话业务和数字业务</p><p>xDSL按上行和下行速率分为速率对称和非对称</p><p>HDSL上行传输速率为1.544Mbps</p><h3 id="光接入网"><a href="#光接入网" class="headerlink" title="光接入网"></a>光接入网</h3><p>光接入网不适宜使用复杂的激光器及其他复杂光器件，以减少大量用户接入时的安装、维护的工作量，以降低成本提高系统可靠性。这些要求意味着无源光接入网比有源光接入网更符合实际应用</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911172000367.png" alt="image-20230911172000367"></p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="磁盘阵列技术"><a href="#磁盘阵列技术" class="headerlink" title="磁盘阵列技术"></a>磁盘阵列技术</h3><p>RAID能在一定程度上提高磁盘存储容量，但不能提高容错率</p><h3 id="服务器技术-1"><a href="#服务器技术-1" class="headerlink" title="服务器技术"></a>服务器技术</h3><p>注意：集群服务器中一个主机出现故障，虽然不会影响系统的<strong>正常服务</strong>，但是会影响系统的性能</p><p>使用RISC结构处理器的服务器通常使用<strong>UNIX</strong>操作系统</p><p>分布式<strong>内存访问技术（NUMA）</strong>将对称多处理器（SMP）和<strong>集群（Cluster）</strong>技术结合</p><p><strong>Cluster技术</strong>：一个主机上的程序异常，该主机上的程序将立即转移至其他主机</p><p><strong>B/S</strong>：浏览器/服务器模式</p><p>服务器<strong>磁盘性能</strong>：由磁盘容量和I/O速度决定</p><p>热插拔：不能更换<strong>主背板</strong>、<strong>主板</strong></p><ul><li>为了提高服务器性能采用了以下技术：<ul><li>对称多处理（SMP）</li><li>集群（Cluster）</li><li>非一致内存访问（NUMA）</li><li>高性能存储与智能I/O技术</li><li>服务处理器与服务控制（ISC）</li><li>应急管理端口（EMP）</li><li>热插拔</li></ul></li></ul><p>均采取了链路冗余的方法</p><p>核心层目前主要采用GE/10GE网络技术</p><p>a的成本高，可靠性高</p><p>b更易形成带宽瓶颈，容易形成单点故障</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230916090403212.png" alt="image-20230916090403212"></p><h3 id="路由器技术"><a href="#路由器技术" class="headerlink" title="路由器技术"></a>路由器技术</h3><ul><li>性能指标<ul><li>吞吐量</li><li>背板能力</li><li>丢包率</li><li>时延与时延抖动</li><li>突发处理能力</li><li>路由表容量</li><li>服务质量</li><li>网管能力</li><li>可靠性</li><li>可用性</li></ul></li></ul><p><strong>路由器的包转发能力</strong>：与<strong>端口数量、端口速率、包长度和包类型</strong>有关</p><p>吞吐是路由器的包转发能力</p><p><strong>背板能力决定了路由器的吞吐量</strong></p><p>语音、视频业务对延时抖动要求<strong>较高</strong></p><p>路由器的突发处理能力是以<strong>最小帧间隔的发送数据包</strong>而<strong>不引起丢失的最大发送速率</strong>来衡量的，而不单单只是以最小帧间隔来衡量</p><p><strong>丢包率</strong>是衡量路由器超负荷工作能力的指标之一</p><p><strong>路由器的服务质量</strong>：主要表现在队列管理机制与支持的Qos协议类型上</p><p><strong>传统路由器</strong>采用<strong>共享背板</strong>的结构，<strong>高性能路由器</strong>采用<strong>可交换式</strong>结构</p><p>队列管理机制：指路由器的队列调度算法和<strong>拥塞管理机制</strong></p><p>高端路由器可靠与可用性指标：</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230916091237962.png" alt="image-20230916091237962"></p><h3 id="网络需求分析"><a href="#网络需求分析" class="headerlink" title="网络需求分析"></a>网络需求分析</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230916084311163.png" alt="image-20230916084311163"></p><h3 id="网络系统分层设计"><a href="#网络系统分层设计" class="headerlink" title="网络系统分层设计"></a>网络系统分层设计</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230916092304990.png" alt="image-20230916092304990"></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>BGP是不同自治系统的路由器之间交换路由信息的协议</p><p>BGP发言人需要周期性（一般间隔是30秒）交换“保活分组”（keeplive）</p><p>一个BGP发言人与其他自治系统中BGP发言人交换路由信息使用TCP连接</p><p>open用于与相邻的另一个BGP发言人简历关系</p><ul><li><p>使用update分组更新路由时，一个报文只能增加一条路由</p><ul><li>所以：当路由信息发生变化时，BGP发言人通过update通知相邻自治系统</li></ul></li><li><p>BGP协议交换路由信息的节点数不小于自治系统数</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在BGP中，节点是指运行BGP协议的路由器。理论上，每个自治系统都可以有一个或多个BGP路由器。因此，如果你有<span class="built_in">N</span>个自治系统，那么至少应该有<span class="built_in">N</span>个BGP路由器来表示这些自治系统。这是因为每个自治系统都需要至少一个BGP节点来表示和交换路由信息。</span><br></pre></td></tr></table></figure></li></ul><p>BGP4采用<strong>路由向量</strong>协议</p><p>BGP是边界网关协议，不是内部网关协议    </p><h3 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h3><ul><li>RIP</li><li>OSPF</li><li>IGRP</li></ul><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>OSPF使用分布式链路状态协议</p><p>链路状态数据库存储着全网的拓扑结构图（不是路由表），并且在全网内保持一致</p><p>OSPF协议要求当链路状态发生变化时采用洪泛法（flooding），向所有路由器发送信息。</p><p>为了使用规模更大的网络，并使更新过程手链更快，OSPF协议将一个自治系统再分为诺干个更小的范围，叫做区域。</p><p>每个区域有一个32位的区域标识符（用点分十进制表示），在一个区域内的路由器不超过200个</p><p>链路状态“度量”主要是指费用、距离、延时、宽带等</p><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><ul><li>路由刷新报文主要内容是由诺干（V、D）组成的表<ul><li>V代表<code>矢量</code>，标识该路由器可以达到的目标网络（或目标主机）</li><li>D代表<code>距离</code>：指出该路由器到达目标网络（或目标主机）的距离（记录路由器的跳数）</li></ul></li></ul><p>路由器在接收（V、D）报文后按照最短路径原则更新路由表</p><p>要求路由器周期性地向外发送路由刷新报文</p><p>路由器在接收到（V、D）报文后按照最短路径原则更新路由表</p><p>RIP协议实现简单，但不适用于大型网络结构</p><p><strong>OSPF和RIP都采用了最短路径优先原则</strong></p><h3 id="AI总结"><a href="#AI总结" class="headerlink" title="AI总结"></a>AI总结</h3><h4 id="RIP-1"><a href="#RIP-1" class="headerlink" title="RIP"></a>RIP</h4><p>RIP（Routing Information Protocol）是一种老旧的内部网关协议（IGP），用于在小型和中型网络中路由数据包。它最早出现在1980年代，并经历了多个版本，其中最广泛使用的版本是RIP版本1（RIPv1）和RIP版本2（RIPv2）。以下是关于RIP的一些重要信息：</p><ol><li><p><strong>跳数矢量协议</strong>：RIP是一种跳数矢量协议，它使用”跳数”（hop count）来衡量路径的距离。每个路由器通过跟踪到目标网络的跳数来选择最佳路径，较少的跳数表示更短的路径。然而，这种度量方式忽略了带宽和延迟等因素。</p></li><li><p><strong>RIPv1 vs. RIPv2</strong>：</p><ul><li><strong>RIPv1</strong>：RIPv1是RIP的早期版本，它使用广播方式发送路由更新，并没有提供对子网掩码的支持。此外，RIPv1没有进行身份验证，因此容易受到安全威胁。</li><li><strong>RIPv2</strong>：RIPv2是RIP的改进版本，支持VLSM（可变长度子网掩码）和CIDR（无类别域间路由）。它也可以使用多播方式发送路由更新，提供了一些基本的安全特性，如身份验证。</li></ul></li><li><p><strong>最大跳数限制</strong>：RIP限制了路径的最大跳数为15。这意味着如果一个网络距离某个目标网络的跳数超过15，RIP将不再考虑该路径。这种限制可能不适用于大型网络。</p></li><li><p><strong>路由更新和定期广播</strong>：RIP路由器会定期广播路由信息，以确保网络拓扑的及时更新。路由器还会在网络拓扑发生变化时发送路由更新。</p></li><li><p><strong>自动汇总</strong>：RIP通常会自动对具有相同网络前缀的路由进行汇总，以减小路由表的大小。这有助于减少路由器的负载。</p></li><li><p><strong>不适合大型网络</strong>：由于其跳数矢量特性和其他限制，RIP在大型复杂网络中通常不被视为最佳选择。它的路由信息可能会产生较大的控制报文量，导致网络拥堵和慢速收敛。</p></li><li><p><strong>被更现代的协议替代</strong>：随着时间的推移，RIP逐渐被更现代的内部路由协议如OSPF和EIGRP所取代。这些协议提供了更好的性能、可扩展性和功能，特别是在大型企业网络和互联网服务提供商环境中。</p></li></ol><p>总之，RIP是一种简单的内部路由协议，适用于小型网络或用于教育和实验目的。然而，在大型复杂网络中，通常更先进的路由协议被广泛采用，以满足更高的性能和可管理性需求。</p><h4 id="OSPF-1"><a href="#OSPF-1" class="headerlink" title="OSPF"></a>OSPF</h4><p>OSPF（Open Shortest Path First）是一种用于内部路由的开放式链路状态路由协议。它是一种内部网关协议（IGP），通常用于企业和互联网服务提供商（ISP）网络中，用于确定数据包在本地网络中的最佳路径。以下是有关OSPF的一些关键信息：</p><ol><li><p><strong>链路状态路由协议</strong>：OSPF是一种链路状态路由协议，它通过交换链路状态信息来维护关于整个网络拓扑的精确视图。每个OSPF路由器都维护一个链路状态数据库（LSDB），其中包含了关于网络中的所有路由器和链路的信息。</p></li><li><p><strong>自治系统内部使用</strong>：OSPF通常用于单个自治系统（AS）内部，以确保该AS内的路由信息的可靠分发。它不用于连接不同AS之间的路由，这是BGP等外部网关协议的任务。</p></li><li><p><strong>区域化</strong>：OSPF网络可以分成多个区域（Area），每个区域有自己的链路状态数据库。这种层次化结构减少了LSDB的规模，提高了路由器计算和数据库更新的效率。区域之间的路由信息交换由Area Border Router（ABR）和Backbone Area（Area 0）完成。</p></li><li><p><strong>路由计算</strong>：OSPF使用Dijkstra算法来计算最短路径树，确定数据包的最佳路径。每个路由器都维护一个最短路径树，该树代表到达网络中每个目标的最佳路径。</p></li><li><p><strong>路由度量</strong>：OSPF使用成本（Cost）来衡量路径的开销，通常与链路带宽相关。较低的成本表示更好的路径。管理员可以手动配置成本，也可以使用默认值。</p></li><li><p><strong>可用性和快速收敛</strong>：OSPF设计了多种机制来确保网络的高可用性和快速收敛。这包括Hello协议用于邻居发现、LSU（Link State Update）分组用于链路状态信息的更新、LSAck用于确认、以及快速重新计算和收敛机制等。</p></li><li><p><strong>认证和安全性</strong>：OSPF支持认证机制，可以确保只有授权的路由器可以参与OSPF过程，从而增强了网络的安全性。</p></li><li><p><strong>OSPF版本</strong>：最初的OSPF版本是OSPFv1，后来发展了OSPFv2和OSPFv3，分别用于IPv4和IPv6网络。</p></li><li><p><strong>应用领域</strong>：OSPF常被用于大型企业网络、校园网络、数据中心和ISP网络中，因为它对于复杂网络拓扑的支持和优秀的收敛性能非常适用。</p></li></ol><p>总之，OSPF是一种强大的内部路由协议，它允许网络管理员建立高度可靠的内部网络拓扑，并确保数据包以最佳路径进行路由。它的优点包括快速收敛、链路状态信息的精确性以及支持IPv6等现代网络要求。</p><h4 id="BGP-1"><a href="#BGP-1" class="headerlink" title="BGP"></a>BGP</h4><p>BGP（Border Gateway Protocol）是一种用于在互联网中路由数据流量的协议。它是互联网上最常用的路由协议之一，主要用于控制数据包在不同自治系统（AS）之间的路由选择。以下是关于BGP的一些重要信息：</p><ol><li><p><strong>自治系统（AS）</strong>：互联网上的网络被划分为多个自治系统，每个自治系统代表一组由单一管理实体控制的IP地址块。BGP用于在不同自治系统之间交换路由信息。</p></li><li><p><strong>BGP路由器</strong>：BGP路由器是运行BGP协议的网络设备，它们负责与其他BGP路由器交换路由信息，并根据这些信息决定如何路由数据包。BGP路由器可以是企业内部的边界路由器（Border Router）或互联网服务提供商（ISP）之间的核心路由器。</p></li><li><p><strong>BGP路由表</strong>：BGP路由器维护一个庞大的路由表，其中包含了关于互联网上的各种网络的信息。这些路由表条目包括目标网络的前缀、下一跳路由器和AS路径等信息。</p></li><li><p><strong>BGP邻居关系</strong>：BGP路由器之间建立邻居关系，以交换路由信息。这些邻居关系可以通过直连连接或通过TCP/IP网络建立。</p></li><li><p><strong>路由策略</strong>：BGP允许网络管理员定义路由策略，以确定如何选择最佳路径来路由数据包。这些策略可以基于AS路径、前缀长度、AS前缀等多个因素进行配置。</p></li><li><p><strong>BGP路由选择过程</strong>：BGP使用路径矢量算法来选择最佳路由。它考虑了多个因素，包括AS路径、前缀长度和路由策略，以确定最佳路径。</p></li><li><p><strong>BGP版本</strong>：目前广泛使用的是BGP-4版本，它在之前的版本基础上进行了改进和扩展，以提高路由的稳定性和可扩展性。</p></li><li><p><strong>BGP的应用</strong>：BGP主要用于互联网核心路由，它决定了数据包如何穿越多个自治系统。此外，BGP还可以用于企业内部网络，特别是在多个站点之间建立广域网连接时。</p></li><li><p><strong>BGP的安全性</strong>：由于BGP的分布性和开放性，它容易受到路由劫持和欺骗等安全威胁。为了提高BGP的安全性，一些安全机制如BGP路由验证（BGP RPKI）和BGP监控工具得到了广泛部署。</p></li></ol><p>总之，BGP是互联网上用于路由控制的关键协议，它确保了全球网络的可达性和稳定性。由于其复杂性和重要性，BGP的配置和管理需要高度的专业知识和经验。</p><h2 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h2><h3 id="IP地址计算"><a href="#IP地址计算" class="headerlink" title="IP地址计算"></a>IP地址计算</h3><p>网络地址：主机位变0</p><p>直接广播地址：主机位变1</p><p>主机号：网络为变0</p><p>子网第一个可用ip地址：网络地址+1</p><h3 id="NAT转换"><a href="#NAT转换" class="headerlink" title="NAT转换"></a>NAT转换</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911185634062.png" alt="image-20230911185634062"></p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911185647419.png" alt="image-20230911185647419"></p><h3 id="大题"><a href="#大题" class="headerlink" title="大题"></a>大题</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230922150904782.png" alt="image-20230922150904782"></p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230922151052558.png" alt="image-20230922151052558"></p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230923183337784.png" alt="image-20230923183337784"></p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230923183715431.png" alt="image-20230923183715431">    </p><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230923190416670.png" alt="image-20230923190416670"></p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230923190427976.png" alt="image-20230923190427976"></p><h4 id="sniffer"><a href="#sniffer" class="headerlink" title="sniffer"></a>sniffer</h4><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230923190709500.png" alt="image-20230923190709500"></p><h1 id="AI总结-1"><a href="#AI总结-1" class="headerlink" title="AI总结"></a>AI总结</h1><h2 id="第一章-1"><a href="#第一章-1" class="headerlink" title="第一章"></a>第一章</h2><h3 id="RPR-1"><a href="#RPR-1" class="headerlink" title="RPR"></a>RPR</h3><p>RPR（Rapid Spanning Tree Protocol）技术是一种用于以太网网络的协议，旨在解决环路问题和提高网络可靠性。它具有以下关键特点：</p><ol><li><p><strong>环路防护</strong>：RPR防止以太网网络中的环路形成，避免广播风暴和数据包洪泛等问题，从而提高网络性能。</p></li><li><p><strong>快速收敛</strong>：RPR能够快速检测网络故障并快速恢复，降低网络中断的时间，相比传统的STP更快速。</p></li><li><p><strong>冗余路径</strong>：RPR支持多个路径，当主路径出现问题时，可以迅速切换到备用路径，提高网络可用性。</p></li><li><p><strong>QoS支持</strong>：RPR允许配置不同的服务质量，确保关键应用程序性能。</p></li><li><p><strong>分布式架构</strong>：RPR使用分布式架构，不需要中央控制器，提高了网络的可伸缩性和稳定性。</p></li><li><p><strong>适用性</strong>：RPR通常用于大型以太网网络，如城域网和广域网，特别适用于需要高可用性和快速恢复的应用场景。</p></li></ol><p>总之，RPR技术旨在改善以太网网络的性能和可靠性，通过防止环路和快速恢复故障来确保网络的高可用性。这对于大型网络和关键应用程序至关重要。</p><h3 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h3><p>STP（Spanning Tree Protocol）技术是一种用于以太网网络的协议，旨在防止网络中的环路并确保数据包传输的稳定性。STP是IEEE 802.1D标准的一部分，它的主要作用是构建一个无环的树状拓扑结构，以避免广播风暴和数据包洪泛。</p><p>以下是STP技术的关键概念和特点：</p><ol><li><p><strong>环路防护</strong>：STP的主要目标是防止以太网网络中的环路。环路可能导致数据包在网络中无限循环，从而耗尽网络资源并降低性能。STP通过选择一条主要路径，将其他冗余路径禁用，以确保网络中不存在环路。</p></li><li><p><strong>桥和交换机</strong>：STP协议适用于桥和交换机（也称为网桥和交换机），这些设备在以太网网络中传输数据帧。每个桥或交换机参与STP协议，共同协商并维护拓扑信息。</p></li><li><p><strong>树状拓扑</strong>：STP构建一个树状拓扑结构，其中一个桥或交换机被选为根桥（Root Bridge），所有其他桥或交换机都通过最佳路径连接到根桥。这确保了无环的网络拓扑。</p></li><li><p><strong>端口状态</strong>：STP定义了端口状态，包括阻塞、监听、学习和转发状态。在树状拓扑中，只有一个端口处于转发状态，其余端口处于阻塞状态，以防止环路。</p></li><li><p><strong>故障恢复</strong>：STP能够检测到网络中的拓扑更改，例如链路故障或设备添加/移除，并自动重新计算拓扑以适应这些更改，以确保网络的稳定性。</p></li><li><p><strong>多个变种</strong>：STP有几个变种，包括经典STP（CSTP）、快速STP（RSTP），以及更快速的多重实例STP（MSTP）。这些变种增强了STP的性能和快速故障恢复能力。</p></li></ol><p>总之，STP技术是一种用于以太网网络的关键协议，旨在防止环路并确保网络的可靠性。它通过构建无环的树状拓扑结构来实现这一目标，并能够在网络拓扑发生变化时自动进行调整，以维护网络的稳定性。不过，需要注意的是，STP的收敛速度相对较慢，因此在要求更快速的网络恢复的情况下，可能需要考虑使用其他协议，如RSTP或MSTP。</p><h3 id="RPR和STP区别"><a href="#RPR和STP区别" class="headerlink" title="RPR和STP区别"></a>RPR和STP区别</h3><p>RPR（Rapid Spanning Tree Protocol）和STP（Spanning Tree Protocol）是两种不同的网络协议，用于以太网网络中的环路防护，它们之间有一些关键的区别：</p><ol><li><p><strong>目标</strong>:</p><ul><li><p><strong>RPR</strong>：RPR的主要目标是提高以太网网络的恢复速度和性能。它旨在快速检测网络中的故障并迅速切换到备用路径，以减少网络中断时间。</p></li><li><p><strong>STP</strong>：STP的主要目标是防止网络中的环路，而不是强调快速恢复。STP构建一个无环的树状拓扑结构，确保数据包不会在网络中无限循环。</p></li></ul></li><li><p><strong>收敛速度</strong>:</p><ul><li><p><strong>RPR</strong>：RPR被设计为快速收敛的协议，通常能够在毫秒级别内检测到网络故障并快速恢复，降低网络中断的影响。</p></li><li><p><strong>STP</strong>：STP的收敛速度相对较慢，通常需要几秒钟或更长时间来恢复网络。这是因为STP使用定时器和状态机来确定最佳路径，需要一些时间来计算和选择新的路径。</p></li></ul></li><li><p><strong>拓扑结构</strong>:</p><ul><li><p><strong>RPR</strong>：RPR允许多个路径同时存在于网络中，以提高冗余性。如果主路径出现故障，RPR可以快速切换到备用路径，确保网络的连通性。</p></li><li><p><strong>STP</strong>：STP构建一个树状拓扑结构，其中只有一个主路径，其他路径处于阻塞状态。这可以防止环路，但是对于冗余路径的利用有限。</p></li></ul></li><li><p><strong>分布式 vs. 集中式</strong>:</p><ul><li><p><strong>RPR</strong>：RPR采用分布式架构，网络中的每个节点可以独立进行决策，而无需中央控制器。这提高了网络的可伸缩性和稳定性。</p></li><li><p><strong>STP</strong>：STP通常是集中式的，网络中的一个节点被选为根桥，然后计算路径以连接到根桥。这种集中式方法可以导致性能瓶颈和单点故障。</p></li></ul></li><li><p><strong>适用性</strong>:</p><ul><li><p><strong>RPR</strong>：RPR通常用于城域网（Metropolitan Area Networks，MANs）和广域网（Wide Area Networks，WANs）等大型以太网网络，特别是需要高可用性和快速恢复的应用场景。</p></li><li><p><strong>STP</strong>：STP通常用于局域网（Local Area Networks，LANs）或小型网络，要求环路防护，但对于快速恢复性能要求不是很高的情况。</p></li></ul></li></ol><p>总的来说，RPR和STP是两种不同的环路防护协议，它们的设计目标和性能特点有所不同。RPR强调快速恢复和冗余路径支持，适用于大型网络，而STP主要用于小型网络，其主要目标是环路防护。选择哪种协议取决于网络规模、性能要求和特定的应用场景。</p><h3 id="FDDI"><a href="#FDDI" class="headerlink" title="FDDI"></a>FDDI</h3><p>FDDI（Fiber Distributed Data Interface）是一种早期的局域网（LAN）技术，最早于1987年由美国国家标准协会（ANSI）标准化。它是一种基于光纤和双绞线的高性能网络技术，旨在提供高带宽、低延迟和高可用性的网络连接。以下是关于FDDI的主要特点和特点：</p><ol><li><p><strong>光纤传输</strong>：FDDI的核心特点是使用光纤作为主要的传输媒介。光纤具有高带宽、低信号衰减和抗电磁干扰的特点，因此能够支持远距离的数据传输，并提供较高的数据传输速度。</p></li><li><p><strong>双环拓扑</strong>：FDDI网络采用双环拓扑结构，分为主环（Primary Ring）和备用环（Secondary Ring）。这两个环状结构可以在网络故障时提供冗余路径，以确保网络的高可用性。如果主环中的某一部分出现故障，数据将被切换到备用环路，几乎无感知地继续传输。</p></li><li><p><strong>高带宽</strong>：FDDI支持高带宽，最初的速度为100 Mbps（兆比特每秒）。后来，FDDI-II标准提出了更高速度的变种，达到了200 Mbps。这使得FDDI成为当时性能最高的LAN技术之一。</p></li><li><p><strong>低延迟</strong>：FDDI设计用于支持实时应用程序，因此具有低延迟特性。这对于需要快速响应时间的应用程序非常重要，例如音频和视频传输。</p></li><li><p><strong>支持多协议</strong>：FDDI可以支持多种协议，包括TCP/IP、IPX/SPX等，使其在不同的操作系统和应用程序环境中通用。</p></li><li><p><strong>管理和可靠性</strong>：FDDI具有强大的管理功能，可以监视网络性能和识别故障。它还具有自动检测和纠正环路故障的能力，以确保网络的稳定性。</p></li><li><p><strong>物理层和数据链路层</strong>：FDDI定义了物理层和数据链路层的标准，包括光纤传输规范、帧格式和MAC（Media Access Control）协议。</p></li><li><p><strong>适用性</strong>：FDDI最初设计用于大型企业网络和数据中心，以满足高带宽、高可用性和低延迟的需求。然而，随着技术的发展，以太网等其他LAN技术逐渐崭露头角，FDDI在较小规模的网络中的使用逐渐减少。</p></li></ol><p>总之，FDDI是一种光纤局域网技术，具有高带宽、低延迟、高可用性和强大的管理功能。尽管它在过去曾经是主要的网络技术之一，但随着以太网等技术的崭露头角，FDDI的使用逐渐减少。然而，它的一些特点仍然在特定的网络环境中有价值，例如需要高可靠性和低延迟的应用场景。</p><h3 id="ADSL-1"><a href="#ADSL-1" class="headerlink" title="ADSL"></a>ADSL</h3><p>ADSL（Asymmetric Digital Subscriber Line）是一种常见的宽带接入技术，用于将数字数据通过普通电话线传输。ADSL之所以称为”不对称”，是因为它支持不同的上行（上传）和下行（下载）数据传输速度，通常下载速度较高，适用于大多数家庭用户的需求。以下是有关ADSL的主要特点和工作原理：</p><ol><li><p><strong>不对称速度</strong>：</p><ul><li>下行速度（从互联网到用户）通常比上行速度（从用户到互联网）快得多。这种设计是基于家庭用户通常更多地下载内容而较少上传的使用模式。</li></ul></li><li><p><strong>电话线传输</strong>：</p><ul><li>ADSL使用普通电话线（铜线）来传输数字数据。这意味着在大多数情况下，用户不需要新的电缆或基础设施，只需使用电话线接入ADSL即可。</li></ul></li><li><p><strong>拆分频段</strong>：</p><ul><li>ADSL技术允许电话线同时传输模拟电话信号和数字数据信号。为了实现这一点，频谱被划分为不同的频段，其中一部分用于传输语音信号，而另一部分用于传输数字数据。</li></ul></li><li><p><strong>调制与解调制</strong>：</p><ul><li>ADSL中，数字数据通过调制（在发送端）和解调制（在接收端）的过程来传输。调制将数字数据转换成模拟信号，以便通过电话线传输。解调制则将接收到的信号还原为数字数据。</li></ul></li><li><p><strong>距离限制</strong>：</p><ul><li>ADSL的性能受到用户和提供商之间的距离限制。通常，用户越远离提供商的中心局（DSLAM，DSL Access Multiplexer），其ADSL连接速度就会降低。这是因为信号在长距离传输过程中会逐渐减弱。</li></ul></li><li><p><strong>不适用于对称需求</strong>：</p><ul><li>尽管ADSL适用于家庭用户和小型企业，但对于需要对称上传和下载速度的应用（如视频会议或远程服务器访问），ADSL可能不是最佳选择。</li></ul></li><li><p><strong>普及性</strong>：</p><ul><li>在过去的几十年中，ADSL曾是家庭和小型企业宽带接入的主要选择，因为它提供了相对较高的下载速度，而且普及率高。然而，随着光纤和有线宽带技术的发展，ADSL在一些地区逐渐被更快的宽带连接替代。</li></ul></li></ol><p>总体而言，ADSL是一种宽带接入技术，适用于家庭用户和小型企业，因其便捷性和相对低廉的成本而受欢迎。然而，在需要更高对称带宽或更远距离连接的场景中，可能需要考虑其他宽带技术，如光纤或有线宽带。</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT，全称为Network Address Translation（网络地址转换），是一种网络技术，常用于连接私有网络与公共互联网之间，以实现多台设备共享单个公共IP地址的目的。NAT的主要功能是将内部私有网络中的设备与外部互联网之间的通信进行转换和管理。以下是有关NAT的主要概念和功能：</p><ol><li><p><strong>IP地址转换</strong>：</p><ul><li>NAT主要工作是将内部私有网络中的设备使用私有IP地址与外部互联网之间的通信进行转换。私有IP地址通常位于以下保留地址段之一：10.0.0.0至10.255.255.255、172.16.0.0至172.31.255.255或192.168.0.0至192.168.255.255。</li></ul></li><li><p><strong>单一公共IP地址</strong>：</p><ul><li>NAT允许多台设备在内部私有网络中使用相同的公共IP地址进行互联网访问。这种方式可以帮助节省公共IP地址，并提高网络的安全性，因为内部设备的IP地址对外部不可见。</li></ul></li><li><p><strong>端口映射</strong>：</p><ul><li>除了IP地址转换，NAT还可以使用端口映射（Port Mapping）来将多个内部设备与同一个公共IP地址关联起来。通过在公共IP地址和端口之间建立映射，NAT可以将外部请求正确路由到内部的特定设备上。</li></ul></li><li><p><strong>类型</strong>：</p><ul><li>有不同类型的NAT，包括静态NAT、动态NAT和PAT（Port Address Translation）。<ul><li><strong>静态NAT</strong>：为特定内部设备分配一个固定的公共IP地址，通常用于服务器等需要对外部可见的设备。</li><li><strong>动态NAT</strong>：为内部设备动态分配公共IP地址，通常是从一个可用的地址池中选择。</li><li><strong>PAT</strong>：是一种特殊形式的NAT，它使用单个公共IP地址，并通过不同的端口号来区分不同的内部设备。</li></ul></li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>NAT提供一定程度的安全性，因为内部设备的IP地址对外部互联网不可见。这可以防止外部网络直接访问内部设备，提高了网络的安全性。</li></ul></li><li><p><strong>IPv4地址枯竭问题</strong>：</p><ul><li>NAT也有助于缓解IPv4地址短缺问题，因为它允许多个内部设备共享一个公共IP地址。这对于面临IP地址不足问题的网络非常重要。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>NAT常用于家庭网络路由器、企业网络和云计算环境中，以允许多个设备在内部网络中访问互联网。它也用于在虚拟化环境中管理虚拟机的网络连接。</li></ul></li></ol><p>总之，NAT是一种网络技术，用于将内部私有网络中的设备与外部互联网之间的通信进行转换和管理，以实现多个设备共享单个公共IP地址的目的。它对网络的安全性和IPv4地址枯竭问题都有积极的影响。</p><h3 id="数字信号和模拟信号"><a href="#数字信号和模拟信号" class="headerlink" title="数字信号和模拟信号"></a>数字信号和模拟信号</h3><p>模拟信号和数字信号是两种不同类型的信号，它们在电子通信和信息处理中具有重要作用。以下是有关模拟信号和数字信号的主要特点和区别：</p><p><strong>模拟信号（Analog Signals）</strong>：</p><ol><li><p><strong>连续性</strong>：模拟信号是连续的，它们可以在一定范围内取任意值。在模拟信号中，信号的值在时间上不断变化，可以采用无限数量的值。</p></li><li><p><strong>波形</strong>：模拟信号可以呈现为连续的波形，如正弦波、余弦波或任何复杂的波形。这些波形表示信号在时间上的变化。</p></li><li><p><strong>物理表示</strong>：模拟信号通常由连续的物理量表示，例如电压、电流或声音压力。这些物理量的变化对应于信号的变化。</p></li><li><p><strong>精度</strong>：模拟信号的精度受到噪声和干扰的影响，可能存在信号失真。因此，保持信号的质量需要采取一些措施，如滤波和放大。</p></li><li><p><strong>用途</strong>：模拟信号常用于传输连续的信息，如音频、视频和传感器数据。传统的电话线路就是一个传输模拟信号的例子。</p></li></ol><p><strong>数字信号（Digital Signals）</strong>：</p><ol><li><p><strong>离散性</strong>：数字信号是离散的，它们只能取有限数量的离散值。在数字信号中，信号的值以离散的步进方式变化。</p></li><li><p><strong>表示</strong>：数字信号通常表示为二进制代码，即由一系列0和1组成的序列。每个二进制数字代表信号的离散值。</p></li><li><p><strong>抗干扰性</strong>：数字信号在传输和处理过程中对噪声和干扰具有较强的抗性。由于信号是以离散值表示的，可以更容易地检测和纠正传输中的错误。</p></li><li><p><strong>精度</strong>：数字信号的精度通常较高，因为它们可以以足够高的分辨率表示信号，以便准确传输和处理。</p></li><li><p><strong>用途</strong>：数字信号广泛用于计算机和数字通信中，包括互联网、数字音频和视频传输、数字电视和移动通信等领域。数字信号也用于数字电子设备的内部通信和处理。</p></li></ol><p>总结起来，模拟信号是连续的、具有无限可能值的信号，通常用于传输连续的信息。而数字信号是离散的、以二进制代码表示的信号，对噪声具有较强的抗性，广泛用于数字化信息和数据的处理、传输和存储。在现代通信和信息技术中，数字信号通常更为常见，因为它们具有高精度和抗干扰性，适用于数字系统中的多种应用。</p><h3 id="地址划分"><a href="#地址划分" class="headerlink" title="地址划分"></a>地址划分</h3><p>IPv4地址空间被分为五个不同的地址类别：A、B、C、D和E。每个地址类别都具有不同的地址范围和用途。以下是各个IPv4地址类别的地址范围：</p><ol><li><p><strong>A类地址</strong>：</p><ul><li>A类地址用于大型网络，通常由大型组织、政府机构或互联网服务提供商使用。A类地址的特点是其高位字节的最高位为0。A类地址的地址范围是从1.0.0.0到126.0.0.0，其中最小的A类地址是1.0.0.0，而最大的A类地址是126.255.255.255。A类地址中有16,777,214个可用的主机地址。</li></ul></li><li><p><strong>B类地址</strong>：</p><ul><li>B类地址用于中型网络，通常由中等规模的组织或公司使用。B类地址的特点是其高位字节的最高位为10。B类地址的地址范围是从128.0.0.0到191.255.0.0，其中最小的B类地址是128.0.0.0，而最大的B类地址是191.255.255.255。B类地址中有65,534个可用的主机地址。</li></ul></li><li><p><strong>C类地址</strong>：</p><ul><li>C类地址用于小型网络，通常由小型企业或组织使用。C类地址的特点是其高位字节的最高位为110。C类地址的地址范围是从192.0.0.0到223.255.255.0，其中最小的C类地址是192.0.0.0，而最大的C类地址是223.255.255.255。C类地址中有254个可用的主机地址。</li></ul></li><li><p><strong>D类地址</strong>：</p><ul><li>D类地址用于多播（Multicast）通信。多播地址用于一对多或多对多的通信，而不是一对一的通信。D类地址的地址范围是从224.0.0.0到239.255.255.255。</li></ul></li><li><p><strong>E类地址</strong>：</p><ul><li>E类地址保留用于实验和研究，不用于正式的互联网通信。E类地址的地址范围是从240.0.0.0到255.255.255.255。</li></ul></li></ol><p>需要注意的是，这些地址范围中的一些地址已被保留用于特定用途，如私有地址空间、保留地址和多播地址。此外，IPv4地址空间已经耗尽，IPv6被广泛采用以应对IPv4地址短缺问题。因此，在实际网络中，IPv6地址分配已经变得越来越重要。</p><h3 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h3><p>在计算机网络技术中，POS（Point of Sale）技术通常指的是与零售业务相关的计算机系统和设备，用于处理销售交易和管理商店或企业的销售活动。POS技术在零售、餐饮和服务行业中广泛应用，以提高交易效率、管理库存、跟踪销售数据等。以下是计算机网络中的POS技术的关键方面：</p><ol><li><p><strong>POS终端</strong>：</p><ul><li>POS系统通常包括POS终端，这是一种特殊的计算机设备或应用程序，用于处理交易。POS终端通常与网络连接，以便与后端服务器或数据库进行通信，以获取产品价格、库存信息等。</li></ul></li><li><p><strong>网络连接</strong>：</p><ul><li>POS终端需要与后端服务器或云服务进行通信，以获取实时的产品信息、价格、库存状态等。这通常需要网络连接，可以是有线或无线网络，以确保快速和可靠的交易处理。</li></ul></li><li><p><strong>支付处理</strong>：</p><ul><li>POS技术通常包括支付处理功能，允许客户使用各种支付方式，如信用卡、借记卡、移动支付、现金等，完成交易。支付信息需要安全传输和处理，因此网络连接通常会采用加密和安全协议。</li></ul></li><li><p><strong>库存管理</strong>：</p><ul><li>POS系统能够跟踪库存水平，以便在销售产品时更新库存。当产品售罄或库存低于阈值时，POS系统可以自动发出订单或提醒库存管理人员。</li></ul></li><li><p><strong>销售数据和报告</strong>：</p><ul><li>POS系统记录每笔交易的详细信息，包括产品、价格、日期、时间等。这些数据可用于生成销售报告和分析，帮助商家了解销售趋势、产品流行度等信息。</li></ul></li><li><p><strong>客户管理</strong>：</p><ul><li>一些POS系统包括客户管理功能，允许商家跟踪客户购买历史、发送促销信息、管理客户积分或奖励计划等。</li></ul></li><li><p><strong>云POS</strong>：</p><ul><li>最近，云POS技术也逐渐流行起来。云POS系统将POS数据存储在云服务器上，允许商家远程访问和管理POS数据，无论在何地都可以查看销售数据。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>POS技术必须具备高度的安全性，以保护支付信息和客户数据。这包括加密数据传输、安全访问控制、防止恶意软件攻击等安全措施。</li></ul></li></ol><p>总之，计算机网络中的POS技术是用于处理销售和管理零售业务的关键工具。它通过网络连接、支付处理、库存管理、数据分析等功能，帮助商家提高交易效率、提供更好的客户服务，并为经营决策提供有用的数据。</p><h3 id="SDN-1"><a href="#SDN-1" class="headerlink" title="SDN"></a>SDN</h3><p>SDN（Software-Defined Networking）技术是一种网络架构和管理方法，它通过将网络控制平面（Control Plane）与数据转发平面（Data Plane）分离，并将网络控制逻辑集中化，以实现更灵活、可编程和自动化的网络管理。下面是关于SDN技术的一些重要信息：</p><ol><li><p><strong>控制平面与数据平面分离</strong>：传统网络设备如路由器和交换机通常将控制平面和数据平面集成在一起，这意味着网络的控制逻辑与数据包的处理在同一设备上完成。SDN将这两个平面分开，允许网络管理员集中管理网络策略，而数据平面设备则负责根据这些策略来转发数据包。</p></li><li><p><strong>SDN控制器</strong>：SDN网络的核心是SDN控制器，它是一个中央实体，负责管理网络设备和路由流量。流行的SDN控制器包括OpenDaylight、ONOS、Floodlight和Cisco的APIC-EM等。这些控制器提供了一种接口，允许管理员定义网络策略、监控流量并动态配置网络设备。</p></li><li><p><strong>网络可编程性</strong>：SDN使网络更加可编程，允许管理员根据应用程序需求动态配置网络策略。这使得网络能够更好地适应不同应用的要求，从而提供更高的灵活性和性能。</p></li><li><p><strong>自动化</strong>：SDN技术可以自动化许多网络管理任务，例如流量工程、负载均衡和故障恢复。通过集中化的控制，网络管理员可以更轻松地实施这些自动化任务，提高了网络的可靠性和效率。</p></li><li><p><strong>SDN协议</strong>：在SDN中，OpenFlow是最常用的通信协议之一，用于在控制器和数据平面设备之间传递流量转发规则。此外，其他协议如NETCONF和RESTful API也可以用于SDN控制器与网络设备之间的通信。</p></li><li><p><strong>SDN的优势</strong>：SDN技术提供了更好的网络管理和资源利用率，有助于降低运营成本。它还允许网络更好地适应新的应用需求，提高了网络的灵活性和可扩展性。</p></li><li><p><strong>SDN的应用</strong>：SDN技术广泛应用于数据中心网络、广域网（WAN）、电信网络和企业网络中。它在虚拟化、云计算、物联网（IoT）和5G网络等领域都有着重要的作用。</p></li></ol><p>需要注意的是，SDN技术虽然具有许多优点，但也存在一些挑战，例如安全性和复杂性。网络管理员需要仔细考虑如何有效地部署和管理SDN网络，以确保网络的稳定性和安全性。</p><h3 id="QoS-1"><a href="#QoS-1" class="headerlink" title="QoS"></a>QoS</h3><p>QoS（Quality of Service）是一种网络技术，用于管理和控制网络上的数据流，以确保不同类型的数据流能够在网络中得到适当的带宽、延迟、丢包率等服务质量参数。QoS技术的主要目标是满足网络上不同应用和服务的性能需求，并确保关键应用的良好运行。</p><p>以下是QoS技术的主要组成部分和相关概念：</p><ol><li><p><strong>带宽管理</strong>：QoS的一个关键方面是带宽管理，它涉及分配和控制网络中可用带宽的方式。这包括带宽分配、带宽保障、带宽调整等策略，以确保重要应用能够获得足够的带宽。</p></li><li><p><strong>流量分类</strong>：QoS技术根据流量的特性对数据流进行分类。通常，流量可以分为不同的类别，如实时流量（例如VoIP和视频流）、交互式流量（例如Web浏览）和后台传输流量（例如文件下载）。这些不同的类别通常需要不同的QoS处理。</p></li><li><p><strong>标记和标签</strong>：为了对不同的数据流应用QoS策略，网络设备通常使用标记或标签来识别流量。这些标记可以通过不同的字段（如DiffServ或802.1p标头字段）添加到数据包中，并在网络中路由和处理数据包时参考。</p></li><li><p><strong>流量控制</strong>：QoS技术允许管理员设置流量控制策略，以控制数据流的速率和优先级。这包括流量调度、队列管理和拥塞控制等技术，以确保高优先级流量在网络中得到及时传输。</p></li><li><p><strong>拥塞管理</strong>：拥塞是网络中常见的问题，会导致数据包丢失和延迟增加。QoS技术可以帮助网络设备识别和应对拥塞情况，例如通过降低低优先级流量的速率来保护高优先级流量。</p></li><li><p><strong>策略配置</strong>：QoS策略通常需要在网络设备上进行配置。这包括设置流量分类、标记和标签、定义带宽限制和优先级、配置队列等。</p></li><li><p><strong>监测和报告</strong>：QoS技术通常需要监测网络性能，并生成报告以评估QoS策略的有效性。这可以通过网络监控工具和QoS报告生成器来实现。</p></li></ol><p>QoS技术在各种网络环境中都有重要应用，特别是在需要支持实时应用程序（如VoIP和视频会议）的企业网络、云计算环境和电信网络中。通过有效实施QoS策略，可以提供更稳定、可靠和高性能的网络服务，确保重要应用的用户体验。</p><h3 id="HFC-2"><a href="#HFC-2" class="headerlink" title="HFC"></a>HFC</h3><p>HFC（Hybrid Fiber-Coaxial）是一种通信网络架构，通常用于提供有线电视和宽带互联网服务。HFC网络结合了光纤（Fiber）和同轴电缆（Coaxial Cable）两种不同的传输介质，以实现高速数据传输和广播电视信号的分发。以下是HFC网络的一些关键特点和组成部分：</p><ol><li><p><strong>光纤部分</strong>：</p><ul><li>HFC网络的核心是光纤（光导纤维），通常由光缆组成。光纤具有高带宽和低损耗的特点，使其能够传输大量数据，同时具有较长的传输距离。</li><li>在HFC网络中，光纤通常延伸到网络提供商的中央办公室（Headend）或数据中心。</li></ul></li><li><p><strong>同轴电缆部分</strong>：</p><ul><li>从中央办公室延伸出来的光纤通常会连接到同轴电缆，这是一种特殊的电缆，具有较高的信号传输能力。</li><li>同轴电缆在最后一英里（Last Mile）或用户家庭附近的网络中用于传输数据和电视信号。它通常分为多个信号频带，每个频带用于不同的目的。</li></ul></li><li><p><strong>分配器和放大器</strong>：</p><ul><li>在HFC网络中，光纤到达街区（通常称为节点）的地方，然后通过分配器将信号分发到各个用户家庭。</li><li>放大器（Amplifiers）用于增强信号，以弥补信号在同轴电缆中的传输损耗。这些放大器通常位于同轴电缆的不同位置，以确保信号质量。</li></ul></li><li><p><strong>数据和电视信号</strong>：</p><ul><li>HFC网络旨在支持多种服务，包括宽带互联网、有线电视和电话服务。光纤部分主要用于数据传输，而同轴电缆部分同时用于广播电视信号的传输。</li><li>数据信号通常采用数字传输，而电视信号可以是模拟或数字信号，具体取决于网络提供商的技术和服务。</li></ul></li><li><p><strong>双向通信</strong>：</p><ul><li>HFC网络通常是双向的，允许用户同时下载和上传数据。这使得它非常适合宽带互联网服务，用户可以通过网络上传和下载大文件、流媒体内容等。</li></ul></li><li><p><strong>网络提供商</strong>：</p><ul><li>HFC网络通常由电视有线运营商或互联网服务提供商提供和维护。这些提供商通过HFC网络向用户提供多种服务，并通常会提供有线电视、宽带互联网和电话服务的捆绑套餐。</li></ul></li></ol><p>总的来说，HFC网络是一种灵活且多用途的通信网络架构，它结合了光纤的高速数据传输能力和同轴电缆的广播电视信号传输能力，为用户提供了多种通信和娱乐服务。然而，随着技术的发展，一些地区正在逐渐升级到更先进的纯光纤网络，以提供更高的速度和性能。</p><h3 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h3><p>MPLS（Multiprotocol Label Switching）是一种用于构建高效、灵活和可管理的数据网络的通信协议和技术。它将传统的IP路由和数据包交换与标签交换相结合，为数据包在网络中的传输提供了更高的性能和质量。</p><p>以下是MPLS的关键特点和工作原理：</p><ol><li><p><strong>标签交换</strong>：</p><ul><li>MPLS引入了一个称为”标签”的数据包头部信息，用于标识数据包的路由和处理方式。</li><li>这些标签是短、固定长度的值，被附加到数据包的头部，以便路由器和交换机能够快速查找和转发数据包，而不必进行复杂的IP路由查找。</li></ul></li><li><p><strong>标签交换的优点</strong>：</p><ul><li>更快的数据包转发速度：由于标签查找速度比传统IP路由更快，MPLS可以实现更高的数据包转发速度，适用于要求低延迟的应用。</li><li>灵活性：MPLS可以根据标签的值来实现流量工程、负载均衡和服务质量（QoS）管理，从而更好地满足网络运营商和企业的需求。</li></ul></li><li><p><strong>标签分发和交换</strong>：</p><ul><li>MPLS网络中的路由器和交换机被称为”MPLS节点”，它们负责为数据包分发和交换标签。</li><li>当数据包进入MPLS网络时，第一个MPLS节点（通常是边缘路由器）会分配一个标签，并将其附加到数据包头部。</li><li>数据包在MPLS网络中根据标签进行路由，每个MPLS节点根据标签决定数据包的下一跳。</li><li>当数据包离开MPLS网络时，最后一个MPLS节点会将标签移除，将数据包发送到目标。</li></ul></li><li><p><strong>MPLS应用</strong>：</p><ul><li>MPLS广泛用于构建虚拟专用网络（VPN）和多协议标签交换（MPLS-VPN）。</li><li>它也用于支持服务提供商网络中的服务质量（QoS）管理、流量工程和负载均衡。</li><li>MPLS还在广域网（WAN）和数据中心网络中得到广泛应用，以提供高性能的互联互通。</li></ul></li><li><p><strong>MPLS与IP</strong>：</p><ul><li>MPLS与IP是可以协同工作的技术。事实上，MPLS可以在现有的IP网络上部署，提供额外的功能和性能优势。</li><li>MPLS通常与BGP（Border Gateway Protocol）等路由协议一起使用，以确定数据包的路径和标签分发。</li></ul></li></ol><p>总的来说，MPLS是一种强大的网络技术，用于提高数据网络的性能、可管理性和质量。它在提供广域网连接、建立虚拟专用网络、实现服务质量管理等方面发挥了重要作用，并在大型企业网络、云服务和电信网络中得到广泛应用。</p><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>频分复用（Frequency Division Multiplexing，FDM）是一种多路复用技术，用于在通信系统中将多个独立的信号或数据流合并成一个复合信号，并通过不同的频率将它们传输到目标接收端。这个技术允许多个信号同时共享传输介质，而不会相互干扰。</p><p>以下是频分复用的一些关键概念和工作原理：</p><ol><li><p><strong>信号分离</strong>：</p><ul><li>在频分复用中，每个独立的信号或数据流被分配到不同的频率带宽上。</li><li>每个信号通常经过一个调制器（Modulator），将其转换成可以在特定频段内传输的信号。</li></ul></li><li><p><strong>合并和传输</strong>：</p><ul><li>合并器（Multiplexer）负责将所有分配给不同频率的信号合并成一个复合信号。</li><li>复合信号随后被传输到通信媒介（如电缆、光纤或空中传输）上，以便传输到接收端。</li></ul></li><li><p><strong>频率选择</strong>：</p><ul><li>接收端使用一个分频器（Demultiplexer）来选择特定频率带宽，并将其分离成独立的信号。</li><li>每个分离出的信号经过解调器（Demodulator）以还原原始数据或信息。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>频分复用允许多个信号并行传输，而不会干扰彼此。</li><li>它可以提高通信系统的效率，允许多个用户或应用程序共享通信通道，从而减少了通信系统的成本。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>频分复用广泛应用于各种通信系统，包括有线电视、广播、卫星通信、移动通信和计算机网络等。</li><li>在移动通信领域，不同的移动电话用户可以使用不同的频段，以便在同一时间共享相同的通信基础设施。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>频分复用的主要缺点是需要足够的频带宽来容纳所有信号。如果频带宽度不足，可能会导致信号重叠和干扰。</li><li>它也可能在信道的传输距离较长或带宽有限的情况下效率不高。</li></ul></li></ol><p>需要注意的是，频分复用是一种传统的多路复用技术，虽然仍然在一些应用中广泛使用，但在一些现代通信系统中，例如数字通信和光纤通信，更高级的复用技术如时分复用（TDM）和码分复用（CDM）也得到了广泛应用。这些技术在提供高效、可靠通信方面具有重要作用。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>多路复用技术是一种将多个信号或数据流合并在一起并在共享传输媒体上同时传输它们的通信技术。这有助于有效地利用通信资源，以满足多个用户或应用程序的需求。以下是一些常用的多路复用技术：</p><ol><li><p><strong>时分复用（Time Division Multiplexing，TDM）</strong>：</p><ul><li>TDM将时间划分为一系列间隔，并在每个时间间隔内依次传输不同信号的部分。</li><li>这意味着每个信号占用独占的时间间隔，使得多个信号可以在共享传输媒体上传输，而不会相互干扰。</li><li>TDM常用于电话网络和数字通信系统中。</li></ul></li><li><p><strong>频分复用（Frequency Division Multiplexing，FDM）</strong>：</p><ul><li>FDM将频谱分成多个不同的频带，每个频带用于传输不同信号。</li><li>这允许多个信号以不同的频率并行传输，而不会相互干扰。</li><li>FDM广泛应用于广播、电视和一些无线通信系统中。</li></ul></li><li><p><strong>码分复用（Code Division Multiplexing，CDM）</strong>：</p><ul><li>CDM使用不同的编码序列来区分和合并多个信号。</li><li>不同的编码序列允许多个信号在相同的频带上传输，并且只有接收端使用正确的解码序列才能还原原始信号。</li><li>CDM用于CDMA（Code Division Multiple Access）等无线通信技术中。</li></ul></li><li><p><strong>波分复用（Wavelength Division Multiplexing，WDM）</strong>：</p><ul><li>WDM是一种光纤通信中常用的技术，它使用不同的光波长（波长）来传输多个独立的信号。</li><li>每个波长代表一个独立的通道，可以传输不同数据流。</li><li>WDM广泛应用于长距离光纤通信和光网络中。</li></ul></li><li><p><strong>码分多址（Code Division Multiple Access，CDMA）</strong>：</p><ul><li>CDMA是一种无线通信技术，允许多个用户在相同的频率范围内传输数据，而不会相互干扰。</li><li>每个用户使用唯一的编码序列，使接收端能够将特定用户的信号从混合信号中分离出来。</li><li>CDMA用于3G和4G移动通信网络中。</li></ul></li><li><p><strong>统计复用</strong>：</p><ul><li>统计复用技术根据信号的需求动态分配传输资源，以提高资源的利用率。</li><li>与固定分配不同，统计复用允许多个用户共享资源，但可能需要处理竞争和碰撞等问题。</li><li>统计复用广泛用于以太网和互联网通信中。</li></ul></li></ol><p>不同的多路复用技术适用于不同的通信场景和需求。选择正确的多路复用技术取决于网络设计的要求、资源可用性以及传输媒体的特性。这些技术在提高通信系统效率、增加容量和满足多用户需求方面都发挥了关键作用。</p><h2 id="第二章-1"><a href="#第二章-1" class="headerlink" title="第二章"></a>第二章</h2><h3 id="磁盘阵列技术-1"><a href="#磁盘阵列技术-1" class="headerlink" title="磁盘阵列技术"></a>磁盘阵列技术</h3><p>磁盘阵列技术是一种将多个物理硬盘驱动器组合在一起，以提高数据存储性能、冗余和容错能力的方法。以下是一些常用的磁盘阵列技术：</p><ol><li><p><strong>RAID 0（条带化）</strong>：</p><ul><li>RAID 0将多个硬盘驱动器组合成一个大的逻辑卷，数据分散存储在这些驱动器上。</li><li>提高性能，因为数据可以同时从多个驱动器读取或写入。</li><li>但没有冗余，如果一个驱动器故障，所有数据都会丢失。</li></ul></li><li><p><strong>RAID 1（镜像）</strong>：</p><ul><li>RAID 1使用两个硬盘驱动器，将相同的数据同时写入两个驱动器。</li><li>提供冗余，如果一个驱动器故障，数据仍然可以从另一个驱动器恢复。</li><li>但容量利用率较低，只有一半的容量可用于数据存储。</li></ul></li><li><p><strong>RAID 5</strong>：</p><ul><li>RAID 5使用至少三个硬盘驱动器，将数据和校验信息分散存储在这些驱动器上。</li><li>提供性能和冗余。如果一个驱动器故障，可以通过校验信息从其余的驱动器中重建数据。</li><li>容量和性能之间取得了一种平衡。</li></ul></li><li><p><strong>RAID 6</strong>：</p><ul><li>RAID 6类似于RAID 5，但使用了两个校验信息块，因此可以容忍两个硬盘驱动器的故障。</li><li>提供更高级别的容错能力，但对于小型阵列可能会有性能损失。</li></ul></li><li><p><strong>RAID 10（1+0）</strong>：</p><ul><li>RAID 10是将RAID 1和RAID 0组合在一起的方式。它至少需要四个硬盘驱动器。</li><li>提供了性能和冗余的最佳组合。数据被镜像并进行条带化。</li><li>可以容忍多个驱动器的故障。</li></ul></li><li><p><strong>JBOD（Just a Bunch Of Disks）</strong>：</p><ul><li>JBOD不是真正的RAID，而是将多个硬盘驱动器简单地组合成一个大的逻辑卷。</li><li>没有性能提升或冗余。每个驱动器故障都会导致数据丢失。</li></ul></li><li><p><strong>RAID 50和RAID 60</strong>：</p><ul><li>这些是RAID 5和RAID 6的条带化版本。它们提供更好的性能，但需要更多的硬盘驱动器。</li></ul></li><li><p><strong>RAID 7</strong>：</p><ul><li>RAID 7是一种硬件RAID，具有高级的安全性和性能功能。它通常用于企业级应用。</li></ul></li></ol><p>这些是一些常用的磁盘阵列技术。选择哪种技术取决于您的需求，包括性能、冗余、容量和预算。不同的RAID级别提供不同的权衡方案。    ，</p>]]></content>
    
    
    <summary type="html">🍔本文汇总计算机三级网络技术考试内容</summary>
    
    
    
    <category term="网络" scheme="https://momoao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://momoao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud</title>
    <link href="https://momoao.github.io/posts/202310090902.html"/>
    <id>https://momoao.github.io/posts/202310090902.html</id>
    <published>2023-09-10T10:19:03.000Z</published>
    <updated>2023-10-14T10:13:44.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p>微服务是一种软件架构风格，它是以专注于单一职责的很多小型项目为基础，组合出复杂的大型应用。</p><h2 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h2><h3 id="熟悉黑马商场"><a href="#熟悉黑马商场" class="headerlink" title="熟悉黑马商场"></a>熟悉黑马商场</h3><p><img src="../assets/image/SpringCloud_Image/image-20231014152011362.png" alt="image-20231014152011362"></p><h3 id="服务拆分细节"><a href="#服务拆分细节" class="headerlink" title="服务拆分细节"></a>服务拆分细节</h3><p><img src="../assets/image/SpringCloud_Image/image-20231014152035526.png" alt="image-20231014152035526"></p><p><img src="../assets/image/SpringCloud_Image/image-20231014165650644.png" alt="image-20231014165650644"></p><h3 id="拆分服务"><a href="#拆分服务" class="headerlink" title="拆分服务"></a>拆分服务</h3><p><img src="../assets/image/SpringCloud_Image/image-20231014165700501.png" alt="image-20231014165700501"></p><p><img src="../assets/image/SpringCloud_Image/image-20231014165729062.png" alt="image-20231014165729062"></p><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3>]]></content>
    
    
    <summary type="html">🥧本文汇总SpringCloud的基础知识点</summary>
    
    
    
    <category term="框架" scheme="https://momoao.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="SpringCloud" scheme="https://momoao.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>苍穹外卖课堂笔记</title>
    <link href="https://momoao.github.io/posts/202309291021.html"/>
    <id>https://momoao.github.io/posts/202309291021.html</id>
    <published>2023-08-29T10:19:03.000Z</published>
    <updated>2023-10-22T06:14:14.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="苍穹外卖课堂笔记"><a href="#苍穹外卖课堂笔记" class="headerlink" title="苍穹外卖课堂笔记"></a>苍穹外卖课堂笔记</h1><h2 id="数据怎么从前端传递到数据库中"><a href="#数据怎么从前端传递到数据库中" class="headerlink" title="数据怎么从前端传递到数据库中"></a>数据怎么从前端传递到数据库中</h2><p>将前端传过来的数据封装到employeeDTO中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//因为这个接口处理post请求，所以用的不是@GetMapping而是@PostMapping</span></span><br><span class="line"><span class="comment">//在文档中可以看见请求路径是/admin/employee，这个就是类上@RequestMapping指定的请求路径，所以这里不需要再加额外路径</span></span><br><span class="line">   <span class="meta">@PostMapping</span></span><br><span class="line">   <span class="comment">//加了这个注解，可以让基于Swagger的增强工具knife4j生成的接口文档中包含这个接口的名字</span></span><br><span class="line">   <span class="meta">@ApiOperation(&quot;新增员工&quot;)</span></span><br><span class="line"><span class="comment">//注解@RequestBody表示从HTTP请求主题中接收数据，并且将json格式转换为EmployeeLoginDTO格式</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeDTO employeeDTO)</span>&#123;</span><br><span class="line">       <span class="comment">//这里输出日志</span></span><br><span class="line">       log.info(<span class="string">&quot;新增员工&#123;&#125;&quot;</span>,employeeDTO);</span><br><span class="line">       <span class="comment">//将数据交个服务层处理</span></span><br><span class="line">       employeeService.save(employeeDTO);</span><br><span class="line">       <span class="comment">//后端返回给前端结果</span></span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这是服务层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 员工登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeLoginDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Employee <span class="title function_">login</span><span class="params">(EmployeeLoginDTO employeeLoginDTO)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增员工业务方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(EmployeeDTO employeeDTO)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是服务层接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口实现这里使用这个注解，用于标识这个类是一个服务类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">EmployeeService</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增员工</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(EmployeeDTO employeeDTO)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Employee用于接收EmployeeDTO中的数据</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 这里可以使用雪花算法生成ID</span></span><br><span class="line">        <span class="comment">//数据拷贝employee--&gt;EmployeeDTO</span></span><br><span class="line">        BeanUtils.copyProperties(employeeDTO,employee);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里还要设置一些employeeDTO不包含的属性，因为管理端填写的时候，这些数据不需要填写，而是应该自动生成</span></span><br><span class="line">        <span class="comment">// 设置账号状态</span></span><br><span class="line">        employee.setStatus(StatusConstant.ENABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置默认密码</span></span><br><span class="line">        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置当前记录的创建时间</span></span><br><span class="line">        employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">        employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 后期这里设置动态的记录创建人ID</span></span><br><span class="line">        <span class="comment">//设置当前记录创建人的id</span></span><br><span class="line">        employee.setCreateUser(<span class="number">10L</span>);</span><br><span class="line">        employee.setUpdateUser(<span class="number">10L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Mapper中的方法将数据添加到数据库中</span></span><br><span class="line">        employeeMapper.insert(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入员工数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, status, create_time, update_time, create_user, update_user) &quot; +</span></span><br><span class="line"><span class="meta">            &quot;values&quot;+</span></span><br><span class="line"><span class="meta">            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;passowrd&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Employee employee)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试时发现返回状态码401，说明需要身份认证，因为有jwt令牌校验这个功能，下面是检测是否有jwt的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sky.constant.JwtClaimsConstant;</span><br><span class="line"><span class="keyword">import</span> com.sky.properties.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> com.sky.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jwt令牌校验的拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenAdminInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">            log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是JwtProperties类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 配置文件在service模块的resources中</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;sky.jwt&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管理端员工生成jwt令牌相关配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String adminSecretKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> adminTtl;</span><br><span class="line">    <span class="keyword">private</span> String adminTokenName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户端微信用户生成jwt令牌相关配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userSecretKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> userTtl;</span><br><span class="line">    <span class="keyword">private</span> String userTokenName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在配置文件中可以看到配置，前端传来的请求头中存放令牌的变量是token，所以要在测试环境中设置全局参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sky:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="comment"># 设置jwt签名加密时使用的秘钥</span></span><br><span class="line">    <span class="attr">admin-secret-key:</span> <span class="string">itcast</span></span><br><span class="line">    <span class="comment"># 设置jwt过期时间</span></span><br><span class="line">    <span class="attr">admin-ttl:</span> <span class="number">7200000</span></span><br><span class="line">    <span class="comment"># 设置前端传递过来的令牌名称</span></span><br><span class="line">    <span class="attr">admin-token-name:</span> <span class="string">token</span></span><br></pre></td></tr></table></figure><p>在Apifox中可以看见请求头的全局Header参数中出现了刚才设置的token，可以设置启用或禁用</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20230923132826373.png" alt="image-20230923132826373"></p><p>再次测试，添加成功</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=<span class="language-ruby">=&gt;  <span class="title class_">Preparing</span>: insert into employee (name, username, password, phone, sex, id_number, status, create_time, update_time, create_user, update_user) values(<span class="string">?,</span><span class="string">?,</span><span class="string">?,</span><span class="string">?,</span><span class="string">?,</span><span class="string">?,</span><span class="string">?,</span><span class="string">?,</span><span class="string">?,</span><span class="string">?,</span><span class="string">?)</span></span></span><br><span class="line">=<span class="language-ruby">=&gt; <span class="title class_">Parameters</span>: 统划速据(<span class="title class_">String</span>), 康秀英(<span class="title class_">String</span>), e10adc3949ba59abbe56e057f20f883e(<span class="title class_">String</span>), <span class="number">18631344652</span>(<span class="title class_">String</span>), 女(<span class="title class_">String</span>), <span class="number">55</span>(<span class="title class_">String</span>), <span class="number">1</span>(<span class="title class_">Integer</span>), <span class="number">2023</span>-09-23<span class="symbol">T13:</span><span class="number">32</span><span class="symbol">:</span><span class="number">56.385214300</span>(<span class="title class_">LocalDateTime</span>), <span class="number">2023</span>-09-23<span class="symbol">T13:</span><span class="number">32</span><span class="symbol">:</span><span class="number">56.385214300</span>(<span class="title class_">LocalDateTime</span>), <span class="number">10</span>(<span class="title class_">Long</span>), <span class="number">10</span>(<span class="title class_">Long</span>)</span></span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure><p>返回给前端的响应体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="如果添加了重复username，后端出现了异常怎么处理"><a href="#如果添加了重复username，后端出现了异常怎么处理" class="headerlink" title="如果添加了重复username，后端出现了异常怎么处理"></a>如果添加了重复username，后端出现了异常怎么处理</h2><p>添加新用户时出现重复的用户名，结果返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#x27;康秀英&#x27;已经存在&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在全局异常处理器中添加处理指定错误的方法</p><ul><li>这里主要处理错误SQLIntegrityConstraintViolationException<ul><li>这个异常表示在执行数据库操作（如插入、更新或删除记录）时，违反了数据库的完整性约束条件。完整性约束条件是一种规则，用于确保数据库中的数据的一致性和准确性。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sky.constant.MessageConstant;</span><br><span class="line"><span class="keyword">import</span> com.sky.exception.BaseException;</span><br><span class="line"><span class="keyword">import</span> com.sky.result.Result;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLIntegrityConstraintViolationException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器，处理项目中抛出的业务异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获业务异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span><span class="params">(BaseException ex)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;异常信息：&#123;&#125;&quot;</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> Result.error(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">        <span class="comment">//如果错误信息中包含关键字“重复的键值对”</span></span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class="line">            String[] split = message.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//取到用户名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> split[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//使用信息常量封装msg</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> username + MessageConstant.ALREADY_EXISTS;</span><br><span class="line">            <span class="keyword">return</span> Result.error(msg);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(MessageConstant.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加新的异常处理之后程序就不会中止运行了</p><h2 id="怎么动态设置创建人id和修改人id"><a href="#怎么动态设置创建人id和修改人id" class="headerlink" title="怎么动态设置创建人id和修改人id"></a>怎么动态设置创建人id和修改人id</h2><p>客户端发起的每一次请求就是一个单独的线程</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20221111201922482.png" alt="image-20221111201922482"></p><p>把ThreadLocal封装成一个工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JWT校验成功后就将提取出的id存在线程中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="comment">//解析JWT，把信息放在Claims中</span></span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">            <span class="comment">//拿出Claims中存储的登录者的ID</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">            log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">            <span class="comment">//将ID存在本线程中</span></span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后在服务层的save（）将EmployeeDTO封装为完整的Employee时拿出ID并存入Employee即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增员工</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(EmployeeDTO employeeDTO)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 这里可以使用雪花算法生成ID</span></span><br><span class="line">        BeanUtils.copyProperties(employeeDTO,employee);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里还要设置一些employeeDTO不包含的属性，因为管理端填写的时候，这些数据不需要填写，而是应该自动生成</span></span><br><span class="line">        <span class="comment">// 设置账号状态</span></span><br><span class="line">        employee.setStatus(StatusConstant.ENABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置默认密码</span></span><br><span class="line">        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置当前记录的创建时间</span></span><br><span class="line">        employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">        employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 后期这里设置动态的记录创建人ID</span></span><br><span class="line">        <span class="comment">//设置当前记录创建人的id</span></span><br><span class="line">        employee.setCreateUser(BaseContext.getCurrentId());</span><br><span class="line">        employee.setUpdateUser(BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">        employeeMapper.insert(employee);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="实现员工分页查询"><a href="#实现员工分页查询" class="headerlink" title="实现员工分页查询"></a>实现员工分页查询</h2><p>封装对应的DTO，用于从前端接收数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeePageQueryDTO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//员工姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> page;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每页显示记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageSize;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用于后端给前端返回的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装分页查询结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total; <span class="comment">//总记录数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List records; <span class="comment">//当前页数据集合</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Controller中添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于分页查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//因为这里处理前端的数据并不是json格式，而是在地址栏中的参数，所以不适用@RequestBody来标识参数</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;员工分页查询&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;PageResult&gt; <span class="title function_">page</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;员工分页查询&quot;</span>);</span><br><span class="line">        <span class="type">PageResult</span> <span class="variable">pageResult</span> <span class="operator">=</span> employeeService.pageQuery(employeePageQueryDTO);</span><br><span class="line">        <span class="keyword">return</span> Result.success(pageResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在ServiceImpl中实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">pageQuery</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;</span><br><span class="line">    PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());</span><br><span class="line"></span><br><span class="line">    Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Mapper中定义具体的SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;Employee&gt; <span class="title function_">pageQuery</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span>;</span><br></pre></td></tr></table></figure><p>因为要使用动态参数，用注解的方式不方便设置，所以SQL写在xml文件中</p><p>在application.yml文件中开启扫描</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment">#mapper配置文件</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>发现查询出的时间格式不符合要求</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20230923165908787.png" alt="image-20230923165908787"></p><p>方法一：在属性上加注解就可以自动转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br></pre></td></tr></table></figure><p>方法二：在WebMvcConfiguration中将自己的消息转换器添加到队列中，并且设置为优先使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展MVC框架的消息转换器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个消息转换器对象</span></span><br><span class="line">        <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        <span class="comment">//为消息转换器设置一个对象转换器</span></span><br><span class="line">        converter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">        <span class="comment">//将自己的消息转换器加入到容易中</span></span><br><span class="line">        <span class="comment">//会放在消息转换器队列的最后，所以不设置优先级一般用不到</span></span><br><span class="line">        <span class="comment">//索引改为0，就会将自己的消息转换器排在第一位</span></span><br><span class="line">        converters.add(<span class="number">0</span>,converter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次查询发现时间格式方便阅读了</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20230923171726568.png" alt="image-20230923171726568"></p><h2 id="启用和禁用员工账号功能实现"><a href="#启用和禁用员工账号功能实现" class="headerlink" title="启用和禁用员工账号功能实现"></a>启用和禁用员工账号功能实现</h2><p>在controller层添加映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启用禁用员工账号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//在添加查询类的控制器时，返回值要指定泛型，因为有返回值</span></span><br><span class="line"><span class="comment">//地址栏参数注解</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;status/&#123;status&#125;&quot;)</span></span><br><span class="line"><span class="comment">//因为地址栏中的参数和方法中的参数名称一样，所以注解后的value可以不指定</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;启用禁用员工账号&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startOrStop</span><span class="params">(<span class="meta">@PathVariable(&quot;status&quot;)</span> Integer status,<span class="type">long</span> id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;启用禁用员工账号：&#123;&#125;&#123;&#125;&quot;</span>,status,id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO 这里可以联合前端实现一个状态切换失败的弹窗</span></span><br><span class="line">    <span class="keyword">return</span> employeeService.startOrStop(status,id);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务层实现</p><p>这里自主添加了额外功能：状态切换失败返回前端失败的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启用禁用员工账号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">startOrStop</span><span class="params">(Integer status, <span class="type">long</span> id)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 【自主添加功能】：状态切换失败提醒</span></span><br><span class="line">        <span class="comment">//先判断状态修改是否正确，这是前端更新数据不及时的解决办法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">status1</span> <span class="operator">=</span> employeeMapper.getStatusById(id);</span><br><span class="line">        <span class="keyword">if</span>(status1 == status)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;状态修改失败，可能原因：状态已处于禁用(或启用)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Employee employee = new Employee();</span></span><br><span class="line"><span class="comment">//        employee.setId(id);</span></span><br><span class="line"><span class="comment">//        employee.setStatus(status);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在Employee上使用@Builder注解后就可以使用下面这种方式构建对象</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> Employee.builder()</span><br><span class="line">                .status(status)</span><br><span class="line">                .id(id)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        employeeMapper.update(employee);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在EmployeeMapper.java文件中声明2个方法</p><p>1、更新数据，在xml中进行实现</p><p>2、通过id查status的方法，直接在java文件中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据主键动态修改属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Employee employee)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查出所有数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Select(&quot;select status from employee where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">Integer <span class="title function_">getStatusById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure><p>xml文件中动态实现更新，这样以后有需要update的操作时，就可以封装一个employee调用这个方法</p><p><strong>注意：这里的标签中的属性名和外面的属性名不一样，标签中使用的是java类中的属性名，外使用的是MySQL中表的列名</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    因为在配置文件中扫描了实体包，所以这里的类可以直接写名字而不写包名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Employee&quot;</span>&gt;</span></span><br><span class="line">        update employee</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name = #&#123;name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username = #&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password = #&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;phone != null&quot;</span>&gt;</span>phone = #&#123;phone&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span>&gt;</span>sex = #&#123;sex&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;idNumber != null&quot;</span>&gt;</span>id_number = #&#123;idNumber&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span>update_time = #&#123;updateTime&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateUser != null&quot;</span>&gt;</span>update_user = #&#123;updateUser&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span>status = #&#123;status&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编辑员工信息实现"><a href="#编辑员工信息实现" class="headerlink" title="编辑员工信息实现"></a>编辑员工信息实现</h2><h3 id="先根据id查所有信息"><a href="#先根据id查所有信息" class="headerlink" title="先根据id查所有信息"></a>先根据id查所有信息</h3><p>在controller中添加映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询员工信息&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Employee&gt; <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.getById(id);</span><br><span class="line">    <span class="keyword">return</span> Result.success(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务层实现方法</p><p>这里不想将密码也传回去，所以用*进行覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Employee <span class="title function_">getById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//查询所有数据，但是密码用****覆盖后再传给前段</span></span><br><span class="line">    Employee employee= employeeMapper.getById(id);</span><br><span class="line"></span><br><span class="line">    employee.setPassword(<span class="string">&quot;****&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mapper中实现方法</p><p>因为没有参数，所以直接使用注解实现即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">Employee <span class="title function_">getById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure><h3 id="在修改信息"><a href="#在修改信息" class="headerlink" title="在修改信息"></a>在修改信息</h3><p>在controller中添加映射</p><p>请求内容从前端的请求体中发送到后端，用EmployeeDTO封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping()</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;编辑员工信息&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeDTO employeeDTO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;编辑员工信息&#123;&#125;&quot;</span>,employeeDTO);</span><br><span class="line"></span><br><span class="line">    employeeService.update(employeeDTO);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务层中实现方法</p><p>使用数据拷贝将EmployeeDTO中的数据拷贝到Employee中，然后在手动添加几个属性值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(EmployeeDTO employeeDTO)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    <span class="comment">//属性拷贝</span></span><br><span class="line">    BeanUtils.copyProperties(employeeDTO,employee);</span><br><span class="line"></span><br><span class="line">    employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    <span class="comment">//在JWT令牌校验时就将令牌中的id取出，并存在了BaseContext中</span></span><br><span class="line">    employee.setUpdateUser(BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">    employeeMapper.update(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面<code>启用和禁用员工</code>部分中在xml中实现的update方法来进行更改</p><h2 id="分类管理功能实现"><a href="#分类管理功能实现" class="headerlink" title="分类管理功能实现"></a>分类管理功能实现</h2><h3 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h3><h4 id="新增分类"><a href="#新增分类" class="headerlink" title="新增分类"></a>新增分类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;新增分类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> CategoryDTO categoryDTO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;新增分类：&#123;&#125;&quot;</span>, categoryDTO);</span><br><span class="line">    categoryService.save(categoryDTO);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;分类分页查询&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;PageResult&gt; <span class="title function_">page</span><span class="params">(CategoryPageQueryDTO categoryPageQueryDTO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;分页查询：&#123;&#125;&quot;</span>, categoryPageQueryDTO);</span><br><span class="line">    <span class="type">PageResult</span> <span class="variable">pageResult</span> <span class="operator">=</span> categoryService.pageQuery(categoryPageQueryDTO);</span><br><span class="line">    <span class="keyword">return</span> Result.success(pageResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了自己封装的分页类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//全参构造</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total; <span class="comment">//总记录数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List records; <span class="comment">//当前页数据集合</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除分类"><a href="#删除分类" class="headerlink" title="删除分类"></a>删除分类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;删除分类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">deleteById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;删除分类：&#123;&#125;&quot;</span>, id);</span><br><span class="line">    categoryService.deleteById(id);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改分类"><a href="#修改分类" class="headerlink" title="修改分类"></a>修改分类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;修改分类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> CategoryDTO categoryDTO)</span>&#123;</span><br><span class="line">    categoryService.update(categoryDTO);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启用禁用分类"><a href="#启用禁用分类" class="headerlink" title="启用禁用分类"></a>启用禁用分类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;启用禁用分类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">startOrStop</span><span class="params">(<span class="meta">@PathVariable(&quot;status&quot;)</span> Integer status, Long id)</span>&#123;</span><br><span class="line">    categoryService.startOrStop(status,id);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据类型查询分类"><a href="#根据类型查询分类" class="headerlink" title="根据类型查询分类"></a>根据类型查询分类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据类型查询分类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;List&lt;Category&gt;&gt; <span class="title function_">list</span><span class="params">(Integer type)</span>&#123;</span><br><span class="line">    List&lt;Category&gt; list = categoryService.list(type);</span><br><span class="line">    <span class="keyword">return</span> Result.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h3><h4 id="新增分类-1"><a href="#新增分类-1" class="headerlink" title="新增分类"></a>新增分类</h4><p>跟之前一样，把前端穿过的DTO拷贝到category中，然后手动添加其他数据，再将完整的category对象传输给Mapper层</p><p>新增分类的状态设置为<code>禁用</code>，因为刚添加的分类里并没有菜品和套餐，所以不能让用户看见，等添加了菜品和套餐在启用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(CategoryDTO categoryDTO)</span> &#123;</span><br><span class="line">    <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();</span><br><span class="line">    <span class="comment">//属性拷贝</span></span><br><span class="line">    BeanUtils.copyProperties(categoryDTO, category);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分类状态默认为禁用状态0</span></span><br><span class="line">    category.setStatus(StatusConstant.DISABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置创建时间、修改时间、创建人、修改人</span></span><br><span class="line">    category.setCreateTime(LocalDateTime.now());</span><br><span class="line">    category.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    category.setCreateUser(BaseContext.getCurrentId());</span><br><span class="line">    category.setUpdateUser(BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">    categoryMapper.insert(category);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><p>这里使用PageHelper进行辅助</p><p>这个类的作用是，在调用<code>startPage()</code>方法后，在下一条本线程执行的SQL语句中<strong>自动添加limit</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">pageQuery</span><span class="params">(CategoryPageQueryDTO categoryPageQueryDTO)</span> &#123;</span><br><span class="line">    PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());</span><br><span class="line">    <span class="comment">//下一条sql进行分页，自动加入limit关键字分页</span></span><br><span class="line">    Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(page.getTotal(), page.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用自己做的DTO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryPageQueryDTO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> page;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每页记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分类类型 1菜品分类  2套餐分类</span></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除分类-1"><a href="#删除分类-1" class="headerlink" title="删除分类"></a>删除分类</h4><p>这里在调用<code>分类Mapper</code>之前，会先使用菜品Mapper和套餐Mapper判断是否包含菜品或套餐，如果有，就不进行删除操作，抛出错误</p><p>比如：酒水饮料（分类）下有王老吉（菜品），那酒水饮料（分类）就不能删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//查询当前分类是否关联了菜品，如果关联了就抛出业务异常</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> dishMapper.countByCategoryId(id);</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//当前分类下有菜品，不能删除</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DeletionNotAllowedException</span>(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前分类是否关联了套餐，如果关联了就抛出业务异常</span></span><br><span class="line">    count = setmealMapper.countByCategoryId(id);</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//当前分类下有菜品，不能删除</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DeletionNotAllowedException</span>(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除分类数据</span></span><br><span class="line">    categoryMapper.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改分类-1"><a href="#修改分类-1" class="headerlink" title="修改分类"></a>修改分类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(CategoryDTO categoryDTO)</span> &#123;</span><br><span class="line">    <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Category</span>();</span><br><span class="line">    BeanUtils.copyProperties(categoryDTO,category);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置修改时间、修改人</span></span><br><span class="line">    category.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    category.setUpdateUser(BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">    categoryMapper.update(category);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启用禁用分类-1"><a href="#启用禁用分类-1" class="headerlink" title="启用禁用分类"></a>启用禁用分类</h4><p>因为<code>update()</code>需要完整的Category对象，所以就算只改一个status，也要封装出一个完整的Category对象来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startOrStop</span><span class="params">(Integer status, Long id)</span> &#123;</span><br><span class="line">    <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> Category.builder()</span><br><span class="line">            .id(id)</span><br><span class="line">            .status(status)</span><br><span class="line">            .updateTime(LocalDateTime.now())</span><br><span class="line">            .updateUser(BaseContext.getCurrentId())</span><br><span class="line">            .build();</span><br><span class="line">    categoryMapper.update(category);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据类型查询分类-1"><a href="#根据类型查询分类-1" class="headerlink" title="根据类型查询分类"></a>根据类型查询分类</h4><p>类型有：菜品分类（1）和套餐分类（2）</p><p>所以传入的数据可能是1或者2，根据这个从表中查出type = ？的并且status = 1的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">list</span><span class="params">(Integer type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> categoryMapper.list(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mapper层"><a href="#Mapper层" class="headerlink" title="Mapper层"></a>Mapper层</h3><h4 id="CategoryMapper"><a href="#CategoryMapper" class="headerlink" title="CategoryMapper"></a>CategoryMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.Page;</span><br><span class="line"><span class="keyword">import</span> com.sky.enumeration.OperationType;</span><br><span class="line"><span class="keyword">import</span> com.sky.dto.CategoryPageQueryDTO;</span><br><span class="line"><span class="keyword">import</span> com.sky.entity.Category;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +</span></span><br><span class="line"><span class="meta">            &quot; VALUES&quot; +</span></span><br><span class="line"><span class="meta">            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Category category)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> categoryPageQueryDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Page&lt;Category&gt; <span class="title function_">pageQuery</span><span class="params">(CategoryPageQueryDTO categoryPageQueryDTO)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除分类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id修改分类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Category category)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类型查询分类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Category&gt; <span class="title function_">list</span><span class="params">(Integer type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DishMapper"><a href="#DishMapper" class="headerlink" title="DishMapper"></a>DishMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据分类id查询菜品数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> categoryId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)</span></span><br><span class="line">    Integer <span class="title function_">countByCategoryId</span><span class="params">(Long categoryId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SetmealMapper"><a href="#SetmealMapper" class="headerlink" title="SetmealMapper"></a>SetmealMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SetmealMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据分类id查询套餐的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)</span></span><br><span class="line">    Integer <span class="title function_">countByCategoryId</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CategoryMapper-xml"><a href="#CategoryMapper-xml" class="headerlink" title="CategoryMapper.xml"></a>CategoryMapper.xml</h4><p>因为在服务层的方法中，调用Mapper层的<code>pageQuery()</code> 之前使用了PageHelper进行了limit的自动添加，所以这里可以不使用limit</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sky.mapper.CategoryMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;pageQuery&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sky.entity.Category&quot;</span>&gt;</span></span><br><span class="line">        select * from category</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type != null&quot;</span>&gt;</span></span><br><span class="line">                and type = #&#123;type&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">        order by sort asc , create_time desc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span></span><br><span class="line">        update category</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type != null&quot;</span>&gt;</span></span><br><span class="line">                type = #&#123;type&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                name = #&#123;name&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sort != null&quot;</span>&gt;</span></span><br><span class="line">                sort = #&#123;sort&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">                status = #&#123;status&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span></span><br><span class="line">                update_time = #&#123;updateTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateUser != null&quot;</span>&gt;</span></span><br><span class="line">                update_user = #&#123;updateUser&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span></span><br><span class="line">        select * from category</span><br><span class="line">        where status = 1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;type != null&quot;</span>&gt;</span></span><br><span class="line">            and type = #&#123;type&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        order by sort asc,create_time desc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="公共字段字段填充实现"><a href="#公共字段字段填充实现" class="headerlink" title="公共字段字段填充实现"></a>公共字段字段填充实现</h2><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20230925172910327.png" alt="image-20230925172910327"></p><p>先创建注解，用于传值（Update or Insert）和标记需要进行公共字段填充的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">//后期更改操作比较多，所以注解默认值是UPDATE</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> OperationType.UPDATE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义切面类</p><ul><li>切入点<ul><li>指明需要切入的方法<ul><li><code>execution()</code>：这是切点表达式的一部分，表示匹配方法执行的规则。</li><li><code>*</code>：表示匹配任意返回类型的方法。<code>*</code> 是通配符，表示不限定方法的返回类型。</li><li><code>com.sky.mapper.*</code>：表示匹配 <code>com.sky.mapper</code> 包下的所有类。</li><li><code>*.*(..)</code>：表示匹配这些类中的所有方法，而 <code>..</code> 表示匹配任意参数类型和个数的方法。</li></ul></li><li>&amp;&amp;后指明了要用某个注解进行标记才行</li></ul></li><li>@Before(“autoFillPointCut()”)<ul><li>在切点方法执行之前需要执行的</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFillPointCut</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，在通知中进行公共字段的赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;autoFillPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;开始进行公共字段的填充！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取被拦截的方法的数据库操作类型(注解的值)</span></span><br><span class="line">        <span class="comment">//获取方法签名</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature)joinPoint.getSignature();<span class="comment">//方法签名对象</span></span><br><span class="line">        <span class="comment">//从方法签名中获取方法，在获取指定的注解</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);<span class="comment">//获得方法上的注解对象</span></span><br><span class="line">        <span class="comment">//从注解中获取值</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();<span class="comment">//获取数据库操作类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前被拦截方法的参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="literal">null</span> || args.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备赋值的数据</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据不同的操作类型，为对应的属性赋值</span></span><br><span class="line">        <span class="keyword">if</span>(operationType == OperationType.INSERT)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里的方法名用了常量</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过反射为对象属性赋值</span></span><br><span class="line">                setCreateTime.invoke(entity,now);</span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setCreateUser.invoke(entity,currentId);</span><br><span class="line">                setUpdateUser.invoke(entity,currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operationType == OperationType.UPDATE)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过反射为对象属性赋值</span></span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setUpdateUser.invoke(entity,currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mapper中进行使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoFill(value = OperationType.INSERT)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure><h2 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h2><h3 id="配置阿里云OSS服务"><a href="#配置阿里云OSS服务" class="headerlink" title="配置阿里云OSS服务"></a>配置阿里云OSS服务</h3><ul><li><p>总结：</p><ul><li><p>写个<code>属性类</code>并使用这三个注解来让spring自动配置yml文件中的内容，并将AliOssProperties对象加载到容器中</p><ul><li><p>（先写配置类，这样在写yml文件时会有代码提示功能）</p></li><li><p>```<br>@Component<br>@ConfigurationProperties(prefix = “sky.alioss”)<br>@Data</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-   写个`工具类`里面封装好需要用的方法</span><br><span class="line"></span><br><span class="line">    -   ```java</span><br><span class="line">        @Data</span><br><span class="line">        @AllArgsConstructor</span><br><span class="line">        @Slf4j</span><br></pre></td></tr></table></figure></li></ul></li><li><p>写个<code>配置类</code></p><ul><li>```java<br>@Configuration<br>@Slf4j<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -   ![未命名文件](../assets/image/<span class="variable">%E8</span><span class="variable">%8</span>B<span class="variable">%8</span>D<span class="variable">%E7</span><span class="variable">%A9</span><span class="variable">%B9</span><span class="variable">%E5</span><span class="variable">%A4</span><span class="variable">%96</span><span class="variable">%E5</span><span class="variable">%8</span>D<span class="variable">%96</span><span class="variable">%E8</span><span class="variable">%AF</span><span class="variable">%BE</span><span class="variable">%E5</span><span class="variable">%A0</span><span class="variable">%82</span><span class="variable">%E7</span><span class="variable">%AC</span><span class="variable">%94</span><span class="variable">%E8</span><span class="variable">%AE</span><span class="variable">%B0_Image</span>/<span class="variable">%E6</span><span class="variable">%9</span>C<span class="variable">%AA</span><span class="variable">%E5</span><span class="variable">%91</span><span class="variable">%BD</span><span class="variable">%E5</span><span class="variable">%90</span><span class="variable">%8</span>D<span class="variable">%E6</span><span class="variable">%96</span><span class="variable">%87</span><span class="variable">%E4</span><span class="variable">%BB</span><span class="variable">%B6.png</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为有这个属性类的存在，所以在添加application.yml文件的时候有代码提示功能</span><br><span class="line"></span><br><span class="line">并且会将类中的驼峰命名法自动改为`-`分割的写法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="title">@Component</span></span><br><span class="line"><span class="title">@ConfigurationProperties</span>(<span class="keyword">prefix</span> <span class="operator">=</span> <span class="string">&quot;sky.alioss&quot;</span>)</span><br><span class="line"><span class="title">@Data</span></span><br><span class="line">public class AliOssProperties &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String endpoint<span class="comment">;</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId<span class="comment">;</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret<span class="comment">;</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName<span class="comment">;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>配置pom文件</p><p>这里采用的写法是将版本号与工件名分开的写法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aliyun.sdk.oss</span>&gt;</span>3.10.2<span class="tag">&lt;/<span class="name">aliyun.sdk.oss</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jaxb-api</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">jaxb-api</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;aliyun.sdk.oss&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jaxb-api&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>光标悬浮在控制台右上角的头像，可以看见AccessKey，来获得访问密钥</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sky:</span></span><br><span class="line">  <span class="attr">alioss:</span></span><br><span class="line">    <span class="attr">access-key-id:</span> <span class="string">。。。</span></span><br><span class="line">    <span class="attr">access-key-secret:</span> <span class="string">。。。</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">oss-cn-beijing.aliyuncs.com</span></span><br><span class="line">    <span class="attr">bucket-name:</span> <span class="string">cangqiong-momoao</span></span><br></pre></td></tr></table></figure><p>准备工具类，在文件上传时可以直接调用工具类中的方法</p><ul><li>upload()方法作用：<ul><li>先确保指定的桶空间是可以访问的；如果访问不到，就会在控制台输出错误信息</li><li>如果能访问到，就会返回根据桶空间生成的访问文件的URL地址（<code>https://BucketName.Endpoint/ObjectName</code>）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.ClientException;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSS;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSClientBuilder;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSException;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="type">byte</span>[] bytes, String objectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">            ossClient.putObject(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">            System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径规则 https://BucketName.Endpoint/ObjectName</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line">        stringBuilder</span><br><span class="line">                .append(bucketName)</span><br><span class="line">                .append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                .append(endpoint)</span><br><span class="line">                .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .append(objectName);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;文件上传到:&#123;&#125;&quot;</span>, stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用配置类，将容器中的AliOssProperties对象作为参数，将AliOssProperties对象中的信息封装到AliOssUtil对象中，并将AliOssUtil对象加载到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类</span></span><br><span class="line"><span class="comment"> * 用于配置AliOssUtil对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//确保容器中只有一个AliOssUtil对象</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> AliOssUtil <span class="title function_">aliOssUtil</span><span class="params">(AliOssProperties ali)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始创建阿里云文件上传工具类对象:&#123;&#125;&quot;</span>,ali);</span><br><span class="line">        <span class="type">AliOssUtil</span> <span class="variable">aliOssUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliOssUtil</span>(ali.getEndpoint(), ali.getAccessKeyId(), ali.getAccessKeySecret(), ali.getBucketName());</span><br><span class="line">        <span class="keyword">return</span> aliOssUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件上传接口开发"><a href="#文件上传接口开发" class="headerlink" title="文件上传接口开发"></a>文件上传接口开发</h3><p>编写接口<code>@PostMapping(&quot;/upload&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/common&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;通用接口&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliOssUtil aliOssUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;文件上传&quot;)</span></span><br><span class="line">    <span class="comment">//这里的参数名为file和前端要保持一致</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;文件上传：&#123;&#125;&quot;</span>,file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//截取 . 及其之后的内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用UUID来生成一个编号，在加上文件扩展名，这样就不会重名了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extension;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用upload()获得访问这个文件的URL地址</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> aliOssUtil.upload(file.getBytes(), objectName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//返回给前端成功的URL地址</span></span><br><span class="line">            <span class="keyword">return</span> Result.success(filePath);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;文件上传失败：&#123;&#125;&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增菜品接口开发"><a href="#新增菜品接口开发" class="headerlink" title="新增菜品接口开发"></a>新增菜品接口开发</h3><p>控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/dish&quot;)</span></span><br><span class="line"><span class="meta">@Api(&quot;菜品相关接口&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishService dishService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增菜品&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> DishDTO dishDTO)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;新增菜品：&#123;&#125;&quot;</span>,dishDTO);</span><br><span class="line">        </span><br><span class="line">        dishService.saveWithFlavor(dishDTO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层</p><p>因为DishDTO中有菜品的数据和口味的数据（List<DishFlavor>），所以要取出，并分别插入不同的表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DishService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishMapper dishMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishFlavorMapper dishFlavorMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithFlavor</span><span class="params">(DishDTO dishDTO)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将DTO中需要插入到dish表中的数据拷贝出来</span></span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">        BeanUtils.copyProperties(dishDTO,dish);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        dishMapper.insert(dish);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取insert语句生成的主键值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> dish.getId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对口味表进行插入</span></span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();</span><br><span class="line">        <span class="keyword">if</span>(flavors != <span class="literal">null</span> &amp;&amp; flavors.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            flavors.forEach(dishFlavor -&gt; &#123;</span><br><span class="line">                dishFlavor.setDishId(dishId);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向口味表插入n条数据</span></span><br><span class="line">            dishFlavorMapper.insertBatch(flavors);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入菜品数据"><a href="#插入菜品数据" class="headerlink" title="插入菜品数据"></a>插入菜品数据</h4><p>添加一个insert()方法，使用@AutoFill自动填写公共字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据分类id查询菜品数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> categoryId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)</span></span><br><span class="line">    Integer <span class="title function_">countByCategoryId</span><span class="params">(Long categoryId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AutoFill(OperationType.INSERT)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Dish dish)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml文件</p><ul><li>insert标签中的属性<ul><li>useGeneratedKeys=”true”<ul><li>自动生成主键</li><li>这通常在插入数据后需要获取自动生成的主键值时使用。</li></ul></li><li>keyProperty=”id”<ul><li>将自动生成的键值赋值给哪个属性</li><li>因为方法参数是一个Dish对象，所以生成的键赋值给这个对象Id属性</li></ul></li><li>所以在服务层中使用<code>Long dishId = dish.getId();</code>可以获取Dish表中此条记录的主键，用于在Flavor表中的<code>dish_id</code>列</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sky.mapper.DishMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into dish(name, category_id, price, image, description, create_time, update_time, create_user, update_user,status)</span><br><span class="line">            values</span><br><span class="line">                (#&#123;name&#125;,#&#123;categoryId&#125;,#&#123;price&#125;,#&#123;image&#125;,#&#123;description&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="插入口味数据"><a href="#插入口味数据" class="headerlink" title="插入口味数据"></a>插入口味数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishFlavorMapper</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量插入口味数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flavors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBatch</span><span class="params">(List&lt;DishFlavor&gt; flavors)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>foreach</code>遍历集合<code>flavors</code>，每次取出的对象命名为<code>df</code>，并且用<code>，</code>作为拼接的分割符</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sky.mapper.DishFlavorMapper&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBatch&quot;</span>&gt;</span></span><br><span class="line">        insert into dish_flavor (dish_id, name, value) VALUES</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;flavors&quot;</span> <span class="attr">item</span>=<span class="string">&quot;df&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            (#&#123;df.dishId&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="菜品分页查询"><a href="#菜品分页查询" class="headerlink" title="菜品分页查询"></a>菜品分页查询</h2><p>前端传过来的DTO</p><p><code>page</code>和<code>pageSize</code>用来指定查询的页数和大小</p><p><code>name</code>：查询菜品的名称</p><p><code>categoryId</code>：分类的ID</p><p><code>status</code>：启用状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishPageQueryDTO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分类id</span></span><br><span class="line">    <span class="keyword">private</span> Integer categoryId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态 0表示禁用 1表示启用</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器层</p><p>依旧使用<code>PageResult</code>来向前端放回数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;菜品分页查询&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;PageResult&gt; <span class="title function_">page</span><span class="params">(DishPageQueryDTO dishPageQueryDTO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;菜品分页查询：&#123;&#125;&quot;</span>,dishPageQueryDTO);</span><br><span class="line">    PageResult pageResult= dishService.pageQuery(dishPageQueryDTO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success(pageResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层</p><p>使用<code>PageHelper</code>来辅助生成SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜品分页查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dishPageQueryDTO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">pageQuery</span><span class="params">(DishPageQueryDTO dishPageQueryDTO)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里指定查询的页数，在执行SQL语句时就会自动填充limit了</span></span><br><span class="line">    PageHelper.startPage(dishPageQueryDTO.getPage(),dishPageQueryDTO.getPageSize());</span><br><span class="line"></span><br><span class="line">    Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(page.getTotal(),page.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapper层</p><p>返回类型是DishVO，因为前端需要的数据从两个表中获取</p><p>里面封装的都是前端需要的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishVO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//菜品名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//菜品分类id</span></span><br><span class="line">    <span class="keyword">private</span> Long categoryId;</span><br><span class="line">    <span class="comment">//菜品价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line">    <span class="comment">//描述信息</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">//0 停售 1 起售</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">    <span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="comment">//菜品关联的口味</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;DishFlavor&gt; flavors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Integer copies;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dishPageQueryDTO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Page&lt;DishVO&gt; <span class="title function_">pageQuery</span><span class="params">(DishPageQueryDTO dishPageQueryDTO)</span>;</span><br></pre></td></tr></table></figure><p>​    链接两个表查询数据，并判断name、categoryId、categoryId数据是否为空，最后用create_time降序排列</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;pageQuery&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sky.vo.DishVO&quot;</span>&gt;</span></span><br><span class="line">    select d.* , c.name as categoryName from dish d left outer join category c on d.category_id = c.id</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            and d.name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;categoryId != null&quot;</span>&gt;</span></span><br><span class="line">            and d.category_id = #&#123;categoryId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            and d.status = #&#123;status&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    order by d.create_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="删除菜品"><a href="#删除菜品" class="headerlink" title="删除菜品"></a>删除菜品</h2><ul><li>业务规则<ul><li>一次可以删一个或多个</li><li>起售的不能删除</li><li>被套餐关联的菜品不能删除</li><li>删除菜品后，关联的口味数据也需要删除</li></ul></li></ul><p>控制器层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;菜品批量删除&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;菜品批量删除：&#123;&#125;&quot;</span>,ids);</span><br><span class="line"></span><br><span class="line">    dishService.deleteBatch(ids);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层</p><p>先判断是否可以删除，如果不可以就抛出错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜品批量删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBatch</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前菜品是否可以删除</span></span><br><span class="line">    <span class="comment">//1、是否起售中</span></span><br><span class="line">    <span class="keyword">for</span> (Long id : ids) &#123;</span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> dishMapper.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (dish.getStatus() == StatusConstant.ENABLE)&#123;</span><br><span class="line">            <span class="comment">//当前菜品起售中</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DeletionNotAllowedException</span>(MessageConstant.DISH_ON_SALE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、是否包含在套餐内</span></span><br><span class="line">    List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);</span><br><span class="line">    <span class="keyword">if</span> (setmealIds != <span class="literal">null</span> &amp;&amp; setmealIds.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//当前套餐关联了，不能删除</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DeletionNotAllowedException</span>(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以删除</span></span><br><span class="line">    <span class="keyword">for</span> (Long id : ids) &#123;</span><br><span class="line">        <span class="comment">//1、删除菜品数据</span></span><br><span class="line">        dishMapper.deleteById(id);</span><br><span class="line">        <span class="comment">//2、删除关联的口味数据</span></span><br><span class="line">        dishFlavorMapper.deleteByDishId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SetmealDishMapper</p><p>查询出字符串中所有包含的id对应的套餐</p><ul><li>其中<ul><li>open：代表以…开头</li><li>close：代表以…结尾</li></ul></li></ul><p>因为in后的数据要包含在<code>()</code>内</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getSetmealIdsByDishIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">    select setmeal_id from setmeal_dish where dish_id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;dishIds&quot;</span> <span class="attr">item</span>=<span class="string">&quot;dishId&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;dishId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DishMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete(&quot;delete from dish where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure><p>DishFlavorMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete(&quot;delete from dish_flavor where dish_id = #&#123;dishId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByDishId</span><span class="params">(Long dishId)</span>;</span><br></pre></td></tr></table></figure><p>优化</p><p>在确认删除的时候，要执行多条SQL，可能会有性能问题</p><p>所以整合为一条SQL</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231004163550807.png" alt="image-20231004163550807"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from dish where id in</span><br><span class="line">         <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">             #&#123;id&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h2><ul><li>业务分析<ul><li>根据id查询菜品</li><li>根据类型查询分类（已实现）</li><li>文件文件上传（已实现）</li><li>修改菜品</li></ul></li></ul><h3 id="根据id查询出菜品信息"><a href="#根据id查询出菜品信息" class="headerlink" title="根据id查询出菜品信息"></a>根据id查询出菜品信息</h3><p>控制器层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询菜品&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;DishVO&gt; <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;根据id查询菜品数据：&#123;&#125;&quot;</span>,id);</span><br><span class="line">    <span class="type">DishVO</span> <span class="variable">dishVO</span> <span class="operator">=</span> dishService.getByIdWithFlavor(id);</span><br><span class="line">    <span class="keyword">return</span> Result.success(dishVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层</p><p>查询出的数据封装到VO中在返回给前端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查询菜品和口味数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DishVO <span class="title function_">getByIdWithFlavor</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//根据id查询菜品数据</span></span><br><span class="line">    <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> dishMapper.getById(id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据菜品id查询口味数据</span></span><br><span class="line">    List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装到DishVO中</span></span><br><span class="line">    <span class="type">DishVO</span> <span class="variable">dishVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishVO</span>();</span><br><span class="line">    BeanUtils.copyProperties(dish,dishVO);</span><br><span class="line">    dishVO.setFlavors(dishFlavors);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dishVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据id修改菜品信息和口味信息"><a href="#根据id修改菜品信息和口味信息" class="headerlink" title="根据id修改菜品信息和口味信息"></a>根据id修改菜品信息和口味信息</h3><p>控制器层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;修改菜品&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> DishDTO dishDTO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;修改菜品：&#123;&#125;&quot;</span>,dishDTO);</span><br><span class="line">    dishService.updateWithFlavor(dishDTO);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层</p><ul><li>菜品表<ul><li>使用update方法更新菜品信息</li></ul></li><li>口味表<ul><li>先把关联的口味数据都删除</li><li>在插入新的口味数据</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id修改菜品信息和口味信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dishDTO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithFlavor</span><span class="params">(DishDTO dishDTO)</span> &#123;</span><br><span class="line">    <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">    BeanUtils.copyProperties(dishDTO,dish);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    dishMapper.update(dish);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先把关联的口味数据都删除</span></span><br><span class="line">    dishFlavorMapper.deleteByDishId(dishDTO.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在插入新的口味数据</span></span><br><span class="line">    List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();</span><br><span class="line">    <span class="keyword">if</span>(flavors != <span class="literal">null</span> &amp;&amp; flavors.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        flavors.forEach(dishFlavor -&gt; &#123;</span><br><span class="line">            dishFlavor.setDishId(dishDTO.getId());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向口味表插入n条数据</span></span><br><span class="line">        dishFlavorMapper.insertBatch(flavors);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜品表的update方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update dish</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span>name = #&#123;name&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;categoryId != null&quot;</span>&gt;</span>categor_id = #&#123;categoryId&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;price != null&quot;</span>&gt;</span>price = #&#123;price&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;iamge != null&quot;</span>&gt;</span>iamge = #&#123;iamge&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null&quot;</span>&gt;</span>description = #&#123;description&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span>status = #&#123;status&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span>update_time = #&#123;updateTime&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateUser != null&quot;</span>&gt;</span>update_user = #&#123;updateUser&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Java中操作Redis"><a href="#Java中操作Redis" class="headerlink" title="Java中操作Redis"></a>Java中操作Redis</h2><h3 id="创建RedisTemplate对象"><a href="#创建RedisTemplate对象" class="headerlink" title="创建RedisTemplate对象"></a>创建RedisTemplate对象</h3><p>写在config包下</p><p>自己创建<code>RedisTemplate</code>的主要目的就是这个设置序列化器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RedisConnectionFactory是spring-boot-starter-data-redis提供的</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始创建redis模板对象...&quot;</span>);</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置redis的连接工厂对象</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置redis key的序列化器</span></span><br><span class="line">        <span class="comment">//这是Spring提供的</span></span><br><span class="line">        <span class="comment">//自己创建RedisTemplate的主要目的就是这个（设置序列化器）</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试类，获取操作不同数据类型的对象，然后使用这些对象来操作对应的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(redisTemplate);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用这个对象可以操作字符串类型的数据</span></span><br><span class="line">        <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//hash类型</span></span><br><span class="line">        <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//列表类型</span></span><br><span class="line">        <span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//集合类型</span></span><br><span class="line">        <span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//有序集合类型</span></span><br><span class="line">        <span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作字符串类型的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// set get setex setnx</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(city);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;1234&quot;</span>,<span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line">        redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作哈希类型的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//hset hget hdel hkeys hvals</span></span><br><span class="line">        <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">        hashOperations.put(<span class="string">&quot;100&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        hashOperations.put(<span class="string">&quot;100&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;100&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(keys);</span><br><span class="line"></span><br><span class="line">        <span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(values);</span><br><span class="line"></span><br><span class="line">        hashOperations.delete(<span class="string">&quot;100&quot;</span>,<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作列表类型的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//lpush lrange rpop llen</span></span><br><span class="line">        <span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">        listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">List</span> <span class="variable">mylist</span> <span class="operator">=</span> listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(mylist);</span><br><span class="line"></span><br><span class="line">        listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">        System.out.println(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作集合类型的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//sadd smembers scard sinter sunion srem</span></span><br><span class="line">        <span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">        setOperations.add(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        setOperations.add(<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">members</span> <span class="operator">=</span> setOperations.members(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(members);</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> setOperations.size(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">intersect</span> <span class="operator">=</span> setOperations.intersect(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">        System.out.println(intersect);</span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">union</span> <span class="operator">=</span> setOperations.union(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">        System.out.println(union);</span><br><span class="line"></span><br><span class="line">        setOperations.remove(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作有序集合类型的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//zadd zrange zincrby zrem</span></span><br><span class="line">        <span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">        zSetOperations.add(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        zSetOperations.add(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        zSetOperations.add(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">zset1</span> <span class="operator">=</span> zSetOperations.range(<span class="string">&quot;zset1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(zset1);</span><br><span class="line"></span><br><span class="line">        zSetOperations.incrementScore(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        zSetOperations.remove(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用命令操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//keys exists type del</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(keys);</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">set1</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">            <span class="type">DataType</span> <span class="variable">type</span> <span class="operator">=</span> redisTemplate.type(key);</span><br><span class="line">            System.out.println(type.name());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="店铺营业状态设置"><a href="#店铺营业状态设置" class="headerlink" title="店铺营业状态设置"></a>店铺营业状态设置</h2><ul><li>接口设计<ul><li>设置营业状态</li><li>管理端查询营业状态</li><li>用户端查询营业状态</li></ul></li></ul><h3 id="管理端"><a href="#管理端" class="headerlink" title="管理端"></a>管理端</h3><p>在admin包下的controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController(&quot;AdminShopController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/shop&quot;)</span></span><br><span class="line"><span class="meta">@Api( tags = &quot;店铺相关接口&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;SHOP_STATUS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;status&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;设置店铺营业状态&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">setStatus</span><span class="params">(<span class="meta">@PathVariable</span> Integer status)</span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;设置店铺营业状态：&#123;&#125;&quot;</span>,status == <span class="number">1</span> ? <span class="string">&quot;营业中&quot;</span> : <span class="string">&quot;打烊中&quot;</span>);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(KEY,status);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/status&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;查询店铺营业状态&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Integer&gt; <span class="title function_">getStatus</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer status= (Integer)redisTemplate.opsForValue().get(KEY);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;获取店铺营业状态：&#123;&#125;&quot;</span>,status == <span class="number">1</span> ? <span class="string">&quot;营业中&quot;</span> : <span class="string">&quot;打烊中&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户端"><a href="#用户端" class="headerlink" title="用户端"></a>用户端</h3><p>在user包下的controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController(&quot;UserShopController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/shop&quot;)</span></span><br><span class="line"><span class="meta">@Api( tags = &quot;店铺相关接口&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;SHOP_STATUS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/status&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;查询店铺营业状态&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Integer&gt; <span class="title function_">getStatus</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer status= (Integer)redisTemplate.opsForValue().get(KEY);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;获取店铺营业状态：&#123;&#125;&quot;</span>,status == <span class="number">1</span> ? <span class="string">&quot;营业中&quot;</span> : <span class="string">&quot;打烊中&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231006155915835.png" alt="image-20231006155915835"></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231006155827734.png" alt="image-20231006155827734"></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231006155840596.png" alt="image-20231006155840596"></p><h4 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h4><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231006155852772.png" alt="image-20231006155852772"></p><h3 id="入门案列"><a href="#入门案列" class="headerlink" title="入门案列"></a>入门案列</h3><p>导包的时候因为使用了以下包，所以不需要再特意导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;aliyun.sdk.oss&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发送Get请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGET</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//创建httpclient对象</span></span><br><span class="line">    <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建请求对象</span></span><br><span class="line">    <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://localhost:8080/user/shop/status&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送请求，接受响应结果</span></span><br><span class="line">    <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(httpGet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取服务端返回的状态码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> response.getStatusLine().getStatusCode();</span><br><span class="line">    System.out.println(<span class="string">&quot;服务端返回的状态码为：&quot;</span> + statusCode);</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> EntityUtils.toString(entity);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务端返回的数据为：&quot;</span> + body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    response.close();</span><br><span class="line">    httpClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送POST请求</p><ul><li><p>POST请求不止需要链接</p><ul><li><p>创建JSONObject对象，指定请求参数</p></li><li><p>封装到StringEntity对象中</p><ul><li>指定编码格式</li><li>指定数据类型</li></ul></li><li><p>设置到POST请求对象中</p><ul><li>```java<br>httpPost.setEntity(entity);<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试通过httpclient发送POST方式的请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Test</span><br><span class="line">    public void test<span class="constructor">POST()</span> throws Exception&#123;</span><br><span class="line">        <span class="comment">// 创建httpclient对象</span></span><br><span class="line">        CloseableHttpClient httpClient = <span class="module-access"><span class="module"><span class="identifier">HttpClients</span>.</span></span>create<span class="constructor">Default()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建请求对象</span></span><br><span class="line">        HttpPost httpPost = <span class="keyword">new</span> <span class="constructor">HttpPost(<span class="string">&quot;http://localhost:8080/admin/employee/login&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为是post请求，所以需要创建JSONObject</span></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> <span class="constructor">JSONObject()</span>;</span><br><span class="line">        jsonObject.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装到StringEntity中</span></span><br><span class="line">        StringEntity entity = <span class="keyword">new</span> <span class="constructor">StringEntity(<span class="params">jsonObject</span>.<span class="params">toString</span>()</span>);</span><br><span class="line">        <span class="comment">//指定请求编码方式</span></span><br><span class="line">        entity.set<span class="constructor">ContentEncoding(<span class="string">&quot;utf-8&quot;</span>)</span>;</span><br><span class="line">        <span class="comment">//数据格式</span></span><br><span class="line">        entity.set<span class="constructor">ContentType(<span class="string">&quot;application/json&quot;</span>)</span>;</span><br><span class="line">        <span class="comment">//设置到Post请求对象中</span></span><br><span class="line">        httpPost.set<span class="constructor">Entity(<span class="params">entity</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        CloseableHttpResponse response = httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析返回结果</span></span><br><span class="line">        <span class="built_in">int</span> statusCode = response.get<span class="constructor">StatusLine()</span>.get<span class="constructor">StatusCode()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;响应码为：&quot;</span> + statusCode);</span><br><span class="line"></span><br><span class="line">        HttpEntity entity1 = response.get<span class="constructor">Entity()</span>;</span><br><span class="line">        String body = <span class="module-access"><span class="module"><span class="identifier">EntityUtils</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">entity1</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;响应数据为：&quot;</span> + body);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        response.close<span class="literal">()</span>;</span><br><span class="line">        httpClient.close<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h2><p><a href="https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN">微信小程序官网介绍</a></p><h3 id="小程序目录结构"><a href="#小程序目录结构" class="headerlink" title="小程序目录结构"></a>小程序目录结构</h3><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231007094939232.png" alt="image-20231007094939232"></p><p>一个页面由四个文件组成</p><p>js和wxml文件是必须得</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231007094955412.png" alt="image-20231007094955412"></p><p>想添加更多的页需要更改app.json文件</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231007100323721.png" alt="image-20231007100323721"></p><h3 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h3><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231007195819972.png" alt="image-20231007195819972"></p><h2 id="支付功能"><a href="#支付功能" class="headerlink" title="支付功能"></a>支付功能</h2><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231010095452717.png" alt="image-20231010095452717"></p><h2 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h2><h3 id="corn表达式"><a href="#corn表达式" class="headerlink" title="corn表达式"></a>corn表达式</h3><p>cron表达式其实就是一个字符串，通过cron表达式可以定义任务触发的时间<br>构成规则：分为6或7个域，由空格分隔开，每个域代表一个含义<br>每个域的含义分别为：秒、分钟、小时、日、月、周、年(可选)</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231010100813951.png" alt="image-20231010100813951"></p><p>cron表达式在线生成器：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231010100917389.png" alt="image-20231010100917389"></p><h3 id="入门案列-1"><a href="#入门案列-1" class="headerlink" title="入门案列"></a>入门案列</h3><ul><li>导入maven坐标 spring-context（已存在）</li><li>启动类添加注解 @EnableScheduling 开启任务调度</li><li>自定义定时任务类</li></ul><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231010100933169.png" alt="image-20231010100933169"></p><ul><li>cron表示到某个时间点就触发<ul><li><code>&quot;0 * * * * ? &quot;</code>表示当秒为0时触发</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理超时订单的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 * * * * ? &quot;)</span> <span class="comment">//每分钟触发一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processTimeoutOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;定时处理超时订单：&#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now().plusMinutes(-<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select * from orders where status = ? and order_time &lt; (当前时间 - 15分钟)</span></span><br><span class="line">        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.PENDING_PAYMENT, time);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ordersList != <span class="literal">null</span> &amp;&amp; ordersList.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Orders orders : ordersList) &#123;</span><br><span class="line">                orders.setStatus(Orders.CANCELLED);</span><br><span class="line">                orders.setCancelReason(<span class="string">&quot;订单超时，自动取消&quot;</span>);</span><br><span class="line">                orders.setCancelTime(LocalDateTime.now());</span><br><span class="line">                orderMapper.update(orders);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理一直处于派送中状态的订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span> <span class="comment">//每天凌晨1点触发一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processDeliveryOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;定时处理处于派送中的订单：&#123;&#125;&quot;</span>,LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now().plusMinutes(-<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.DELIVERY_IN_PROGRESS, time);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ordersList != <span class="literal">null</span> &amp;&amp; ordersList.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Orders orders : ordersList) &#123;</span><br><span class="line">                orders.setStatus(Orders.COMPLETED);</span><br><span class="line">                orderMapper.update(orders);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send()&quot;</span>&gt;</span>发送消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;closeWebSocket()&quot;</span>&gt;</span>关闭连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> clientId = <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">substr</span>(<span class="number">2</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//判断当前浏览器是否支持WebSocket</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//连接WebSocket节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//创建对象之后会自动发送请求建立连接</span></span></span><br><span class="line"><span class="language-javascript">        websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080/ws/&quot;</span>+clientId);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;Not support websocket&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//连接发生错误的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    websocket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;error&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//连接成功建立的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    websocket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;连接成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//接收到消息的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    websocket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setMessageInnerHTML</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//连接关闭的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    websocket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;close&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//将消息显示在网页上</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">setMessageInnerHTML</span>(<span class="params">innerHTML</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;message&#x27;</span>).<span class="property">innerHTML</span> += innerHTML + <span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//发送消息</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> message = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;text&#x27;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        websocket.<span class="title function_">send</span>(message);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//关闭连接</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">closeWebSocket</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>处理请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放会话对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; sessionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：&quot;</span> + sid + <span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">        sessionMap.put(sid, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自客户端：&quot;</span> + sid + <span class="string">&quot;的信息:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(<span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开:&quot;</span> + sid);</span><br><span class="line">        sessionMap.remove(sid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToAllClient</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        Collection&lt;Session&gt; sessions = sessionMap.values();</span><br><span class="line">        <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//服务器向客户端发送消息</span></span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h3><h4 id="来单提醒"><a href="#来单提醒" class="headerlink" title="来单提醒"></a>来单提醒</h4><h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><ul><li>支付成功了<ul><li>因为是否支付成功是用户先知道的，所以由用户通知服务端支付成功了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付回调相关接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/notify&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayNotifyController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WeChatProperties weChatProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付成功回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/paySuccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paySuccessNotify</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> readData(request);</span><br><span class="line">        log.info(<span class="string">&quot;支付成功回调：&#123;&#125;&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">plainText</span> <span class="operator">=</span> decryptData(body);</span><br><span class="line">        log.info(<span class="string">&quot;解密后的文本：&#123;&#125;&quot;</span>, plainText);</span><br><span class="line"></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(plainText);</span><br><span class="line">        <span class="type">String</span> <span class="variable">outTradeNo</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;out_trade_no&quot;</span>);<span class="comment">//商户平台订单号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">transactionId</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;transaction_id&quot;</span>);<span class="comment">//微信支付交易号</span></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;商户平台订单号：&#123;&#125;&quot;</span>, outTradeNo);</span><br><span class="line">        log.info(<span class="string">&quot;微信支付交易号：&#123;&#125;&quot;</span>, transactionId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//业务处理，修改订单状态、来单提醒</span></span><br><span class="line">        orderService.paySuccess(outTradeNo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给微信响应</span></span><br><span class="line">        responseToWeixin(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">readData</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> request.getReader();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">decryptData</span><span class="params">(String body)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">resultObject</span> <span class="operator">=</span> JSON.parseObject(body);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">resource</span> <span class="operator">=</span> resultObject.getJSONObject(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ciphertext</span> <span class="operator">=</span> resource.getString(<span class="string">&quot;ciphertext&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> resource.getString(<span class="string">&quot;nonce&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">associatedData</span> <span class="operator">=</span> resource.getString(<span class="string">&quot;associated_data&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">AesUtil</span> <span class="variable">aesUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AesUtil</span>(weChatProperties.getApiV3Key().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//密文解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">plainText</span> <span class="operator">=</span> aesUtil.decryptToString(associatedData.getBytes(StandardCharsets.UTF_8),</span><br><span class="line">                nonce.getBytes(StandardCharsets.UTF_8),</span><br><span class="line">                ciphertext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> plainText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给微信响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">responseToWeixin</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        response.setStatus(<span class="number">200</span>);</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-type&quot;</span>, ContentType.APPLICATION_JSON.toString());</span><br><span class="line">        response.getOutputStream().write(JSONUtils.toJSONString(map).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        response.flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付成功，修改订单状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outTradeNo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paySuccess</span><span class="params">(String outTradeNo)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前登录用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据订单号查询当前用户的订单</span></span><br><span class="line">    <span class="type">Orders</span> <span class="variable">ordersDB</span> <span class="operator">=</span> orderMapper.getByNumberAndUserId(outTradeNo, userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据订单id更新订单的状态、支付方式、支付状态、结账时间</span></span><br><span class="line">    <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> Orders.builder()</span><br><span class="line">            .id(ordersDB.getId())</span><br><span class="line">            .status(Orders.TO_BE_CONFIRMED)</span><br><span class="line">            .payStatus(Orders.PAID)</span><br><span class="line">            .checkoutTime(LocalDateTime.now())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    orderMapper.update(orders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过websocket向客户端浏览器推送消息 type orderId content</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>,<span class="number">1</span>); <span class="comment">// 1表示来单提醒 2表示客户催单</span></span><br><span class="line">    map.put(<span class="string">&quot;orderId&quot;</span>,ordersDB.getId());</span><br><span class="line">    map.put(<span class="string">&quot;content&quot;</span>,<span class="string">&quot;订单号：&quot;</span> + outTradeNo);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(map);</span><br><span class="line">    webSocketServer.sendToAllClient(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户催单"><a href="#客户催单" class="headerlink" title="客户催单"></a>客户催单</h4><p>接口设计</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231022094555154.png" alt="image-20231022094555154"></p><h2 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231016160009430.png" alt="image-20231016160009430"></p><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>maven</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231016161533663.png" alt="image-20231016161533663"></p><h4 id="将数据写入excel"><a href="#将数据写入excel" class="headerlink" title="将数据写入excel"></a>将数据写入excel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//在内存中创建一个Excel文件</span></span><br><span class="line">    <span class="type">XSSFWorkbook</span> <span class="variable">excel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>();</span><br><span class="line">    <span class="comment">//在Excel文件中创建一个Sheet页</span></span><br><span class="line">    <span class="type">XSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> excel.createSheet(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    <span class="comment">//在Sheet中创建行对象,rownum编号从0开始</span></span><br><span class="line">    <span class="type">XSSFRow</span> <span class="variable">row</span> <span class="operator">=</span> sheet.createRow(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建单元格并且写入文件内容</span></span><br><span class="line">    <span class="comment">//这里的1代表第二行，</span></span><br><span class="line">    row.createCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">    row.createCell(<span class="number">2</span>).setCellValue(<span class="string">&quot;城市&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个新行</span></span><br><span class="line">    row = sheet.createRow(<span class="number">2</span>);</span><br><span class="line">    row.createCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    row.createCell(<span class="number">2</span>).setCellValue(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    row = sheet.createRow(<span class="number">3</span>);</span><br><span class="line">    row.createCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    row.createCell(<span class="number">2</span>).setCellValue(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过输出流将内存中的Excel文件写入到磁盘</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\info.xlsx&quot;</span>));</span><br><span class="line">    excel.write(out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    out.close();</span><br><span class="line">    excel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从excecl读出数据"><a href="#从excecl读出数据" class="headerlink" title="从excecl读出数据"></a>从excecl读出数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过POI读取Excel文件中的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\info.xlsx&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取磁盘上已经存在的Excel文件</span></span><br><span class="line">    <span class="type">XSSFWorkbook</span> <span class="variable">excel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>(in);</span><br><span class="line">    <span class="comment">//读取Excel文件中的第一个Sheet页</span></span><br><span class="line">    <span class="type">XSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> excel.getSheetAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Sheet中最后一行的行号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRowNum</span> <span class="operator">=</span> sheet.getLastRowNum();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= lastRowNum ; i++) &#123;</span><br><span class="line">        <span class="comment">//获得某一行</span></span><br><span class="line">        <span class="type">XSSFRow</span> <span class="variable">row</span> <span class="operator">=</span> sheet.getRow(i);</span><br><span class="line">        <span class="comment">//获得单元格对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cellValue1</span> <span class="operator">=</span> row.getCell(<span class="number">1</span>).getStringCellValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cellValue2</span> <span class="operator">=</span> row.getCell(<span class="number">2</span>).getStringCellValue();</span><br><span class="line">        System.out.println(cellValue1 + <span class="string">&quot; &quot;</span> + cellValue2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    in.close();</span><br><span class="line">    excel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目应用-1"><a href="#项目应用-1" class="headerlink" title="项目应用"></a>项目应用</h3><h4 id="controller-1"><a href="#controller-1" class="headerlink" title="controller"></a>controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出运营数据报表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/export&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;导出运营数据报表&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">(HttpServletResponse response)</span>&#123;</span><br><span class="line">    reportService.exportBusinessData(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service-1"><a href="#service-1" class="headerlink" title="service"></a>service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出运营数据报表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportBusinessData</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查询数据库，获取营业数据---查询最近30天的运营数据</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">dateBegin</span> <span class="operator">=</span> LocalDate.now().minusDays(<span class="number">30</span>);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">dateEnd</span> <span class="operator">=</span> LocalDate.now().minusDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询概览数据</span></span><br><span class="line">    <span class="type">BusinessDataVO</span> <span class="variable">businessDataVO</span> <span class="operator">=</span> workspaceService.getBusinessData(LocalDateTime.of(dateBegin, LocalTime.MIN), LocalDateTime.of(dateEnd, LocalTime.MAX));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 通过POI将数据写入到Excel文件中</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;template/运营数据报表模板.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//基于模板文件创建一个新的Excel文件</span></span><br><span class="line">        <span class="type">XSSFWorkbook</span> <span class="variable">excel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>(in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取表格文件的Sheet页</span></span><br><span class="line">        <span class="type">XSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> excel.getSheet(<span class="string">&quot;Sheet1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充数据--时间</span></span><br><span class="line">        sheet.getRow(<span class="number">1</span>).getCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;时间：&quot;</span> + dateBegin + <span class="string">&quot;至&quot;</span> + dateEnd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得第4行</span></span><br><span class="line">        <span class="type">XSSFRow</span> <span class="variable">row</span> <span class="operator">=</span> sheet.getRow(<span class="number">3</span>);</span><br><span class="line">        row.getCell(<span class="number">2</span>).setCellValue(businessDataVO.getTurnover());</span><br><span class="line">        row.getCell(<span class="number">4</span>).setCellValue(businessDataVO.getOrderCompletionRate());</span><br><span class="line">        row.getCell(<span class="number">6</span>).setCellValue(businessDataVO.getNewUsers());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得第5行</span></span><br><span class="line">        row = sheet.getRow(<span class="number">4</span>);</span><br><span class="line">        row.getCell(<span class="number">2</span>).setCellValue(businessDataVO.getValidOrderCount());</span><br><span class="line">        row.getCell(<span class="number">4</span>).setCellValue(businessDataVO.getUnitPrice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充明细数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> dateBegin.plusDays(i);</span><br><span class="line">            <span class="comment">//查询某一天的营业数据</span></span><br><span class="line">            <span class="type">BusinessDataVO</span> <span class="variable">businessData</span> <span class="operator">=</span> workspaceService.getBusinessData(LocalDateTime.of(date, LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获得某一行</span></span><br><span class="line">            row = sheet.getRow(<span class="number">7</span> + i);</span><br><span class="line">            row.getCell(<span class="number">1</span>).setCellValue(date.toString());</span><br><span class="line">            row.getCell(<span class="number">2</span>).setCellValue(businessData.getTurnover());</span><br><span class="line">            row.getCell(<span class="number">3</span>).setCellValue(businessData.getValidOrderCount());</span><br><span class="line">            row.getCell(<span class="number">4</span>).setCellValue(businessData.getOrderCompletionRate());</span><br><span class="line">            row.getCell(<span class="number">5</span>).setCellValue(businessData.getUnitPrice());</span><br><span class="line">            row.getCell(<span class="number">6</span>).setCellValue(businessData.getNewUsers());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 通过输出流将Excel文件下载到客户端浏览器</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        excel.write(out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        excel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231021094851446.png" alt="image-20231021094851446"></p><h2 id="Apache-ECahrts"><a href="#Apache-ECahrts" class="headerlink" title="Apache ECahrts"></a>Apache ECahrts</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>是一个流行的开源JavaScript图表库，用于在Web应用程序中创建交互式、动态和美观的数据可视化图表</p><h3 id="入门案例-1"><a href="#入门案例-1" class="headerlink" title="入门案例"></a>入门案例</h3><p>在绘图之前准备一个定义了宽高的DOM容器</p><p>用<code>document.getElementById(&#39;main&#39;)</code>获取到的元素初始化echarts对象</p><ul><li>定义一个option对象，设置其中的一些属性</li></ul><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231020200506545.png" alt="image-20231020200506545"></p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231020201025297.png" alt="image-20231020201025297"></p><h2 id="营业额统计"><a href="#营业额统计" class="headerlink" title="营业额统计"></a>营业额统计</h2><h3 id="controller-2"><a href="#controller-2" class="headerlink" title="controller"></a>controller</h3><p>从params中提取出两个参数，一个开始时间一个结束时间</p><p>统计这段时间里的每一天的订单数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/turnoverStatistics&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;营业额统计&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;TurnoverReportVO&gt; <span class="title function_">turnoverStatistics</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span>  LocalDate begin,</span></span><br><span class="line"><span class="params">        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;营业额数据统计：&#123;&#125;,&#123;&#125;&quot;</span>,begin,end);</span><br><span class="line">    <span class="keyword">return</span> Result.success(reportService.getTurnoverStatistics(begin,end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service-2"><a href="#service-2" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计指定时间区间内的营业额数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TurnoverReportVO <span class="title function_">getTurnoverStatistics</span><span class="params">(LocalDate begin, LocalDate end)</span> &#123;</span><br><span class="line">    <span class="comment">//当前集合用于存放从begin到end范围内的每天的日期</span></span><br><span class="line">    List&lt;LocalDate&gt; dateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    dateList.add(begin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!begin.equals(end)) &#123;</span><br><span class="line">        <span class="comment">//日期计算，计算指定日期的后一天对应的日期</span></span><br><span class="line">        begin = begin.plusDays(<span class="number">1</span>);</span><br><span class="line">        dateList.add(begin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放每天的营业额</span></span><br><span class="line">    List&lt;Double&gt; turnoverList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (LocalDate date : dateList) &#123;</span><br><span class="line">        <span class="comment">//查询date日期对应的营业额数据，营业额是指：状态为“已完成”的订单金额合计</span></span><br><span class="line">        <span class="comment">//这里的of用于拼接时间，将之前具体到天的时间后再跟上时分秒</span></span><br><span class="line">        <span class="comment">//LocalTime.MIN代表的就是（00:00:00）</span></span><br><span class="line">        <span class="comment">//LocalTime.MAX代表的是 23:59:59.999999999（纳秒）</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.of(date, LocalTime.MIN);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(date, LocalTime.MAX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将开始时间、结束时间、当天的营业额三个数据封装到map中</span></span><br><span class="line">        <span class="comment">// select sum(amount) from orders where order_time &gt; beginTime and order_time &lt; endTime and status = 5</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;begin&quot;</span>, beginTime);</span><br><span class="line">        map.put(<span class="string">&quot;end&quot;</span>, endTime);</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, Orders.COMPLETED);</span><br><span class="line">        <span class="comment">//这里将三项数据都传到mapper层中</span></span><br><span class="line">        <span class="type">Double</span> <span class="variable">turnover</span> <span class="operator">=</span> orderMapper.sumByMap(map);</span><br><span class="line">        <span class="comment">//确保SQL语句查询失败造成的turnover为null，所以这里判断一下</span></span><br><span class="line">        turnover = turnover == <span class="literal">null</span> ? <span class="number">0.0</span> : turnover;</span><br><span class="line">        <span class="comment">//这是存储营业额的List</span></span><br><span class="line">        turnoverList.add(turnover);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装返回结果</span></span><br><span class="line">    <span class="keyword">return</span> TurnoverReportVO</span><br><span class="line">            .builder()</span><br><span class="line">            .dateList(StringUtils.join(dateList, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .turnoverList(StringUtils.join(turnoverList, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    统计一定时间内的订单总量，返回Double型数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;sumByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Double&quot;</span>&gt;</span></span><br><span class="line">        select sum(amount) from orders</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">#         在进行一重判断，确保数据不为空时在写到SQL中</span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null&quot;</span>&gt;</span></span><br><span class="line">                and order_time <span class="symbol">&amp;gt;</span> #&#123;begin&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;end != null&quot;</span>&gt;</span></span><br><span class="line">                and order_time <span class="symbol">&amp;lt;</span> #&#123;end&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">                and status = #&#123;status&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="用户统计"><a href="#用户统计" class="headerlink" title="用户统计"></a>用户统计</h2><p>统计每天的用户新增数量和用户总量</p><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231020213356327.png" alt="image-20231020213356327"></p><h3 id="controller-3"><a href="#controller-3" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户统计</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/userStatistics&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;用户统计&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;UserReportVO&gt; <span class="title function_">userStatistics</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span>  LocalDate begin,</span></span><br><span class="line"><span class="params">        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;用户数据统计：&#123;&#125;,&#123;&#125;&quot;</span>,begin,end);</span><br><span class="line">    <span class="keyword">return</span> Result.success(reportService.getUserStatistics(begin,end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service-3"><a href="#service-3" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计指定时间区间内的用户数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> UserReportVO <span class="title function_">getUserStatistics</span><span class="params">(LocalDate begin, LocalDate end)</span> &#123;</span><br><span class="line">    <span class="comment">//存放从begin到end之间的每天对应的日期</span></span><br><span class="line">    List&lt;LocalDate&gt; dateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    dateList.add(begin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!begin.equals(end)) &#123;</span><br><span class="line">        begin = begin.plusDays(<span class="number">1</span>);</span><br><span class="line">        dateList.add(begin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放每天的新增用户数量 select count(id) from user where create_time &lt; ? and create_time &gt; ?</span></span><br><span class="line">    List&lt;Integer&gt; newUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放每天的总用户数量 select count(id) from user where create_time &lt; ?</span></span><br><span class="line">    List&lt;Integer&gt; totalUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (LocalDate date : dateList) &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.of(date, LocalTime.MIN);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(date, LocalTime.MAX);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//只设置结束时间，统计：截止到当天的总用户数量</span></span><br><span class="line">        map.put(<span class="string">&quot;end&quot;</span>, endTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总用户数量</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">totalUser</span> <span class="operator">=</span> userMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;begin&quot;</span>, beginTime);</span><br><span class="line">        <span class="comment">//新增用户数量</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">newUser</span> <span class="operator">=</span> userMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        totalUserList.add(totalUser);</span><br><span class="line">        newUserList.add(newUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装结果数据</span></span><br><span class="line">    <span class="keyword">return</span> UserReportVO</span><br><span class="line">            .builder()</span><br><span class="line">            .dateList(StringUtils.join(dateList, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .totalUserList(StringUtils.join(totalUserList, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .newUserList(StringUtils.join(newUserList, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapper-1"><a href="#mapper-1" class="headerlink" title="mapper"></a>mapper</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    当只传入结束时间时，统计的就是：截止到当天总用户数量--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    当传入开始时间和结束时间时，统计的就是：当天的新增用户数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        select count(id) from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null&quot;</span>&gt;</span></span><br><span class="line">                and create_time <span class="symbol">&amp;gt;</span> #&#123;begin&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;end != null&quot;</span>&gt;</span></span><br><span class="line">                and create_time <span class="symbol">&amp;lt;</span> #&#123;end&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="订单统计"><a href="#订单统计" class="headerlink" title="订单统计"></a>订单统计</h2><h3 id="controller-4"><a href="#controller-4" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单统计</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/ordersStatistics&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;订单统计&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;OrderReportVO&gt; <span class="title function_">ordersStatistics</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span>  LocalDate begin,</span></span><br><span class="line"><span class="params">        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;订单数据统计：&#123;&#125;,&#123;&#125;&quot;</span>,begin,end);</span><br><span class="line">    <span class="keyword">return</span> Result.success(reportService.getOrderStatistics(begin,end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service-4"><a href="#service-4" class="headerlink" title="service"></a>service</h3><ul><li><code>stream()</code> 方法将这个列表转换成一个流（Stream），这允许你对列表中的元素进行各种操作。</li><li><code>reduce</code> 操作是一个终端操作，它用来将流中的元素进行归约操作，本例中是求和操作。</li><li><code>Integer::sum</code> 是一个二元操作，表示将两个整数相加<ul><li>个操作会被应用到流中的所有元素，从左到右进行累积。这就是为什么你最终得到了这些整数的总和。</li></ul></li><li><code>get()</code> 方法用于获取终端操作的结果。在这个例子中，它会返回整数列表中所有元素的和作为结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计指定时间区间内的订单数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> OrderReportVO <span class="title function_">getOrderStatistics</span><span class="params">(LocalDate begin, LocalDate end)</span> &#123;</span><br><span class="line">    <span class="comment">//存放从begin到end之间的每天对应的日期</span></span><br><span class="line">    List&lt;LocalDate&gt; dateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    dateList.add(begin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!begin.equals(end)) &#123;</span><br><span class="line">        begin = begin.plusDays(<span class="number">1</span>);</span><br><span class="line">        dateList.add(begin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放每天的订单总数</span></span><br><span class="line">    List&lt;Integer&gt; orderCountList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放每天的有效订单数</span></span><br><span class="line">    List&lt;Integer&gt; validOrderCountList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历dateList集合，查询每天的有效订单数和订单总数</span></span><br><span class="line">    <span class="keyword">for</span> (LocalDate date : dateList) &#123;</span><br><span class="line">        <span class="comment">//查询每天的订单总数 select count(id) from orders where order_time &gt; ? and order_time &lt; ?</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.of(date, LocalTime.MIN);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(date, LocalTime.MAX);</span><br><span class="line">        <span class="comment">//查询每天的订单数</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">orderCount</span> <span class="operator">=</span> getOrderCount(beginTime, endTime, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询每天的有效订单数 select count(id) from orders where order_time &gt; ? and order_time &lt; ? and status = 5</span></span><br><span class="line">        <span class="comment">//条件加一个status = 5来查询完成的订单</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">validOrderCount</span> <span class="operator">=</span> getOrderCount(beginTime, endTime, Orders.COMPLETED);</span><br><span class="line"></span><br><span class="line">        orderCountList.add(orderCount);</span><br><span class="line">        validOrderCountList.add(validOrderCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算时间区间内的订单总数量</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">totalOrderCount</span> <span class="operator">=</span> orderCountList.stream().reduce(Integer::sum).get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算时间区间内的有效订单数量</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">validOrderCount</span> <span class="operator">=</span> validOrderCountList.stream().reduce(Integer::sum).get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化完成率</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">orderCompletionRate</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(totalOrderCount != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//计算订单完成率</span></span><br><span class="line">        orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  OrderReportVO.builder()</span><br><span class="line">            .dateList(StringUtils.join(dateList,<span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .orderCountList(StringUtils.join(orderCountList,<span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .validOrderCountList(StringUtils.join(validOrderCountList,<span class="string">&quot;,&quot;</span>))</span><br><span class="line">            .totalOrderCount(totalOrderCount)</span><br><span class="line">            .validOrderCount(validOrderCount)</span><br><span class="line">            .orderCompletionRate(orderCompletionRate)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据条件统计订单数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Integer <span class="title function_">getOrderCount</span><span class="params">(LocalDateTime begin, LocalDateTime end, Integer status)</span>&#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;begin&quot;</span>,begin);</span><br><span class="line">    map.put(<span class="string">&quot;end&quot;</span>,end);</span><br><span class="line">    map.put(<span class="string">&quot;status&quot;</span>,status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> orderMapper.countByMap(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapper-2"><a href="#mapper-2" class="headerlink" title="mapper"></a>mapper</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">    select count(id) from orders</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null&quot;</span>&gt;</span></span><br><span class="line">            and order_time <span class="symbol">&amp;gt;</span> #&#123;begin&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;end != null&quot;</span>&gt;</span></span><br><span class="line">            and order_time <span class="symbol">&amp;lt;</span> #&#123;end&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            and status = #&#123;status&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="销量排名"><a href="#销量排名" class="headerlink" title="销量排名"></a>销量排名</h2><h3 id="controller-5"><a href="#controller-5" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销量排名top10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/top10&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;销量排名top10&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;SalesTop10ReportVO&gt; <span class="title function_">top10</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span>  LocalDate begin,</span></span><br><span class="line"><span class="params">        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;销量排名top10：&#123;&#125;,&#123;&#125;&quot;</span>,begin,end);</span><br><span class="line">    <span class="keyword">return</span> Result.success(reportService.getSalesTop10(begin,end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service-5"><a href="#service-5" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计指定时间区间内的销量排名前10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SalesTop10ReportVO <span class="title function_">getSalesTop10</span><span class="params">(LocalDate begin, LocalDate end)</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> LocalDateTime.of(begin, LocalTime.MIN);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> LocalDateTime.of(end, LocalTime.MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询销量前10的菜品名和销量</span></span><br><span class="line">    List&lt;GoodsSalesDTO&gt; salesTop10 = orderMapper.getSalesTop10(beginTime, endTime);</span><br><span class="line">    <span class="comment">//转化成流  映射出name属性  收集到List中</span></span><br><span class="line">    List&lt;String&gt; names = salesTop10.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">nameList</span> <span class="operator">=</span> StringUtils.join(names, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; numbers = salesTop10.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">numberList</span> <span class="operator">=</span> StringUtils.join(numbers, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装返回结果数据</span></span><br><span class="line">    <span class="keyword">return</span> SalesTop10ReportVO</span><br><span class="line">            .builder()</span><br><span class="line">            .nameList(nameList)</span><br><span class="line">            .numberList(numberList)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapper-3"><a href="#mapper-3" class="headerlink" title="mapper"></a>mapper</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  GoodsSalesDTO 有两个属性，name和number--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getSalesTop10&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sky.dto.GoodsSalesDTO&quot;</span>&gt;</span></span><br><span class="line">        select od.name, sum(od.number) number</span><br><span class="line">        from order_detail od,orders o</span><br><span class="line">        where od.order_id = o.id and o.status = 5</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null&quot;</span>&gt;</span></span><br><span class="line">            and o.order_time <span class="symbol">&amp;gt;</span> #&#123;begin&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;end != null&quot;</span>&gt;</span></span><br><span class="line">            and o.order_time <span class="symbol">&amp;lt;</span> #&#123;end&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        group by od.name</span><br><span class="line">        order by number desc</span><br><span class="line">        limit 0,10</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="工作台"><a href="#工作台" class="headerlink" title="工作台"></a>工作台</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231021094921001.png" alt="image-20231021094921001"></p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231021100030641.png" alt="image-20231021100030641"></p><p>概览</p><p><img src="../assets/image/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0_Image/image-20231021095330450.png" alt="image-20231021095330450"></p><h3 id="controller-6"><a href="#controller-6" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/workspace&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;工作台相关接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkSpaceController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WorkspaceService workspaceService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作台今日数据查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/businessData&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;工作台今日数据查询&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;BusinessDataVO&gt; <span class="title function_">businessData</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获得当天的开始时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">begin</span> <span class="operator">=</span> LocalDateTime.now().with(LocalTime.MIN);</span><br><span class="line">        <span class="comment">//获得当天的结束时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.now().with(LocalTime.MAX);</span><br><span class="line"></span><br><span class="line">        <span class="type">BusinessDataVO</span> <span class="variable">businessDataVO</span> <span class="operator">=</span> workspaceService.getBusinessData(begin, end);</span><br><span class="line">        <span class="keyword">return</span> Result.success(businessDataVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询订单管理数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/overviewOrders&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;查询订单管理数据&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;OrderOverViewVO&gt; <span class="title function_">orderOverView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(workspaceService.getOrderOverView());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询菜品总览</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/overviewDishes&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;查询菜品总览&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;DishOverViewVO&gt; <span class="title function_">dishOverView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(workspaceService.getDishOverView());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询套餐总览</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/overviewSetmeals&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;查询套餐总览&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;SetmealOverViewVO&gt; <span class="title function_">setmealOverView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(workspaceService.getSetmealOverView());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="service-6"><a href="#service-6" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkspaceServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">WorkspaceService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishMapper dishMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SetmealMapper setmealMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据时间段统计营业数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> BusinessDataVO <span class="title function_">getBusinessData</span><span class="params">(LocalDateTime begin, LocalDateTime end)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 营业额：当日已完成订单的总金额</span></span><br><span class="line"><span class="comment">         * 有效订单：当日已完成订单的数量</span></span><br><span class="line"><span class="comment">         * 订单完成率：有效订单数 / 总订单数</span></span><br><span class="line"><span class="comment">         * 平均客单价：营业额 / 有效订单数</span></span><br><span class="line"><span class="comment">         * 新增用户：当日新增用户的数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;begin&quot;</span>,begin);</span><br><span class="line">        map.put(<span class="string">&quot;end&quot;</span>,end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询总订单数</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">totalOrderCount</span> <span class="operator">=</span> orderMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, Orders.COMPLETED);</span><br><span class="line">        <span class="comment">//营业额</span></span><br><span class="line">        <span class="type">Double</span> <span class="variable">turnover</span> <span class="operator">=</span> orderMapper.sumByMap(map);</span><br><span class="line">        turnover = turnover == <span class="literal">null</span>? <span class="number">0.0</span> : turnover;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有效订单数</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">validOrderCount</span> <span class="operator">=</span> orderMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="type">Double</span> <span class="variable">unitPrice</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Double</span> <span class="variable">orderCompletionRate</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(totalOrderCount != <span class="number">0</span> &amp;&amp; validOrderCount != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//订单完成率</span></span><br><span class="line">            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;</span><br><span class="line">            <span class="comment">//平均客单价</span></span><br><span class="line">            unitPrice = turnover / validOrderCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新增用户数</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">newUsers</span> <span class="operator">=</span> userMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BusinessDataVO.builder()</span><br><span class="line">                .turnover(turnover)</span><br><span class="line">                .validOrderCount(validOrderCount)</span><br><span class="line">                .orderCompletionRate(orderCompletionRate)</span><br><span class="line">                .unitPrice(unitPrice)</span><br><span class="line">                .newUsers(newUsers)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询订单管理数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OrderOverViewVO <span class="title function_">getOrderOverView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;begin&quot;</span>, LocalDateTime.now().with(LocalTime.MIN));</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, Orders.TO_BE_CONFIRMED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待接单</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">waitingOrders</span> <span class="operator">=</span> orderMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待派送</span></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, Orders.CONFIRMED);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">deliveredOrders</span> <span class="operator">=</span> orderMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已完成</span></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, Orders.COMPLETED);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">completedOrders</span> <span class="operator">=</span> orderMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//已取消</span></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, Orders.CANCELLED);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">cancelledOrders</span> <span class="operator">=</span> orderMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//全部订单</span></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">allOrders</span> <span class="operator">=</span> orderMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> OrderOverViewVO.builder()</span><br><span class="line">                .waitingOrders(waitingOrders)</span><br><span class="line">                .deliveredOrders(deliveredOrders)</span><br><span class="line">                .completedOrders(completedOrders)</span><br><span class="line">                .cancelledOrders(cancelledOrders)</span><br><span class="line">                .allOrders(allOrders)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询菜品总览</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DishOverViewVO <span class="title function_">getDishOverView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, StatusConstant.ENABLE);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sold</span> <span class="operator">=</span> dishMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, StatusConstant.DISABLE);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">discontinued</span> <span class="operator">=</span> dishMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DishOverViewVO.builder()</span><br><span class="line">                .sold(sold)</span><br><span class="line">                .discontinued(discontinued)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询套餐总览</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SetmealOverViewVO <span class="title function_">getSetmealOverView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, StatusConstant.ENABLE);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sold</span> <span class="operator">=</span> setmealMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, StatusConstant.DISABLE);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">discontinued</span> <span class="operator">=</span> setmealMapper.countByMap(map);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SetmealOverViewVO.builder()</span><br><span class="line">                .sold(sold)</span><br><span class="line">                .discontinued(discontinued)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AI总结"><a href="#AI总结" class="headerlink" title="AI总结"></a>AI总结</h2><h3 id="HTTP服务常见状态码"><a href="#HTTP服务常见状态码" class="headerlink" title="HTTP服务常见状态码"></a>HTTP服务常见状态码</h3><p>HTTP服务常用状态码主要包括:</p><ul><li>200 OK - 请求成功</li><li>301 Moved Permanently - 资源永久移动</li><li>302 Found - 资源临时移动</li><li>304 Not Modified - 资源未修改</li><li>400 Bad Request - 请求语法错误</li><li>401 Unauthorized - 需要身份认证</li><li>403 Forbidden - 服务器拒绝请求</li><li>404 Not Found - 请求资源不存在</li><li>500 Internal Server Error - 服务器内部错误</li></ul><p>其中:</p><ul><li>2xx 表示成功处理了请求</li><li>3xx 表示需要进行额外操作以完成请求</li><li>4xx 表示请求自身存在问题</li><li>5xx 表示服务器处理请求出错</li></ul><p>这些状态码可以帮助客户端判断请求的结果,以及后续需要进行的操作。如404状态码表示客户端请求的资源不存在,应该检查请求URL;500状态码表示服务器端出错,客户端可能需要重试请求。正确处理状态码是构建健壮的HTTP服务非常重要的一步。</p><h3 id="HTTP服务中常见的请求类型"><a href="#HTTP服务中常见的请求类型" class="headerlink" title="HTTP服务中常见的请求类型"></a>HTTP服务中常见的请求类型</h3><p>HTTP（Hypertext Transfer Protocol）是一种用于在客户端和服务器之间传输数据的协议。在HTTP服务中，常见的请求类型包括以下几种：</p><ol><li><p><strong>GET</strong>：GET请求用于从服务器获取资源。它是一种幂等请求，意味着多次发送相同的GET请求不会对服务器状态产生影响。通常用于请求页面、图片、文件或其他资源。GET请求将数据附加在URL的查询参数中，因此可见于URL。</p></li><li><p><strong>POST</strong>：POST请求用于向服务器提交数据，通常用于创建新资源或提交表单数据。POST请求将数据放在请求体中，而不是在URL中，因此适用于传输敏感数据，如用户凭证或大量数据。</p></li><li><p><strong>PUT</strong>：PUT请求用于更新服务器上的资源，通常用于更新已经存在的资源。与POST不同，PUT请求是幂等的，多次发送相同的PUT请求将产生相同的结果。</p></li><li><p><strong>DELETE</strong>：DELETE请求用于删除服务器上的资源。与GET和POST不同，DELETE请求是幂等的，多次发送相同的DELETE请求将产生相同的结果。</p></li><li><p><strong>PATCH</strong>：PATCH请求用于对服务器上的资源进行部分更新。它类似于PUT，但通常只更新资源的一部分而不是整个资源。PATCH请求也是幂等的。</p></li><li><p><strong>HEAD</strong>：HEAD请求与GET请求类似，但服务器只返回响应头而不返回响应体。它通常用于获取资源的元数据，如大小或类型，而不需要实际的内容。</p></li><li><p><strong>OPTIONS</strong>：OPTIONS请求用于获取有关服务器支持的通信选项的信息。它通常用于跨域资源共享（CORS）和其他HTTP协议的交互。</p></li><li><p><strong>CONNECT</strong>：CONNECT请求用于建立到服务器的网络连接，通常用于代理服务器。它允许客户端与目标服务器之间建立隧道，以进行安全通信。</p></li><li><p><strong>TRACE</strong>：TRACE请求用于诊断请求和响应之间的中间代理服务器的操作。它通常用于调试和测试。</p></li></ol><p>这些是HTTP服务中的常见请求类型。每种请求类型都有特定的语义和用途，根据应用程序的需求选择合适的请求类型来与服务器进行交互。</p><h3 id="注解-Slf4j"><a href="#注解-Slf4j" class="headerlink" title="注解@Slf4j"></a>注解@Slf4j</h3><p><code>@Slf4j</code> 是一个注解，它是 Lombok（一种Java库）提供的功能之一。它的作用是自动为类添加一个标准的日志对象，用于记录日志信息，以简化 Java 类中的日志记录操作。<code>@Slf4j</code> 可以大幅度减少编写冗长的日志记录代码的工作，提高了代码的可读性和可维护性。</p><p>以下是关于 <code>@Slf4j</code> 注解的一些重要信息：</p><ol><li><p><strong>引入 Lombok</strong>：<br>要使用 <code>@Slf4j</code> 注解，你需要在你的项目中引入 Lombok 依赖。通常，这涉及到将 Lombok 依赖添加到项目的构建工具（例如 Maven 或 Gradle）配置文件中，并确保项目的 IDE 支持 Lombok 插件。</p></li><li><p><strong>生成日志对象</strong>：<br>使用 <code>@Slf4j</code> 注解的类会自动在编译时生成一个名为 <code>log</code> 的日志对象。你可以使用这个 <code>log</code> 对象来记录日志消息，而不必手动创建和配置日志记录器。</p></li><li><p><strong>日志级别</strong>：<br><code>@Slf4j</code> 自动生成的日志对象支持多种日志级别，包括 DEBUG、INFO、WARN、ERROR 等。你可以使用这些级别来记录不同重要性的日志消息。</p></li><li><p><strong>示例</strong>：<br>下面是一个使用 <code>@Slf4j</code> 注解的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Debug message&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;Informational message&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;Warning message&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;Error message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>@Slf4j</code> 注解自动为 <code>MyClass</code> 类生成了一个 <code>log</code> 对象。然后，我们可以使用 <code>log</code> 对象来记录不同级别的日志消息。</p></li><li><p><strong>日志配置</strong>：<br>通常，你需要配置日志系统（例如 Logback、Log4j2 等）来定义日志消息的输出方式、格式和目标。<code>@Slf4j</code> 本身不处理日志配置，它只是为类生成日志对象。你需要确保你的项目正确配置了日志框架，以便日志消息按照你的需求进行记录和输出。</p></li></ol><p>总之，<code>@Slf4j</code> 注解是一个方便的工具，用于简化 Java 类中的日志记录操作。它减少了编写样板代码的工作，提高了代码的清晰度，并使日志记录更加容易管理和维护。但要注意，为了使 <code>@Slf4j</code> 生效，你需要正确配置和集成 Lombok 插件和你的日志框架。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code> 是 Java 中一个非常有用的类，它允许你在多线程环境下为每个线程存储和管理独立的数据副本。每个线程都可以独立访问和修改自己的数据副本，从而避免了线程安全问题。以下是一些 <code>ThreadLocal</code> 常用方法和用法：</p><ol><li><p><strong>构造方法</strong>：</p><ul><li><code>ThreadLocal</code> 类有一个无参数的构造方法，用于创建一个新的 <code>ThreadLocal</code> 实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;T&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>set</code> 方法</strong>：</p><ul><li><code>set</code> 方法用于在当前线程中设置 <code>ThreadLocal</code> 实例的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(value);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>get</code> 方法</strong>：</p><ul><li><code>get</code> 方法用于获取当前线程中 <code>ThreadLocal</code> 实例的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>remove</code> 方法</strong>：</p><ul><li><code>remove</code> 方法用于删除当前线程中 <code>ThreadLocal</code> 实例的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化 ThreadLocal 的值</strong>：</p><ul><li>你可以通过重写 <code>ThreadLocal</code> 的 <code>initialValue</code> 方法来初始化 <code>ThreadLocal</code> 的值。这个方法在第一次访问 <code>get</code> 方法时调用，用于返回初始值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;T&gt; threadLocal = ThreadLocal.withInitial(() -&gt; initialValue);</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：<br>下面是一个简单的示例，演示了如何在不同的线程中使用 <code>ThreadLocal</code> 存储和访问线程相关的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            value++;</span><br><span class="line">            threadLocal.set(value);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-local value: &quot;</span> + value);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个 <code>ThreadLocal</code> 实例 <code>threadLocal</code>，并在两个不同的线程中分别访问和修改它的值。由于每个线程都有自己的数据副本，它们不会相互干扰。</p></li></ol><p><code>ThreadLocal</code> 在多线程环境中用于存储线程特定的数据非常有用，但需要谨慎使用，以避免内存泄漏问题。要确保在不再需要数据时调用 <code>remove</code> 方法以释放资源。此外，要避免滥用 <code>ThreadLocal</code>，因为过多的 <code>ThreadLocal</code> 变量可能会导致不必要的内存开销。</p><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>在Java中,@Retention是一种元注解,用于指定自定义注解的保留策略,即自定义注解在什么阶段可以被读取。</p><p>@Retention有以下三个值:</p><ol><li><p>RetentionPolicy.SOURCE:注解只保留在源码级别,在编译器进行编译时它将被丢弃忽略。</p></li><li><p>RetentionPolicy.CLASS:注解被保留到编译进行的时候,而在jvm加载class文件到内存的时候被遗弃。</p></li><li><p>RetentionPolicy.RUNTIME:注解可以保留到程序运行的时候,我们可以通过反射机制读取该注解的信息。</p></li></ol><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着MyAnnotation可以被保留到程序运行时,我们可以通过反射来读取它的注解信息。</p><p>@Retention的这个保留策略对于注解非常重要。因为我们一般会在运行时去读取注解的信息,所以自定义注解通常都会指定为@Retention(RetentionPolicy.RUNTIME),这样才能够发挥注解的作用。</p><p>如果指定为SOURCE或CLASS,那运行时就无法读取该注解信息,限制了其使用场景。</p><p>所以一般情况下,我们自定义的注解为了满足运行时读取的需求,都需要使用@Retention(RetentionPolicy.RUNTIME)来保留到运行时。</p><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h3><p><code>@Aspect</code> 是Spring Framework中用于声明切面（Aspect）的注解。切面是一种特殊的类，它包含了与横切关注点（cross-cutting concerns）相关的代码和配置。横切关注点包括日志记录、安全性、事务管理、异常处理等，这些关注点通常会分布在应用程序的多个地方，而切面的作用是将这些关注点模块化，使得它们可以集中管理，提高代码的可维护性和可重用性。</p><p>以下是关于 <code>@Aspect</code> 注解的详细解释：</p><ol><li><p><strong>声明切面类：</strong></p><p>使用 <code>@Aspect</code> 注解来声明一个类为切面。通常，切面类包含了切点（Pointcut）的定义和与切点相关的通知（Advice）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 切点和通知定义在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义切点：</strong></p><p>切点是一个表达式，它定义了在哪些方法上应用切面逻辑。切点表达式使用特定的语法来匹配方法的签名，以确定在哪些方法执行前、执行后或出现异常时应用通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 切点定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义通知：</strong></p><p>通知是切面类中的方法，它定义了在切点匹配的方法执行前、执行后或出现异常时执行的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;myPointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在方法执行前执行的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用的通知类型包括 <code>@Before</code>、<code>@After</code>、<code>@AfterReturning</code>、<code>@AfterThrowing</code> 和 <code>@Around</code>，它们分别表示在方法执行前、执行后、成功返回后、抛出异常后以及环绕方法执行时执行的逻辑。</p></li><li><p><strong>切面的应用场景：</strong></p><ul><li><p><strong>日志记录</strong>：记录方法执行前后的信息，以便跟踪应用程序的行为和调试。</p></li><li><p><strong>事务管理</strong>：管理数据库事务，确保数据一致性。</p></li><li><p><strong>安全性</strong>：进行权限验证，确保只有授权的用户可以访问某些方法。</p></li><li><p><strong>异常处理</strong>：捕获和处理方法抛出的异常，以实现更友好的错误处理。</p></li><li><p><strong>性能监控</strong>：测量方法的执行时间，收集性能统计信息，进行性能调优。</p></li><li><p><strong>缓存管理</strong>：在方法执行前检查缓存，以提高性能并减少对数据库或其他资源的访问。</p></li></ul></li><li><p><strong>多个切面的组合：</strong></p><p>在实际应用中，你可以定义多个切面，每个切面关注不同的横切关注点。Spring AOP允许你将多个切面组合在一起，以实现更复杂的逻辑。你可以使用 <code>@Order</code> 注解来指定切面的执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect1</span> &#123;</span><br><span class="line">    <span class="comment">// 切点和通知定义在这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect2</span> &#123;</span><br><span class="line">    <span class="comment">// 切点和通知定义在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总之，<code>@Aspect</code> 注解用于声明切面类，它是Spring AOP的核心组件之一，用于将横切关注点从应用程序的核心逻辑中分离出来，以提高代码的模块化性、可维护性和可重用性。切面定义了切点和通知，通过切点匹配的方法会在通知中执行额外的逻辑。这种方式允许你在不修改原始代码的情况下，将横切关注点集中处理，从而更好地管理和维护应用程序。</p><hr><p>在 Spring AOP 中，<code>@Aspect</code> 注解用于标识一个类作为切面，用来定义切点（Pointcut）和通知（Advice），以及其他与AOP相关的配置。除了 <code>@Aspect</code> 注解，还有一些其他常用的与 <code>@Aspect</code> 注解一起使用的注解，这些注解用于定义切点和通知的行为。以下是一些可能与 <code>@Aspect</code> 注解一起使用的注解：</p><ol><li><p><code>@Before</code>：用于定义前置通知，指定在目标方法执行前执行的逻辑。</p></li><li><p><code>@AfterReturning</code>：用于定义返回通知，指定在目标方法成功执行后执行的逻辑。</p></li><li><p><code>@AfterThrowing</code>：用于定义异常通知，指定在目标方法抛出异常时执行的逻辑。</p></li><li><p><code>@After</code>：用于定义最终通知，指定无论目标方法是否成功执行都会执行的逻辑。</p></li><li><p><code>@Around</code>：用于定义环绕通知，指定在目标方法执行前和执行后都可以插入逻辑，可以完全控制方法的执行过程。</p></li></ol><p>这些注解允许你根据需要在不同的执行点插入自定义逻辑，以满足各种需求。通常，你可以根据目标方法的执行顺序和行为选择合适的注解来实现特定的功能。在一个切面类中，可以同时使用这些注解来定义多个通知，以实现更复杂的逻辑。</p><p>除了上述通知注解，还有其他用于配置切点的注解，如：</p><ol><li><p><code>@Pointcut</code>：用于定义切点表达式，指定在哪些方法上应用切面逻辑。</p></li><li><p><code>@Around</code>：可以在切点表达式中使用，用于在通知中引用切点。</p></li><li><p><code>@Order</code>：用于定义切面的执行顺序，如果有多个切面，可以通过 <code>@Order</code> 注解来控制它们的执行顺序。</p></li></ol><p>这些注解通常与 <code>@Aspect</code> 注解一起使用，以实现对应的AOP功能。在Spring AOP中，使用这些注解可以有效地管理横切关注点，并将它们与应用程序的核心逻辑分离开来。</p><h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><p>Spring Framework 提供了多个用于定义不同类型组件的注解，类似于 <code>@Service</code> 注解。这些注解都有不同的语义和用途，但它们都用于告诉 Spring 容器如何处理特定的组件。以下是一些与 <code>@Service</code> 相似的注解：</p><ol><li><p><code>@Component</code>: <code>@Service</code> 注解是 <code>@Component</code> 注解的一个特殊化版本。它用于标记一个普通的 Spring 组件类。</p></li><li><p><code>@Repository</code>: 用于标记数据访问层的组件，通常与持久性相关的类。Spring 会将其识别为仓库类，并提供一些额外的异常转换，例如将数据库异常转换为 Spring 的 DataAccessException。</p></li><li><p><code>@Controller</code>: 用于标记控制器类，通常用于处理 Web 请求，并返回视图或模板。</p></li><li><p><code>@RestController</code>: 用于标记控制器类，通常用于处理 RESTful Web 服务请求，它的方法会返回数据而不是视图。</p></li><li><p><code>@Service</code>: 用于标记业务逻辑层的组件，通常用于放置服务类。与 <code>@Component</code> 类似，但更加语义化，用于区分不同层次的组件。</p></li><li><p><code>@Configuration</code>: 用于标记配置类，通常与 <code>@Bean</code> 注解一起使用，用于定义 Spring Bean 的创建。</p></li><li><p><code>@Scope</code>: 用于定义 Bean 的作用域，控制 Bean 的生命周期。常见的作用域包括 Singleton、Prototype、Request、Session 等。</p></li><li><p><code>@Lazy</code>: 用于标记 Bean 是否懒加载，即只有在需要时才会初始化。</p></li></ol><p>这些注解都有不同的用途，但它们都用于告诉 Spring 容器如何处理组件，并帮助 Spring 在应用程序中进行依赖注入和管理 Bean 的生命周期。选择合适的注解取决于你的组件的角色和用途。</p><h3 id="Component和-Bean"><a href="#Component和-Bean" class="headerlink" title="@Component和@Bean"></a>@Component和@Bean</h3><p><code>@Component</code> 和 <code>@Bean</code> 是 Spring Framework 中用于创建和管理 bean（组件）的两种不同方式，它们有一些关键的区别：</p><ol><li><p><strong>用法和用途</strong>：</p><ul><li><p><code>@Component</code> 是一种类级别的注解，通常用于将一个类标记为 Spring 托管的组件。它告诉 Spring 在类路径扫描期间，将这个类自动识别为 bean，并将其实例化并管理。</p></li><li><p><code>@Bean</code> 是一种方法级别的注解，通常用于配置类中的方法，以指示 Spring 创建和管理特定的 bean 实例。您需要在一个配置类中定义这个方法，然后 Spring 容器会调用该方法以获取 bean 实例。</p></li></ul></li><li><p><strong>位置</strong>：</p><ul><li><p><code>@Component</code> 注解通常在组件类的定义上使用，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Bean</code> 注解通常在配置类的方法上使用，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>创建方式</strong>：</p><ul><li><p><code>@Component</code> 注解的 bean 由 Spring 容器自动创建和管理。您只需在类上添加 <code>@Component</code> 注解，Spring 会负责其余的工作。</p></li><li><p><code>@Bean</code> 注解的 bean 是由开发者显式定义的。您需要在配置类中编写一个方法，并在该方法上添加 <code>@Bean</code> 注解，然后在方法内部创建并返回 bean 实例。</p></li></ul></li><li><p><strong>配置级别</strong>：</p><ul><li><p><code>@Component</code> 注解通常用于将普通的 Java 类纳入 Spring 容器的管理中，而不需要额外的配置类。</p></li><li><p><code>@Bean</code> 注解通常用于配置类中，通常需要使用 <code>@Configuration</code> 注解标记配置类，以指示 Spring 容器查找 <code>@Bean</code> 方法。</p></li></ul></li><li><p><strong>方法参数</strong>：</p><ul><li><p><code>@Component</code> 注解的类通常不接受其他 bean 作为构造函数参数，而是通过字段注入或 <code>@Autowired</code> 注解来获取其他 bean。</p></li><li><p><code>@Bean</code> 注解的方法可以接受其他 bean 作为参数，并将它们注入到方法中，从而允许您在创建 bean 实例时进行自定义配置。</p></li></ul></li></ol><p>总结而言，<code>@Component</code> 和 <code>@Bean</code> 都是用于创建和管理 Spring bean 的方式，但它们的使用方式和用途有所不同。<code>@Component</code> 更适合将普通的 Java 类声明为 bean，而 <code>@Bean</code> 更适合在配置类中进行精确的 bean 创建和配置。您可以根据项目需求和设计模式选择使用其中之一或两者结合使用。</p><h3 id="方法参数前的注解"><a href="#方法参数前的注解" class="headerlink" title="方法参数前的注解"></a>方法参数前的注解</h3><p>在Java中，有许多不同的注解可用于方法参数前，用于指定参数的特定行为或属性。以下是一些常见的用于参数前的注解：</p><ol><li><p><strong>@RequestParam</strong>：</p><ul><li>用于从HTTP请求中提取参数值，通常用于获取URL中的查询参数或表单字段的值。</li></ul></li><li><p><strong>@PathVariable</strong>：</p><ul><li>用于将URI模板变量（例如RESTful API中的路径参数）映射到方法参数。</li></ul></li><li><p><strong>@RequestBody</strong>：</p><ul><li>用于指示方法参数应该从HTTP请求体中获取，通常用于接收JSON或XML等请求体数据。</li></ul></li><li><p><strong>@RequestHeader</strong>：</p><ul><li>用于获取HTTP请求头的值，可以指定头的名称来获取特定头的值。</li></ul></li><li><p><strong>@CookieValue</strong>：</p><ul><li>用于获取HTTP请求中的Cookie的值，可以指定Cookie的名称来获取特定Cookie的值。</li></ul></li><li><p><strong>@ModelAttribute</strong>：</p><ul><li>用于将请求参数绑定到模型对象上，通常用于表单数据的绑定。</li></ul></li><li><p><strong>@RequestAttribute</strong>：</p><ul><li>用于获取HTTP请求中的属性值，通常在请求处理过程中通过<code>HttpServletRequest</code>设置的属性。</li></ul></li><li><p><strong>@Valid</strong>：</p><ul><li>用于在参数上启用Bean验证（JSR-303），通常与<code>@Validated</code>一起使用，以验证参数的有效性。</li></ul></li><li><p><strong>@RequestParamMap</strong>：</p><ul><li>用于将所有的请求参数映射到一个<code>Map</code>对象，以便获取所有的请求参数。</li></ul></li><li><p><strong>@RequestParamMultiValue</strong>：</p><ul><li>用于将多个值的请求参数映射到一个<code>MultiValueMap</code>对象，以便获取多值请求参数。</li></ul></li></ol><p>这些注解提供了各种方式来处理和访问HTTP请求的不同部分，可以根据具体的需求来选择适当的注解。这些注解通常用于Spring框架中的控制器方法中，以处理和解析HTTP请求。</p><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p><code>@Transactional</code> 是Spring框架中的一个注解，用于声明事务性方法，它告诉Spring容器，被注解的方法应该在一个事务中执行。事务是一组操作，要么全部成功完成，要么全部失败回滚，以确保数据的一致性和完整性。</p><p>以下是关于 <code>@Transactional</code> 注解的一些重要信息和用法：</p><ol><li><p><strong>在方法级别使用</strong>：</p><ul><li><p>通常，<code>@Transactional</code> 注解被应用于服务层的方法，以指示这些方法应该在事务管理下执行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>事务传播属性（Propagation）</strong>：</p><ul><li><code>@Transactional</code> 注解支持不同的事务传播属性，用于控制事务的行为。例如，可以设置为 <code>REQUIRED</code>、<code>REQUIRES_NEW</code>、<code>SUPPORTS</code>、<code>MANDATORY</code> 等。</li><li>事务传播属性决定了在方法被调用时如何处理已经存在的事务。不同的传播属性适用于不同的业务场景。</li></ul></li><li><p><strong>隔离级别（Isolation Level）</strong>：</p><ul><li>事务的隔离级别定义了事务之间的相互影响程度，Spring支持多种隔离级别，如 <code>DEFAULT</code>、<code>READ_COMMITTED</code>、<code>SERIALIZABLE</code> 等。</li><li>隔离级别用于控制多个并发事务之间的可见性和一致性。</li></ul></li><li><p><strong>回滚规则（Rollback Rules）</strong>：</p><ul><li>可以使用 <code>rollbackFor</code> 和 <code>noRollbackFor</code> 参数来定义哪些异常应该触发事务回滚，哪些异常不应该触发事务回滚。</li><li>这使得你可以根据需要对事务回滚进行更精细的控制。</li></ul></li><li><p><strong>事务超时（Timeout）</strong>：</p><ul><li>使用 <code>timeout</code> 参数来指定事务的超时时间，如果事务在指定的时间内没有完成，将会自动回滚。</li></ul></li><li><p><strong>只读事务（Read-Only Transactions）</strong>：</p><ul><li>如果你知道一个方法只会读取数据而不修改数据，可以使用 <code>readOnly</code> 参数来设置方法为只读事务，这可以提高性能。</li></ul></li><li><p><strong>嵌套事务</strong>：</p><ul><li><code>@Transactional</code> 注解还支持嵌套事务，使得方法可以在一个已存在的事务中执行，或者开启一个新的嵌套事务。</li></ul></li><li><p><strong>异常处理</strong>：</p><ul><li>如果一个被 <code>@Transactional</code> 注解的方法抛出了未捕获的异常，Spring会将事务标记为“回滚”。你可以通过捕获异常并处理来控制事务的行为。</li></ul></li></ol><p>总之，<code>@Transactional</code> 注解是Spring框架中用于管理事务的强大工具，可以帮助你实现数据库操作的一致性和可靠性。通过正确配置事务的传播属性、隔离级别、回滚规则等参数，你可以确保事务在各种复杂的业务场景下正确地执行。</p><h3 id="接口中的静态方法可以被重写吗"><a href="#接口中的静态方法可以被重写吗" class="headerlink" title="接口中的静态方法可以被重写吗"></a>接口中的静态方法可以被重写吗</h3><p>接口中的静态方法不能被子接口或实现类重写。静态方法是与接口本身相关联的，而不是与接口的实现类相关联的。因此，子接口或实现类无法覆盖接口中的静态方法。</p><p>当你在接口中定义一个静态方法时，它可以在接口的名称上直接调用，与实例化接口的对象无关。<strong>如果子接口或实现类试图定义一个与接口中的静态方法具有相同名称和参数列表的静态方法，这只是在子接口或实现类中创建了一个新的静态方法，而不是对接口中的静态方法进行重写。</strong>这两个方法是完全独立的，没有覆盖或重写的关系。</p><p>因此，要注意，接口中的静态方法不具备多态性，也不能被子接口或实现类用来提供不同的实现。静态方法通常用于接口提供一些与接口相关的工具方法，这些方法不依赖于接口的实例化对象。</p>]]></content>
    
    
    <summary type="html">🍔本文记录苍穹外卖项目搭建过程中的笔记</summary>
    
    
    
    <category term="项目" scheme="https://momoao.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="MyBatis" scheme="https://momoao.github.io/tags/MyBatis/"/>
    
    <category term="SpringBoot" scheme="https://momoao.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://momoao.github.io/posts/202308290811.html"/>
    <id>https://momoao.github.io/posts/202308290811.html</id>
    <published>2023-08-29T07:33:03.000Z</published>
    <updated>2023-08-29T01:40:21.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="所有数据类型"><a href="#所有数据类型" class="headerlink" title="所有数据类型"></a>所有数据类型</h2><p>JavaScript支持多种数据类型，这些数据类型可以根据其特性和用途进行分类。以下是JavaScript中的主要数据类型：</p><ol><li><p><strong>基本数据类型（Primitive Data Types）</strong>：</p><ul><li><strong>String</strong>（字符串）：表示文本数据，使用单引号或双引号括起来。</li><li><strong>Number</strong>（数字）：表示数值，可以是整数或浮点数。</li><li><strong>Boolean</strong>（布尔）：表示逻辑值，只有两个可能的值：<code>true</code>（真）和<code>false</code>（假）。</li><li><strong>null</strong>：表示空值或无值。</li><li><strong>undefined</strong>：表示未定义的值。</li></ul></li><li><p><strong>复杂数据类型（Complex Data Types）</strong>：</p><ul><li><strong>Object</strong>（对象）：表示一个键值对集合，可以包含属性和方法。对象可以用花括号 <code>&#123;&#125;</code> 来定义。</li><li><strong>Array</strong>（数组）：表示有序的列表，包含一组值。数组可以用方括号 <code>[]</code> 来定义。</li><li><strong>Function</strong>（函数）：表示可执行的代码块，可以被调用执行。</li></ul></li><li><p><strong>特殊数据类型</strong>：</p><ul><li><strong>Symbol</strong>（符号）：ES6引入的数据类型，表示唯一的、不可变的值，主要用于创建对象属性的唯一键。</li></ul></li><li><p><strong>包装对象（Wrapper Objects）</strong>：</p><ul><li>JavaScript为基本数据类型提供了相应的包装对象，使其可以像对象一样访问属性和方法。例如，<code>String</code>、<code>Number</code> 和 <code>Boolean</code>。</li></ul></li></ol><p>这些数据类型在JavaScript中具有不同的特性和用途。例如，字符串用于处理文本，数字用于数值计算，对象和数组用于组织和存储数据，函数用于封装可执行的代码块等。</p><p>在JavaScript中，数据类型通常是动态的，这意味着变量的类型可以在运行时改变。这种灵活性使JavaScript非常适合用于各种应用程序，从网页交互到服务器端开发。</p><h3 id="null和undefined和NAN的区别"><a href="#null和undefined和NAN的区别" class="headerlink" title="null和undefined和NAN的区别"></a>null和undefined和NAN的区别</h3><p><code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都是 JavaScript 中表示特殊值或特定情况的值，它们在含义和用法上有所不同：</p><ol><li><p><strong>null</strong>：</p><ul><li><code>null</code> 表示一个空值或缺失值。</li><li>当您想要明确地表示一个变量没有值时，可以将其赋值为 <code>null</code>。</li><li><code>null</code> 是一个原始数据类型，表示一个空的或无效的对象引用。</li><li>在逻辑判断中，<code>null</code> 被视为一个”假值”（falsey value），但不等于布尔值 <code>false</code>。</li></ul></li><li><p><strong>undefined</strong>：</p><ul><li>当声明了一个变量但没有为其赋值时，它的值就是 <code>undefined</code>。</li><li>函数没有显式返回值时，默认返回 <code>undefined</code>。</li><li>访问对象上不存在的属性时，返回的值也是 <code>undefined</code>。</li><li>在逻辑判断中，<code>undefined</code> 被视为一个”假值”（falsey value），但不等于布尔值 <code>false</code>。</li></ul></li><li><p><strong>NaN</strong>（Not-a-Number）：</p><ul><li><code>NaN</code> 表示一个非数字的值，通常在进行数学运算出错时返回。</li><li>例如，字符串解析成数字失败时，结果就是 <code>NaN</code>。</li><li><code>NaN</code> 是一个特殊的数值，它与任何其他值都不相等，包括自身。因此，<code>NaN !== NaN</code>。</li><li>在逻辑判断中，<code>NaN</code> 被视为一个”假值”（falsey value），但不等于布尔值 <code>false</code>。</li></ul></li></ol><p>总结区别：</p><ul><li><code>null</code> 表示明确的空值或缺失值，是一个赋值的操作，属于原始数据类型。</li><li><code>undefined</code> 表示未定义的值，可以是变量声明但未赋值，函数未返回值等情况。</li><li><code>NaN</code> 表示非数字的值，通常在数学运算出错时返回，属于数值类型。</li><li>在逻辑判断中，<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都被视为”假值”，但不等于布尔值 <code>false</code>。</li></ul><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出：null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> parsedNumber = <span class="built_in">parseInt</span>(c);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parsedNumber); <span class="comment">// 输出：NaN</span></span><br></pre></td></tr></table></figure><p>了解这些特殊值的含义和行为可以帮助您更好地处理变量赋值、逻辑判断和数学运算等情况。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>JavaScript的语法与许多其他编程语言相似，包括变量、数据类型、运算符等。</li><li>定义变量使用 <code>var</code>、<code>let</code> 或 <code>const</code>，其中 <code>let</code> 和 <code>const</code> 是ES6引入的新声明方式。</li><li>基本数据类型包括数字、字符串、布尔值，以及特殊值 <code>null</code> 和 <code>undefined</code>。</li><li>使用 <code>+</code> 运算符可以连接字符串，执行数字相加。</li><li>条件语句如 <code>if</code>、<code>else if</code> 和 <code>else</code> 用于控制代码的执行路径。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量和数据类型</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件语句</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Number is greater than 5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Number is not greater than 5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h3><p>在JavaScript中，<code>var</code>、<code>let</code>和<code>const</code>是用于声明变量的关键字，它们在作用域、可变性和生命周期等方面有不同的行为。以下是它们的主要区别：</p><ol><li><p><strong>var</strong>：</p><ul><li><code>var</code> 是在ES5中引入的变量声明关键字。</li><li>变量声明提升：在作用域内，<code>var</code> 声明的变量会被提升到作用域的顶部。这意味着您可以在声明之前引用变量。</li><li>没有块级作用域：<code>var</code> 声明的变量在函数作用域内有效，而不仅仅是在块（如循环或条件语句）中有效。</li><li>允许重复声明：在同一作用域内，您可以多次使用 <code>var</code> 声明同一个变量。</li></ul></li><li><p><strong>let</strong>：</p><ul><li><code>let</code> 是在ES6中引入的块级作用域变量声明关键字。</li><li>块级作用域：<code>let</code> 声明的变量仅在其声明的块内有效，不会提升到作用域的顶部。</li><li>不允许重复声明：在同一作用域内，不允许使用 <code>let</code> 重复声明同一个变量。</li></ul></li><li><p><strong>const</strong>：</p><ul><li><code>const</code> 也是在ES6中引入的，用于声明常量，即一旦赋值后就不能再改变的变量。</li><li>块级作用域：<code>const</code> 同样遵循块级作用域规则，只在其声明的块内有效。</li><li>必须初始化：在声明 <code>const</code> 变量时必须进行初始化，否则会引发错误。</li><li>常量值不可变：一旦赋值，<code>const</code> 变量的值就不能再改变。</li></ul></li></ol><p>总结区别：</p><ul><li>使用 <code>var</code> 可能会导致变量提升和难以预测的作用域行为。它的使用已经逐渐被 <code>let</code> 和 <code>const</code> 取代。</li><li><code>let</code> 允许在块级作用域内声明变量，并且变量的值可以重新赋值。</li><li><code>const</code> 用于声明常量，变量的值在初始化后不能更改，并且也遵循块级作用域。</li></ul><p>推荐在现代JavaScript代码中使用 <code>let</code> 和 <code>const</code> 来获得更严格的作用域控制和代码可维护性。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>使用 <code>function</code> 关键字定义函数。函数可以接受参数，也可以返回值。</li><li>可以使用匿名函数（无名函数），也可以使用命名函数。</li><li>函数可以在其他函数中调用，也可以作为回调传递给其他函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> multiply = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">3</span>, <span class="number">5</span>));       <span class="comment">// 输出：8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiply</span>(<span class="number">2</span>, <span class="number">4</span>)); <span class="comment">// 输出：8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数组和对象"><a href="#数组和对象" class="headerlink" title="数组和对象"></a>数组和对象</h2><ul><li>数组用于存储多个值，可以通过索引访问。使用方括号 <code>[]</code> 创建数组。</li><li>对象用于存储键值对，每个键对应一个值。使用大括号 <code>&#123;&#125;</code> 创建对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Johnson&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers[<span class="number">2</span>]);        <span class="comment">// 输出：3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">firstName</span>);  <span class="comment">// 输出：&quot;Alice&quot;</span></span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li>使用 <code>for</code> 循环和 <code>while</code> 循环可以重复执行一组操作。</li><li><code>for...of</code> 循环用于遍历数组等可迭代对象的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while 循环</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件和DOM操作"><a href="#事件和DOM操作" class="headerlink" title="事件和DOM操作"></a>事件和DOM操作</h2><ul><li>JavaScript可以用于操作网页上的元素。通过DOM（文档对象模型）可以获取和修改HTML元素。</li><li>使用 <code>addEventListener</code> 来附加事件处理程序，例如点击事件、鼠标移动等。</li></ul><p>&lt;!DOCTYPE html&gt;</p><html><head>  <title>DOM Example</title></head><body>  <button id="myButton">Click Me</button>  <script>    const button = document.getElementById('myButton');    button.addEventListener('click', () => {      alert('Button Clicked!');    });  </script></body></html><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><ul><li>JavaScript中的异步编程非常重要。可以使用回调函数、Promise和async/await来处理异步操作，如定时器、网络请求等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 setTimeout 模拟异步操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;End&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul><li>JSON（JavaScript Object Notation）是一种数据格式，用于表示结构化数据。它在JavaScript中广泛使用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Jane&quot;, &quot;age&quot;: 25&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> parsedData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonData);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parsedData.<span class="property">name</span>); <span class="comment">// 输出：&quot;Jane&quot;</span></span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul><li>在大型项目中，模块化使代码更有组织性。可以使用 <code>import</code> 和 <code>export</code> 关键字进行模块导入和导出。</li><li>在模块中不使用export导出的内容时私有的，别的模块中不能使用import引用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 输出：7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🍔本文汇总JavaScript的基础知识点</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JavaScript" scheme="https://momoao.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://momoao.github.io/posts/202308281533.html"/>
    <id>https://momoao.github.io/posts/202308281533.html</id>
    <published>2023-08-28T07:33:03.000Z</published>
    <updated>2023-09-24T10:14:02.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>1.反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。</p><p>2.反射可以在一个类运行的时候获取类的信息的机制，可以获取在编译期不可能获得的类的信息。</p><p>3.对于任意一个对象，都能调用它的任意一个方法和属性。</p><p>4.因为类的信息是保存在Class对象中的，而这个Class对象是在程序运行时被类加载器（ClassLoader）动态加载的。</p><p>5.当类加载器装载运行了类后，动态获取Class对象的信息以及动态操作Class对象的属性和方法的功能称为Java的反射机制。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>1.反编译：.class —&gt; .java。</p><p>2.通过反射机制访问Java对象中的属性、方法、构造方法等。</p><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/format,png.png" alt="img"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/image-20230523192847278.png" alt="image-20230523192847278"></p><p>Java的反射就是利用上面第二步加载到jvm中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。</p><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p><p>类加载器层次结构</p><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/image-20230523193541423.png" alt="image-20230523193541423"></p><p>获取class的三种结构</p><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/format,png-16848418498382.png" alt="img"></p><h2 id="class类常用方法"><a href="#class类常用方法" class="headerlink" title="class类常用方法"></a>class类常用方法</h2><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>String getName()</code></td><td>返回类的全限定名。</td></tr><tr><td><code>Class&lt;?&gt; getSuperclass()</code></td><td>返回父类的Class对象。</td></tr><tr><td><code>Class&lt;?&gt;[] getInterfaces()</code></td><td>返回实现的接口的Class对象数组。</td></tr><tr><td><code>boolean isInterface()</code></td><td>判断是否是接口。</td></tr><tr><td><code>boolean isAssignableFrom(Class&lt;?&gt; cls)</code></td><td>判断是否可以赋值给指定的类。</td></tr><tr><td><code>Object newInstance()</code></td><td>创建该类的实例。</td></tr><tr><td><code>Field[] getFields()</code></td><td>返回所有公共字段的数组，包括父类的字段。</td></tr><tr><td><code>Field getField(String name)</code></td><td>返回指定名称的公共字段，包括父类的字段。</td></tr><tr><td><code>Field[] getDeclaredFields()</code></td><td>返回当前类声明的所有字段的数组，不包括父类的字段。</td></tr><tr><td><code>Field getDeclaredField(String name)</code></td><td>返回当前类声明的指定名称的字段，不包括父类的字段。</td></tr><tr><td><code>Method[] getMethods()</code></td><td>返回所有公共方法的数组，包括父类的方法。</td></tr><tr><td><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>返回指定名称和参数类型的公共方法，包括父类的方法。</td></tr><tr><td><code>Method[] getDeclaredMethods()</code></td><td>返回当前类声明的所有方法的数组，不包括父类的方法。</td></tr><tr><td><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>返回当前类声明的指定名称和参数类型的方法，不包括父类的方法。</td></tr><tr><td><code>Constructor&lt;?&gt;[] getConstructors()</code></td><td>返回所有公共构造函数的数组。</td></tr><tr><td><code>Constructor&lt;?&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></td><td>返回指定参数类型的公共构造函数。</td></tr><tr><td><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code></td><td>返回当前类声明的所有构造函数的数组。</td></tr><tr><td><code>Constructor&lt;?&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td><td>返回当前类声明的指定参数类型的构造函数。</td></tr></tbody></table></div><p>作者总结的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">getName()：获得类的完整名字。</span><br><span class="line"></span><br><span class="line">getFields()：获得类的<span class="keyword">public</span>类型的属性。</span><br><span class="line"></span><br><span class="line">getDeclaredFields()：获得类的所有属性。包括<span class="keyword">private</span> 声明的和继承类</span><br><span class="line"></span><br><span class="line">getMethods()：获得类的<span class="keyword">public</span>类型的方法。</span><br><span class="line"></span><br><span class="line">getDeclaredMethods()：获得类的所有方法。包括<span class="keyword">private</span> 声明的和继承类</span><br><span class="line"></span><br><span class="line">getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</span><br><span class="line"></span><br><span class="line">getConstructors()：获得类的<span class="keyword">public</span>类型的构造方法。</span><br><span class="line"></span><br><span class="line">getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</span><br><span class="line"></span><br><span class="line">newInstance()：通过类的构造方法创建这个类的一个对象。</span><br></pre></td></tr></table></figure><h2 id="Class类能实现的功能"><a href="#Class类能实现的功能" class="headerlink" title="Class类能实现的功能"></a>Class类能实现的功能</h2><h3 id="能实现的功能"><a href="#能实现的功能" class="headerlink" title="能实现的功能"></a>能实现的功能</h3><p>1判断对象属于哪个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">Class class2= person.getClass();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;class2：&quot;</span>+class2);</span><br><span class="line"></span><br><span class="line">输出：class2：<span class="keyword">class</span> <span class="title class_">reflect</span>.Person</span><br></pre></td></tr></table></figure><p>2获取类信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">Method[] methods = class1.getMethods();</span><br><span class="line"></span><br><span class="line">Method[] declaredMethods = class1.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">Field[] declaredFields = class1.getDeclaredFields();</span><br></pre></td></tr></table></figure><p>3构建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">Class class2= person.getClass();</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> class2.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//强转前先用instanceof判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line"></span><br><span class="line">((Person) o).workIng();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4动态执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">work</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;work&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">work.invoke(person);</span><br></pre></td></tr></table></figure><p>5动态操作属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">field.set(person,<span class="string">&quot;pine&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="动态赋值和普通赋值的区别"><a href="#动态赋值和普通赋值的区别" class="headerlink" title="动态赋值和普通赋值的区别"></a>动态赋值和普通赋值的区别</h3>]]></content>
    
    
    <summary type="html">🍔本文汇总Java反射的知识点</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://momoao.github.io/posts/202308281529.html"/>
    <id>https://momoao.github.io/posts/202308281529.html</id>
    <published>2023-08-28T07:30:03.000Z</published>
    <updated>2023-10-19T01:11:45.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h1 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h1><ol><li><p>导入Spring开发的基本包坐标</p><p><img src="../assets/image/Spring_Image/image-20230524091130200.png" alt="image-20230524091130200"></p></li><li><p>编写Dao接口和实现类</p></li><li><p>创建Spring核心配置文件</p></li><li><p>在Spring配置文件中配置UserDaoImpl</p></li><li><p>使用Spring的API获得Bean实例</p><p><img src="../assets/image/Spring_Image/image-20230524093003542.png" alt="image-20230524093003542"></p></li></ol><h1 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h1><p>默认使用无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="scope属性值"><a href="#scope属性值" class="headerlink" title="scope属性值"></a>scope属性值</h2><p><img src="../assets/image/Spring_Image/image-20230524093629771.png" alt="image-20230524093629771"></p><h3 id="singleton模式"><a href="#singleton模式" class="headerlink" title="singleton模式"></a>singleton模式</h3><p><img src="../assets/image/Spring_Image/image-20230524100219430.png" alt="image-20230524100219430"></p><h3 id="prototype模式"><a href="#prototype模式" class="headerlink" title="prototype模式"></a>prototype模式</h3><p><img src="../assets/image/Spring_Image/image-20230524110346654.png" alt="image-20230524110346654"></p><p><img src="../assets/image/Spring_Image/image-20230524110356913.png" alt="image-20230524110356913"></p><h3 id="这两个模式创建Bean的时机不同"><a href="#这两个模式创建Bean的时机不同" class="headerlink" title="这两个模式创建Bean的时机不同"></a>这两个模式创建Bean的时机不同</h3><ul><li><p>singleton模式</p><ul><li><p>在</p></li><li><p>```<br>ApplicationContext app = new ClassPathXmlApplicationContext(“applicationCOntext.xml”);</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">    -</span>   时就创建了Bean</span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span>   证明：</span><br><span class="line"></span><br><span class="line"><span class="bullet">        -</span>   ![<span class="string">image-20230524111351773</span>](<span class="link">../assets/image/Spring_Image/image-20230524111351773.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">        -</span>   在创建ApplicationContext对象的时候这个类的无参构造被调用了</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span>   prototype模式</span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span>   在</span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span>   <span class="code">```</span></span><br><span class="line"><span class="code">        UserDao userDao1 = (UserDao) app.getBean(&quot;userDao&quot;);</span></span><br></pre></td></tr></table></figure></li><li><p>时创建了Bean</p></li></ul></li></ul><h1 id="Bean实现对象实例化的三种方式"><a href="#Bean实现对象实例化的三种方式" class="headerlink" title="Bean实现对象实例化的三种方式"></a>Bean实现对象实例化的三种方式</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    无参构造--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    默认使用无参构造方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    工厂静态--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    工厂实例--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    工厂标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.DynamicFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    这个标签指定工厂bean、工厂方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="将UserDao注入给UserService的方法"><a href="#将UserDao注入给UserService的方法" class="headerlink" title="将UserDao注入给UserService的方法"></a>将UserDao注入给UserService的方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>通过有参构造将UserDao写在UserService的构造方法参数中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        这里name的userDao是setUserDao()名字中set后面的，但是首字母小写--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        这类ref中的userDao是上面那个bean的id--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        这个标签的用处是将bean userDao通过setUserDao()注入到bean userService中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../assets/image/Spring_Image/image-20230524164039354.png" alt="image-20230524164039354"></p><p><img src="../assets/image/Spring_Image/image-20230524171224135.png" alt="image-20230524171224135"></p><h3 id="p命名空间注入（本质也是set注入）"><a href="#p命名空间注入（本质也是set注入）" class="headerlink" title="p命名空间注入（本质也是set注入）"></a>p命名空间注入（本质也是set注入）</h3><p>在beans标签中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这种注入方法只需要改xml文件，不需要在UserServiceImpl类中创建setUserDao()4</p><p><strong>以上讲的是引用类型数据的注入，下面讲普通数据类型和集合类型的注入</strong></p><h1 id="普通类型数据和引用类型的注入"><a href="#普通类型数据和引用类型的注入" class="headerlink" title="普通类型数据和引用类型的注入"></a>普通类型数据和引用类型的注入</h1><p><img src="../assets/image/Spring_Image/image-20230524192930799.png" alt="image-20230524192930799"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;strList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>ppp1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>ppp2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jerry&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上海&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Bean标签的常用方法"><a href="#Bean标签的常用方法" class="headerlink" title="Bean标签的常用方法"></a>Bean标签的常用方法</h1><p><img src="../assets/image/Spring_Image/image-20230524201233971.png" alt="image-20230524201233971"></p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>指定bean的唯一标识符。</td></tr><tr><td>class</td><td>指定bean的类名。</td></tr><tr><td>name</td><td>指定bean的名称。可以使用逗号或分号分隔多个名称。</td></tr><tr><td>scope</td><td>指定bean的作用域，如singleton（单例）、prototype（原型）等。</td></tr><tr><td>constructor-arg</td><td>指定bean的构造函数参数。可以通过<code>&lt;value&gt;</code>或<code>&lt;ref&gt;</code>子元素来指定值或引用其他bean。</td></tr><tr><td>property</td><td>指定bean的属性。可以通过<code>&lt;value&gt;</code>或<code>&lt;ref&gt;</code>子元素来指定值或引用其他bean。</td></tr><tr><td>init-method</td><td>指定bean初始化时调用的方法。</td></tr><tr><td>destroy-method</td><td>指定bean销毁时调用的方法。</td></tr><tr><td>autowire</td><td>指定自动装配的方式，如byName、byType、constructor等。</td></tr><tr><td>lazy-init</td><td>指定是否延迟初始化bean。</td></tr><tr><td>depends-on</td><td>指定bean的依赖关系，即在当前bean实例化之前需要先实例化的其他bean。</td></tr><tr><td>factory-bean</td><td>指定一个工厂bean的名称，用于创建当前bean实例。</td></tr><tr><td>factory-method</td><td>指定工厂bean中用于创建当前bean实例的静态方法。</td></tr></tbody></table></div><h1 id="getBean-使用"><a href="#getBean-使用" class="headerlink" title="getBean()使用"></a>getBean()使用</h1><p><img src="../assets/image/Spring_Image/image-20230525093249319.png" alt="image-20230525093249319"></p><p>因为 </p><p><img src="../assets/image/Spring_Image/image-20230525092849583.png" alt="image-20230525092849583"></p><p>但是如果有两个bean，还通过.getBean(UserService.class)获取对象就会报错。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是<span class="keyword">Object</span>，需要强转。</span><br><span class="line">当参数的数据类型是<span class="keyword">Class</span>类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错</span><br></pre></td></tr></table></figure><h1 id="Spring配置数据源"><a href="#Spring配置数据源" class="headerlink" title="Spring配置数据源"></a>Spring配置数据源</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><img src="../assets/image/Spring_Image/image-20230525161326550.png" alt="image-20230525161326550"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><img src="../assets/image/Spring_Image/image-20230525161340641.png" alt="image-20230525161340641"></p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p><img src="../assets/image/Spring_Image/image-20230525161359050.png" alt="image-20230525161359050"></p><p><img src="../assets/image/Spring_Image/image-20230525161415108.png" alt="image-20230525161415108"></p><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><p>这种方法虽然方便，但是每种配置文件都应该有自己的职责</p><p>例如xml配置spring用</p><p>而mysql的配置放在properties中更好一些</p><p>方法五将对这种方法进行优化</p><p><img src="../assets/image/Spring_Image/image-20230525161438908.png" alt="image-20230525161438908"></p><p><img src="../assets/image/Spring_Image/image-20230525161446087.png" alt="image-20230525161446087"></p><h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><h3 id="在xml文件中创建命名空间context"><a href="#在xml文件中创建命名空间context" class="headerlink" title="在xml文件中创建命名空间context"></a>在xml文件中创建命名空间context</h3><p>复制xmlns那行粘贴在下面，后面加:context，把beans改为context</p><p>在xsi:schemaLocation的值的字符串中添加一行新数据（注意在一个字符串中），把beans改为context</p><p><img src="../assets/image/Spring_Image/image-20230525162300727.png" alt="image-20230525162300727"></p><h3 id="加载外部配置文件"><a href="#加载外部配置文件" class="headerlink" title="加载外部配置文件"></a>加载外部配置文件</h3><p><img src="../assets/image/Spring_Image/image-20230525162501007.png" alt="image-20230525162501007"></p><p>然后就可以在bean中使用properties了</p><p><img src="../assets/image/Spring_Image/image-20230525162631930.png" alt="image-20230525162631930"></p><p>test方法中使用bean</p><p><img src="../assets/image/Spring_Image/image-20230525162821705.png" alt="image-20230525162821705"></p><h1 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a>Spring注解开发</h1><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。  </p><p>Spring原始注解主要是替代<Bean>的配置</p><h2 id="原始注解"><a href="#原始注解" class="headerlink" title="原始注解"></a>原始注解</h2><p>Spring原始注解：</p><p>2、3、4号注解和1号作用一样，只是在不同的层使用不同的注解可读性强一些</p><div class="table-container"><table><thead><tr><th><strong>注解</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td>@Component</td><td style="text-align:left">使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td style="text-align:left">使用在web层类上用于实例化Bean</td></tr><tr><td>@Service</td><td style="text-align:left">使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td style="text-align:left">使用在dao层类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td style="text-align:left">使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td style="text-align:left">结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resource</td><td style="text-align:left">相当于@Autowired+@Qualifier，按照名称进行注入</td></tr><tr><td>@Value</td><td style="text-align:left">注入普通属性</td></tr><tr><td>@Scope</td><td style="text-align:left">标注Bean的作用范围</td></tr><tr><td>@PostConstruct</td><td style="text-align:left">使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestroy</td><td style="text-align:left">使用在方法上标注该方法是Bean的销毁方法</td></tr></tbody></table></div><h3 id="引用数据类型注入"><a href="#引用数据类型注入" class="headerlink" title="引用数据类型注入"></a>引用数据类型注入</h3><p>不使用注解时的开发：</p><p><img src="../assets/image/Spring_Image/image-20230525174516514.png" alt="image-20230525174516514"></p><p>使用注解的开发：</p><p><img src="../assets/image/Spring_Image/image-20230525174739036.png" alt="image-20230525174739036"></p><p><img src="../assets/image/Spring_Image/image-20230525174750940.png" alt="image-20230525174750940"></p><p><img src="../assets/image/Spring_Image/image-20230525174756764.png" alt="image-20230525174756764"></p><p>上面这个代码也可以不写set()，在属性上面写两个注解：</p><p><img src="../assets/image/Spring_Image/image-20230525175234254.png" alt="image-20230525175234254"></p><p>甚至不用@Qualifier(“userDao”)也可以</p><p>这种就是Spring根据数据类型从容器中获取（找UserDao类型的bean进行注入），但是只能有一个UserDao类型的bean，如果有多个就必须通过@Qualifier(“userDao”)来指定注入bean的id</p><p>@Qualifier每次使用都要和@Autowired搭配使用，反之则不必须</p><p><img src="../assets/image/Spring_Image/image-20230525175305381.png" alt="image-20230525175305381"></p><h3 id="普通数据类型的注入"><a href="#普通数据类型的注入" class="headerlink" title="普通数据类型的注入"></a>普通数据类型的注入</h3><p><img src="../assets/image/Spring_Image/image-20230525175940199.png" alt="image-20230525175940199"></p><p><img src="../assets/image/Spring_Image/image-20230525180137750.png" alt="image-20230525180137750"></p><p>使用上面这种时记得在xml添加外部配置文件</p><p><img src="../assets/image/Spring_Image/image-20230525180235443.png" alt="image-20230525180235443"></p><p>使用注解注入bean的scope属性</p><p><img src="../assets/image/Spring_Image/image-20230525180353087.png" alt="image-20230525180353087"></p><p>只用注解指定bean的初始化和销毁方法</p><p><img src="../assets/image/Spring_Image/image-20230525180746096.png" alt="image-20230525180746096"></p><h2 id="新注解"><a href="#新注解" class="headerlink" title="新注解"></a>新注解</h2><p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：</p><p><img src="../assets/image/Spring_Image/image-20230525181241227.png" alt="image-20230525181241227"></p><p>所以需要更多的注解</p><p>新注解：</p><p><img src="../assets/image/Spring_Image/image-20230525181337349.png" alt="image-20230525181337349"></p><p>通过注解使用配置文件中的数据</p><p>主配置类：</p><p><img src="../assets/image/Spring_Image/image-20230525183645266.png" alt="image-20230525183645266"></p><p>数据源配置类：</p><p>主要负责获得数据源（例如：读取配置文件中的信息再连接MySQL）</p><p><img src="../assets/image/Spring_Image/image-20230525183738657.png" alt="image-20230525183738657"></p><p>将配置文件中的数据读到属性中才能使用</p><p><img src="../assets/image/Spring_Image/image-20230525183837510.png" alt="image-20230525183837510"></p><p>在使用@Bean(“dataSource”)将方法的返回值，放到容器中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spring会将当前方法的返回值已指定名称存储到Spring的容器中</span><br><span class="line">和<span class="meta">@Component</span>不同的地方：</span><br><span class="line"><span class="meta">@Component</span>是通过类创建bean放到容器，可能通过</span><br><span class="line">  <span class="meta">@Autowired</span>和 <span class="meta">@Qualifier</span>对引用值注入</span><br><span class="line">  <span class="meta">@Value</span>对普通数据类型注入</span><br><span class="line">而<span class="meta">@Bean</span>是把经过方法处理的数据放到容器中</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Spring_Image/image-20230525183920925.png" alt="image-20230525183920925"></p><p>开发后的测试</p><p><img src="../assets/image/Spring_Image/image-20230525184150286.png" alt="image-20230525184150286"></p><h1 id="Spring整合JUnit"><a href="#Spring整合JUnit" class="headerlink" title="Spring整合JUnit"></a>Spring整合JUnit</h1><p>因为：</p><p><img src="../assets/image/Spring_Image/image-20230525184729697.png" alt="image-20230525184729697"></p><p>解决思路：</p><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它</li><li>将需要进行测试Bean直接在测试类中进行注入</li></ul><p>Spring集成Junit步骤：</p><p><img src="../assets/image/Spring_Image/image-20230525184839840.png" alt="image-20230525184839840"></p><p>导入坐标</p><p><img src="../assets/image/Spring_Image/image-20230525191924851.png" alt="image-20230525191924851"></p><p>写测试类运行就可以使用</p><p><img src="../assets/image/Spring_Image/image-20230525193314457.png" alt="image-20230525193314457"></p><p>就算只运行test1()，也会从applicationContext.xml中读取需要的内容</p><p><img src="../assets/image/Spring_Image/image-20230525193502055.png" alt="image-20230525193502055"></p><p><img src="../assets/image/Spring_Image/image-20230525193733099.png" alt="image-20230525193733099"></p><p><img src="../assets/image/Spring_Image/image-20230525193800525.png" alt="image-20230525193800525"></p><p>不但可以通过xml文件进行测试，也可以通过配置类来测试</p><p><img src="../assets/image/Spring_Image/image-20230525195652352.png" alt="image-20230525195652352"></p><h1 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h1><h2 id="切面-切点-通知"><a href="#切面-切点-通知" class="headerlink" title="切面=切点+通知"></a>切面=切点+通知</h2><p>什么是AOP</p><p><img src="../assets/image/Spring_Image/image-20230526151632822.png" alt="image-20230526151632822"></p><p>作用及其优势</p><p><img src="../assets/image/Spring_Image/image-20230526151657426.png" alt="image-20230526151657426"></p><p>底层实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</span><br></pre></td></tr></table></figure><h2 id="基于JDK的动态代理"><a href="#基于JDK的动态代理" class="headerlink" title="基于JDK的动态代理"></a>基于JDK的动态代理</h2><h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><p><img src="../assets/image/Spring_Image/image-20230526160309406.png" alt="image-20230526160309406"></p><h3 id="增强对象"><a href="#增强对象" class="headerlink" title="增强对象"></a>增强对象</h3><p><img src="../assets/image/Spring_Image/image-20230526160320891.png" alt="image-20230526160320891"></p><p>使用增强对象 对 目标对象的功能进行增强</p><p><img src="../assets/image/Spring_Image/image-20230526160404843.png" alt="image-20230526160404843"></p><h2 id="基于cglib的动态代理"><a href="#基于cglib的动态代理" class="headerlink" title="基于cglib的动态代理"></a>基于cglib的动态代理</h2><p>maven官方整合了cglib这个第三方包</p><p><img src="../assets/image/Spring_Image/image-20230526173343588.png" alt="image-20230526173343588"></p><h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><p><img src="../assets/image/Spring_Image/image-20230526185340919.png" alt="image-20230526185340919"></p><h2 id="AOP-开发明确的事项"><a href="#AOP-开发明确的事项" class="headerlink" title="AOP 开发明确的事项"></a>AOP 开发明确的事项</h2><p><img src="../assets/image/Spring_Image/image-20230526190210094.png" alt="image-20230526190210094"></p><h2 id="xml实现AOP"><a href="#xml实现AOP" class="headerlink" title="xml实现AOP"></a>xml实现AOP</h2><h3 id="通知（增强）的类型"><a href="#通知（增强）的类型" class="headerlink" title="通知（增强）的类型"></a>通知（增强）的类型</h3><p><img src="../assets/image/Spring_Image/image-20230527163019327.png" alt="image-20230527163019327"></p><p>增加aop命名空间</p><p><img src="../assets/image/Spring_Image/image-20230527093235236.png" alt="image-20230527093235236"></p><h3 id="使用前后置方法进行增强"><a href="#使用前后置方法进行增强" class="headerlink" title="使用前后置方法进行增强"></a>使用前后置方法进行增强</h3><p>xml中的配置</p><p><img src="../assets/image/Spring_Image/image-20230527093347536.png" alt="image-20230527093347536"></p><p>使用Spring中整合的JUnit进行测试</p><p><img src="../assets/image/Spring_Image/image-20230527093414356.png" alt="image-20230527093414356"></p><p>运行结果</p><p><img src="../assets/image/Spring_Image/image-20230527093427571.png" alt="image-20230527093427571"></p><p>切点表达式的写法：</p><p><img src="../assets/image/Spring_Image/image-20230527102831520.png" alt="image-20230527102831520"></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">指定固定的某个方法，这种表达式不常用</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.aop.Target.method())</span><br><span class="line">    </span><br><span class="line">指定Target类下的所有<span class="keyword">void</span>方法</span><br><span class="line">execution(<span class="keyword">void</span> com.itheima.aop.Target.*(..))</span><br><span class="line">    </span><br><span class="line">指定aop包下的所有类的所有方法，并且返回值任意</span><br><span class="line">execution(* com.itheima.aop.*.*(..))</span><br><span class="line">    </span><br><span class="line">指定aop包及其子包下的所有类的所有方法，并且返回值任意   </span><br><span class="line">execution(* com.itheima.aop..*.*(..))</span><br><span class="line">    </span><br><span class="line">这种没有什么意义</span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure><h3 id="使用环绕方法进行增强"><a href="#使用环绕方法进行增强" class="headerlink" title="使用环绕方法进行增强"></a>使用环绕方法进行增强</h3><p>效果和前后置一样</p><p><img src="../assets/image/Spring_Image/image-20230527162023399.png" alt="image-20230527162023399"></p><p>将之前写在两个方法中的内容，在一个环绕方法中实现</p><p><img src="../assets/image/Spring_Image/image-20230527162031929.png" alt="image-20230527162031929"></p><h3 id="对方法的异常处理进行增强"><a href="#对方法的异常处理进行增强" class="headerlink" title="对方法的异常处理进行增强"></a>对方法的异常处理进行增强</h3><p>在配置文件中</p><p><img src="../assets/image/Spring_Image/image-20230527162414419.png" alt="image-20230527162414419"></p><p>在目标方法中写一个异常</p><p><img src="../assets/image/Spring_Image/image-20230527162421234.png" alt="image-20230527162421234"></p><p>在MyAspect类中新增一个用于异常处理的方法</p><p><img src="../assets/image/Spring_Image/image-20230527162431636.png" alt="image-20230527162431636"></p><h3 id="最终增强"><a href="#最终增强" class="headerlink" title="最终增强"></a>最终增强</h3><p>在MyAspect类中新增一个用于最终增强的方法</p><p><img src="../assets/image/Spring_Image/image-20230527162649720.png" alt="image-20230527162649720"></p><p>xml中进行配置</p><p><img src="../assets/image/Spring_Image/image-20230527162714155.png" alt="image-20230527162714155"></p><p>执行结果</p><p><img src="../assets/image/Spring_Image/image-20230527162918780.png" alt="image-20230527162918780"></p><p>有异常时的增强</p><p><img src="../assets/image/Spring_Image/image-20230527162938700.png" alt="image-20230527162938700"></p><h3 id="xml中更好的写法"><a href="#xml中更好的写法" class="headerlink" title="xml中更好的写法"></a>xml中更好的写法</h3><p>通过表达式</p><p><img src="../assets/image/Spring_Image/image-20230527173053857.png" alt="image-20230527173053857"></p><h2 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h2><p>开发步骤</p><p><img src="../assets/image/Spring_Image/image-20230527173932228.png" alt="image-20230527173932228"></p><p>切点表达式用于指明对哪些方法进行增强</p><p>目标类用注解加载进容器中</p><p><img src="../assets/image/Spring_Image/image-20230527180726305.png" alt="image-20230527180726305"></p><p>带有通知的类通过注解加载到容器中，并指明这个类是切面类</p><p><img src="../assets/image/Spring_Image/image-20230527181017239.png" alt="image-20230527181017239"></p><p>将通知加载到容器中，需指明切点表达式</p><p><img src="../assets/image/Spring_Image/image-20230527181044398.png" alt="image-20230527181044398"></p><p>在xml中开启组件扫描、开启aop自动代理</p><p><img src="../assets/image/Spring_Image/image-20230527181139590.png" alt="image-20230527181139590"></p><p>在测试类中进行测试</p><p><img src="../assets/image/Spring_Image/image-20230527181156639.png" alt="image-20230527181156639"></p><p>基于注解的AOP开发的知识要点</p><p><img src="../assets/image/Spring_Image/image-20230527181339131.png" alt="image-20230527181339131"></p><h1 id="jdbc模板"><a href="#jdbc模板" class="headerlink" title="jdbc模板"></a>jdbc模板</h1><ol><li>创建数据源</li><li>创建模板</li><li>设置模板的数据源对象</li><li>执行操作</li></ol><p><img src="../assets/image/Spring_Image/image-20230527194006087.png" alt="image-20230527194006087"></p><p>将上面图片中的操作变为spring xml中的操作就是</p><p><img src="../assets/image/Spring_Image/image-20230527194833220.png" alt="image-20230527194833220"></p><p><img src="../assets/image/Spring_Image/image-20230527195216939.png" alt="image-20230527195216939"></p><p>把数据库信息放在properties中</p><p>添加命名空间、加载配置文件</p><p><img src="../assets/image/Spring_Image/image-20230527195632141.png" alt="image-20230527195632141"></p><p>用SpringJunit4进行测试</p><p><img src="../assets/image/Spring_Image/image-20230527200240194.png" alt="image-20230527200240194"></p><p>查询</p><p>查询多列（加多行）数据和单个数据</p><p><img src="../assets/image/Spring_Image/image-20230527203751932.png" alt="image-20230527203751932"></p><p>用Account类进行接受数据的操作</p><p>类中必须含有查询出来的结果的对应属性</p><p><strong>并且必须有这写属性的set()   可以没有get()</strong>   </p><p><strong>类的属性名和数据库的列名必须相同</strong></p><p><img src="../assets/image/Spring_Image/image-20230527204144865.png" alt="image-20230527204144865"></p><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><p><img src="../assets/image/Spring_Image/image-20230527204723426.png" alt="image-20230527204723426"></p><h1 id="Spring事务控制"><a href="#Spring事务控制" class="headerlink" title="Spring事务控制"></a>Spring事务控制</h1><h2 id="编程式事务控制"><a href="#编程式事务控制" class="headerlink" title="编程式事务控制"></a>编程式事务控制</h2><h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p><img src="../assets/image/Spring_Image/image-20230528171824146.png" alt="image-20230528171824146"></p><h3 id="事务隔离等级"><a href="#事务隔离等级" class="headerlink" title="事务隔离等级"></a>事务隔离等级</h3><p>最后一个：串行化    相当于锁表</p><p><img src="../assets/image/Spring_Image/image-20230528172103438.png" alt="image-20230528172103438"></p><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><img src="../assets/image/Spring_Image/image-20230528172218278.png" alt="image-20230528172218278"></p><h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p><img src="../assets/image/Spring_Image/image-20230528173344446.png" alt="image-20230528173344446"></p><h3 id="编程式事务控制三大对象"><a href="#编程式事务控制三大对象" class="headerlink" title="编程式事务控制三大对象"></a>编程式事务控制三大对象</h3><p>根据DAO层采用不同的技术时，用不同的对象控制</p><p><img src="../assets/image/Spring_Image/image-20230528174020171.png" alt="image-20230528174020171"></p><h2 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h2><h3 id="基于XML"><a href="#基于XML" class="headerlink" title="基于XML"></a>基于XML</h3><p>什么是声明式事务控制</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Spring</span> 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</span><br></pre></td></tr></table></figure><p>声明式事务处理的作用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</span><br><span class="line">在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</span><br></pre></td></tr></table></figure><p><strong>注意：Spring 声明式事务控制底层就是AOP</strong>（面向切面编程）</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p><img src="../assets/image/Spring_Image/image-20230528175846163.png" alt="image-20230528175846163"></p><h4 id="在xml文件中"><a href="#在xml文件中" class="headerlink" title="在xml文件中"></a>在xml文件中</h4><p>1.配置数据源</p><p><img src="../assets/image/Spring_Image/image-20230531090016333.png" alt="image-20230531090016333"></p><p>2.配置jdbc模板</p><p>里面注入数据源</p><p><img src="../assets/image/Spring_Image/image-20230531090144429.png" alt="image-20230531090144429"></p><p>3.配置自己写的持久层类</p><p>注入jdbc模板给这个类的属性</p><p><img src="../assets/image/Spring_Image/image-20230531090402268.png" alt="image-20230531090402268"></p><p><img src="../assets/image/Spring_Image/image-20230531090255770.png" alt="image-20230531090255770"></p><p>4.配置自己写的业务层类</p><p>注入持久层类</p><p><img src="../assets/image/Spring_Image/image-20230531090342933.png" alt="image-20230531090342933"></p><p><img src="../assets/image/Spring_Image/image-20230531090424272.png" alt="image-20230531090424272"></p><p>5.配置平台事务管理器</p><p>注入数据源</p><p><img src="../assets/image/Spring_Image/image-20230531090519305.png" alt="image-20230531090519305"></p><p>6.事务（事务管理器）的增强</p><p>先指定事务管理器</p><p>然后添加事务的属性</p><p>​    [方法名]    [隔离等级]    [是否只读]</p><p>如果设置只读，name这个方法只能读数据库不能写</p><p><img src="../assets/image/Spring_Image/image-20230531092715160.png" alt="image-20230531092715160"></p><p>7.用aop将事务的增强织入到切点表达式中</p><p>虽然上面指定了需要事务控制的方法名，但是aop织入的时候也要指定将哪个事务增强织入到哪个切点表达式中</p><p><img src="../assets/image/Spring_Image/image-20230531090952569.png" alt="image-20230531090952569"></p><h3 id="基于注解的声明式事务控制"><a href="#基于注解的声明式事务控制" class="headerlink" title="基于注解的声明式事务控制"></a>基于注解的声明式事务控制</h3><p>在xml中</p><p>开启组件扫描、添加数据源、添加jdbc模板、添加事务控制管理器、事务的注解驱动</p><p>其中jdbc模板和事务管理器都要注入数据源</p><p><strong>不加注解驱动注解可能不起作用</strong></p><p><img src="../assets/image/Spring_Image/image-20230531095808450.png" alt="image-20230531095808450"></p><p>持久层</p><p>注入jdbc模板</p><p><img src="../assets/image/Spring_Image/image-20230531095826459.png" alt="image-20230531095826459"></p><p>业务层</p><p>注入持久层</p><p>给需要事务控制的方法使用注解@Transactional</p><p>通过给注解添加属性(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)</p><p>实现隔离等级、传播、是否只读的设置</p><p><img src="../assets/image/Spring_Image/image-20230531095852416.png" alt="image-20230531095852416"></p><h1 id="Spring集成web环境"><a href="#Spring集成web环境" class="headerlink" title="Spring集成web环境"></a>Spring集成web环境</h1><p>pom.xml中添加两个新的坐标</p><p><img src="../assets/image/Spring_Image/image-20230601154914365.png" alt="image-20230601154914365"></p><p>web层</p><p><img src="../assets/image/Spring_Image/image-20230601160436675.png" alt="image-20230601160436675"></p><p>服务层</p><p><img src="../assets/image/Spring_Image/image-20230601160451287-16856066914451.png" alt="image-20230601160451287"></p><p>持久层</p><p><img src="../assets/image/Spring_Image/image-20230601160502709.png" alt="image-20230601160502709"></p><p>applicationContext.xml中把Dao注入到Service中</p><p><img src="../assets/image/Spring_Image/image-20230601160534406.png" alt="image-20230601160534406"></p><p>web层调用—&gt;Service—&gt;Dao</p><p>每次使用web层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>都要加载配置文件和创建应用上下文对象</p><p><img src="../assets/image/Spring_Image/image-20230601160821601.png" alt="image-20230601160821601"></p><p>解决方法：</p><p><img src="../assets/image/Spring_Image/image-20230601161003281.png" alt="image-20230601161003281"></p><h2 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="web-xml中"><a href="#web-xml中" class="headerlink" title="web.xml中"></a>web.xml中</h3><p>配置全局上下文参数，在代码中可以通过name访问value的值</p><p>这样改配置文件的时候就不用改代码了</p><p><img src="../assets/image/Spring_Image/image-20230601181728122.png" alt="image-20230601181728122"></p><p>配置监听器</p><p><img src="../assets/image/Spring_Image/image-20230601181837657.png" alt="image-20230601181837657"></p><p>总结</p><p><img src="../assets/image/Spring_Image/image-20230601182916680.png" alt="image-20230601182916680"></p><p><strong>MVC == Model  View  Control</strong></p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>概述</p><p><img src="../assets/image/Spring_Image/image-20230601190911958.png" alt="image-20230601190911958"></p><h2 id="开发步骤-2"><a href="#开发步骤-2" class="headerlink" title="开发步骤"></a>开发步骤</h2><p><img src="../assets/image/Spring_Image/image-20230602152213016.png" alt="image-20230602152213016"></p><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>配置前端控制器</p><p><img src="../assets/image/Spring_Image/image-20230602162411110.png" alt="image-20230602162411110"></p><p>配置全局初始化参数</p><p>将优先初始化这个资源xml文件</p><p><img src="../assets/image/Spring_Image/image-20230602162502572.png" alt="image-20230602162502572"></p><p>配置监听器</p><p><img src="../assets/image/Spring_Image/image-20230602162714540.png" alt="image-20230602162714540"></p><p>配置自己的映射</p><p>网址后加上/userServelet将运行com.itheima.web.UserServelet类中的doGet()</p><p><img src="../assets/image/Spring_Image/image-20230602162742705.png" alt="image-20230602162742705"></p><p><img src="../assets/image/Spring_Image/image-20230602162839136.png" alt="image-20230602162839136"></p><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><p><img src="../assets/image/Spring_Image/image-20230602162924426.png" alt="image-20230602162924426"></p><h3 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h3><p>配置组件扫描，用于扫描包中的注解</p><p><img src="../assets/image/Spring_Image/image-20230602163017412.png" alt="image-20230602163017412"></p><h3 id="webapp"><a href="#webapp" class="headerlink" title="webapp"></a>webapp</h3><p>下面创建一个网页success.jsp</p><p><img src="../assets/image/Spring_Image/image-20230602163052149.png" alt="image-20230602163052149"></p><p>在组件扫描的包中写个类，用于链接到success.jsp</p><p>该类使用@Controller将这个类加载到spring容器中</p><p>使用@RequestMapping(“/quick”)指定了网址，在网址后加上这个就可以访问这个方法返回的String指定位置的文件</p><p><img src="../assets/image/Spring_Image/image-20230602163141705.png" alt="image-20230602163141705"></p><h2 id="程序寻找顺序"><a href="#程序寻找顺序" class="headerlink" title="程序寻找顺序"></a>程序寻找顺序</h2><p>输入localhost:8080/quick后</p><p>先找Tomcat</p><p>然后在web.xml因为有前端控制器并且</p><p><url-pattern>/&lt;/url-pattern&gt;</p><p>表示找任何地址都先经过这个控制器</p><p>然后就能找到/quick了</p><p><img src="../assets/image/Spring_Image/image-20230602163424126.png" alt="image-20230602163424126"></p><p>能找到/quick是因为资源配置文件spring-mvc.xml中开启了包com.itheima.controller的扫描</p><p><img src="../assets/image/Spring_Image/image-20230602163820093.png" alt="image-20230602163820093"></p><p>然后在这个包中有个类</p><p>通过注解将这个类加到了容器中，而用注解@RequestMapping(“/quick”)注解的方法，当输入这个网址时就会调用，执行完方法后，链接到返回的String指引的文件上</p><p><img src="../assets/image/Spring_Image/image-20230603110612766.png" alt="image-20230603110612766"></p><p>success.jsp文件中是html代码</p><p><img src="../assets/image/Spring_Image/image-20230602164008972.png" alt="image-20230602164008972"></p><h2 id="逻辑流程图"><a href="#逻辑流程图" class="headerlink" title="逻辑流程图"></a>逻辑流程图</h2><p><img src="../assets/image/Spring_Image/image-20230603093641452.png" alt="image-20230603093641452"></p><h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h2><p><img src="../assets/image/Spring_Image/image-20230603094019177.png" alt="image-20230603094019177"></p><h2 id="组件解析"><a href="#组件解析" class="headerlink" title="组件解析"></a>组件解析</h2><p><img src="../assets/image/Spring_Image/image-20230603100720670.png" alt="image-20230603100720670"></p><p><img src="../assets/image/Spring_Image/image-20230603100743066.png" alt="image-20230603100743066"></p><p>在使用组件扫描时可以以指定扫描包含哪些注解或除去哪些注解</p><p><img src="../assets/image/Spring_Image/image-20230603141215035.png" alt="image-20230603141215035"></p><p>配置内部资源解析器</p><p>在配置之前，因为jsp文件都在jsp文件夹中，所以return的值要写前缀和后缀（.jsp）</p><p><img src="../assets/image/Spring_Image/image-20230603141255107.png" alt="image-20230603141255107"></p><p>配置之后，只需要写文件名</p><p><img src="../assets/image/Spring_Image/image-20230603141349511.png" alt="image-20230603141349511"></p><p>在spring-mvc.xml中配置</p><p>表示为每个带有@RequestMapping注解的方法返回的String加上前后缀</p><p><img src="../assets/image/Spring_Image/image-20230603141418537.png" alt="image-20230603141418537"></p><h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><p><img src="../assets/image/Spring_Image/image-20230603100808598.png" alt="image-20230603100808598"></p><p>例如：</p><p><img src="../assets/image/Spring_Image/image-20230603111806588.png" alt="image-20230603111806588"></p><p>需要的url链接必须要有参数usernmae l</p><p><img src="../assets/image/Spring_Image/image-20230603111841101.png" alt="image-20230603111841101"></p><h2 id="SpringMVC相关组件"><a href="#SpringMVC相关组件" class="headerlink" title="SpringMVC相关组件"></a>SpringMVC相关组件</h2><p><img src="../assets/image/Spring_Image/image-20230603141627910.png" alt="image-20230603141627910"></p><p>在return “suuccess”时默认前面带forward，意思是在当前网址后加上后访问的目录。如果写return “redirect:suuccess”就会把网址变为localhost:8080/success   而不是网址叠加</p><p><img src="../assets/image/Spring_Image/image-20230603142014109.png" alt="image-20230603142014109"></p><h1 id="浏览器请求方式"><a href="#浏览器请求方式" class="headerlink" title="浏览器请求方式"></a>浏览器请求方式</h1><p><img src="../assets/image/Spring_Image/image-20230603111430937.png" alt="image-20230603111430937"></p><h1 id="SpringMVC数据响应"><a href="#SpringMVC数据响应" class="headerlink" title="SpringMVC数据响应"></a>SpringMVC数据响应</h1><h2 id="数据响应方式"><a href="#数据响应方式" class="headerlink" title="数据响应方式"></a>数据响应方式</h2><p><img src="../assets/image/Spring_Image/image-20230603142722394.png" alt="image-20230603142722394"></p><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>返回字符串形式</p><p><img src="../assets/image/Spring_Image/image-20230603143115529.png" alt="image-20230603143115529"></p><p>返回ModelAndView形式</p><p><img src="../assets/image/Spring_Image/image-20230603143228470.png" alt="image-20230603143228470"></p><p>数据在jsp文件中可以使用${键名}的方式提取</p><p><img src="../assets/image/Spring_Image/image-20230603143902717.png" alt="image-20230603143902717"></p><p><img src="../assets/image/Spring_Image/image-20230603143943620.png" alt="image-20230603143943620"></p><p>springMVC框架会检测参数，可以自动提供一个ModelAndView对象</p><p><img src="../assets/image/Spring_Image/image-20230603144544631.png" alt="image-20230603144544631"></p><p>也可以单独返回Model</p><p>但是不设置视图的话，会自动查找</p><p><img src="../assets/image/Spring_Image/image-20230603144831279.png" alt="image-20230603144831279"></p><p><img src="../assets/image/Spring_Image/image-20230603145121111.png" alt="image-20230603145121111"></p><h3 id="回写数据"><a href="#回写数据" class="headerlink" title="回写数据"></a>回写数据</h3><h4 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h4><p>方法1</p><p><img src="../assets/image/Spring_Image/image-20230603150457780.png" alt="image-20230603150457780"></p><p>方法2</p><p><img src="../assets/image/Spring_Image/image-20230603150536247.png" alt="image-20230603150536247"></p><p>返回json字符串，使用ObjectMapper将对象转换为json字符串</p><p><img src="../assets/image/Spring_Image/image-20230603151501882.png" alt="image-20230603151501882"></p><h4 id="返回对象或集合"><a href="#返回对象或集合" class="headerlink" title="返回对象或集合"></a>返回对象或集合</h4><p>可以通过配置处理器映射器来告诉SpringMVC框架自动将消息转换</p><p>自动将返回的对象转换为json字符串</p><p><img src="../assets/image/Spring_Image/image-20230603152340236.png" alt="image-20230603152340236"></p><p><img src="../assets/image/Spring_Image/image-20230603152353202.png" alt="image-20230603152353202"></p><p>可以配置mvc注解驱动来让mvc自己调用映射器，而不用自己配置</p><p><img src="../assets/image/Spring_Image/image-20230603152959755.png" alt="image-20230603152959755"></p><p><strong>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</strong></p><h1 id="SpringMVC获得请求数据"><a href="#SpringMVC获得请求数据" class="headerlink" title="SpringMVC获得请求数据"></a>SpringMVC获得请求数据</h1><p><img src="../assets/image/Spring_Image/image-20230603155305748.png" alt="image-20230603155305748"></p><h2 id="基本类型数据"><a href="#基本类型数据" class="headerlink" title="基本类型数据"></a>基本类型数据</h2><p><img src="../assets/image/Spring_Image/image-20230603160109243.png" alt="image-20230603160109243"></p><h2 id="POJO类型参数"><a href="#POJO类型参数" class="headerlink" title="POJO类型参数"></a>POJO类型参数</h2><p>输入的参数和User类的属性名一致，就可以自动封装</p><p><img src="../assets/image/Spring_Image/image-20230603160333507.png" alt="image-20230603160333507"></p><h2 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h2><p><img src="../assets/image/Spring_Image/image-20230603160957402.png" alt="image-20230603160957402"></p><p><img src="../assets/image/Spring_Image/image-20230603161003841.png" alt="image-20230603161003841"></p><h2 id="集合类型参数"><a href="#集合类型参数" class="headerlink" title="集合类型参数"></a>集合类型参数</h2><p>第一种方法</p><p>还是封装在类中</p><p><img src="../assets/image/Spring_Image/image-20230603172517789.png" alt="image-20230603172517789"></p><p><img src="../assets/image/Spring_Image/image-20230603172529481.png" alt="image-20230603172529481"></p><p>在jsp文件中使用表单提交集合对象，要求和类中的属性名一致。可以指定集合中第几个元素的某个属性</p><p><img src="../assets/image/Spring_Image/image-20230603172552484.png" alt="image-20230603172552484"></p><p>第二种方法</p><p>直接接收由浏览器页面发出的数据</p><p>使用jquery包中的方法，发送数据</p><p>访问ajax.jsp</p><p><img src="../assets/image/Spring_Image/image-20230604201620098.png" alt="image-20230604201620098"></p><p><img src="../assets/image/Spring_Image/image-20230604201336222.png" alt="image-20230604201336222"></p><p>并将jquery的访问权限开放，不然浏览器可能跳转到jquery时就停止跳转</p><p>在spring-mvc.xml中配置对jquery资源的访问权限</p><p><img src="../assets/image/Spring_Image/image-20230604202315828.png" alt="image-20230604202315828"></p><p>之后访问ajax.jsp，浏览器的跳转顺序就会这样</p><p><img src="../assets/image/Spring_Image/image-20230604202350908.png" alt="image-20230604202350908"></p><p>还有一种开放资源的办法</p><p><img src="../assets/image/Spring_Image/image-20230604203052408.png" alt="image-20230604203052408"></p><h2 id="参数绑定注解"><a href="#参数绑定注解" class="headerlink" title="参数绑定注解"></a>参数绑定注解</h2><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。</p><p>如果网址后提交的参数不是username是name就这样改</p><p><img src="../assets/image/Spring_Image/image-20230604203429433.png" alt="image-20230604203429433"></p><p>改完之后就只能用name提交了，因为有这个注解的存在，会将name的值映射到username上</p><p>@RequestParam注解的其他参数</p><p><img src="../assets/image/Spring_Image/image-20230604203836242.png" alt="image-20230604203836242"></p><p>默认name参数不必须包含，提交后打印值为null</p><p><img src="../assets/image/Spring_Image/image-20230604203927135.png" alt="image-20230604203927135"></p><p><img src="../assets/image/Spring_Image/image-20230604203952230.png" alt="image-20230604203952230"></p><p>使用了默认值，提交后打印itcast</p><p><img src="../assets/image/Spring_Image/image-20230604204045987.png" alt="image-20230604204045987"></p><p><img src="../assets/image/Spring_Image/image-20230604204054637.png" alt="image-20230604204054637"></p><h2 id="获取Restful风格的参数"><a href="#获取Restful风格的参数" class="headerlink" title="获取Restful风格的参数"></a>获取Restful风格的参数</h2><p>在网址中写入请求方式</p><p><img src="../assets/image/Spring_Image/image-20230605162451916.png" alt="image-20230605162451916"></p><p>@PathVariable中的value必须和@RequestMapping相同，但是可以和参数中的String不同</p><p><img src="../assets/image/Spring_Image/image-20230605162842599.png" alt="image-20230605162842599"></p><p>使用：</p><p><img src="../assets/image/Spring_Image/image-20230605163339876.png" alt="image-20230605163339876"></p><p><img src="../assets/image/Spring_Image/image-20230605163344930.png" alt="image-20230605163344930"></p><h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><p><img src="../assets/image/Spring_Image/image-20230605163640580.png" alt="image-20230605163640580"></p><p>像这种int age框架虽然接收的是String，但是会自动转换后传给参数</p><p><img src="../assets/image/Spring_Image/image-20230605163703848.png" alt="image-20230605163703848"></p><p>手动实现类型转换</p><p>实现背景：</p><p><img src="../assets/image/Spring_Image/image-20230605192805294.png" alt="image-20230605192805294"></p><p><img src="../assets/image/Spring_Image/image-20230605192906187.png" alt="image-20230605192906187"></p><p>提交数据时，默认需要接收用/的时间格式，但是提交时如果用了-分离就会报错，下面写一个格式转换器来进行格式转换</p><p>先写一个用于将String转换为Date的类，实现了接口Converter</p><p><img src="../assets/image/Spring_Image/image-20230605194004702.png" alt="image-20230605194004702"></p><p>然后在spring-mvc.xml中配置</p><p>声明一个工厂用于创建自己写的格式转换器</p><p><img src="../assets/image/Spring_Image/image-20230605194052205.png" alt="image-20230605194052205"></p><p>同时也要更改MVC的注解驱动</p><p><img src="../assets/image/Spring_Image/image-20230605194156791.png" alt="image-20230605194156791"></p><h2 id="获得请求头"><a href="#获得请求头" class="headerlink" title="获得请求头"></a>获得请求头</h2><p><img src="../assets/image/Spring_Image/image-20230605195538973.png" alt="image-20230605195538973"></p><p>自己写的方法</p><p><img src="../assets/image/Spring_Image/image-20230605195947915.png" alt="image-20230605195947915"></p><p>访问</p><p><img src="../assets/image/Spring_Image/image-20230605195953802.png" alt="image-20230605195953802"></p><p>然后输出的就是请求头中属性User-Agent对应的值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Mozilla</span>/<span class="number">5</span>.<span class="number">0</span> (Windows NT <span class="number">10</span>.<span class="number">0</span>; Win64; x64) AppleWebKit/<span class="number">537</span>.<span class="number">36</span> (KHTML, like Gecko) Chrome/<span class="number">114.0.0.0</span> Safari/<span class="number">537</span>.<span class="number">36</span></span><br></pre></td></tr></table></figure><p>当然还有其他属性的信息都可以获取（Cookie除外）</p><p><img src="../assets/image/Spring_Image/image-20230605200132776.png" alt="image-20230605200132776"></p><p><img src="../assets/image/Spring_Image/image-20230605200139984.png" alt="image-20230605200139984"></p><p>也可以设置为这个信息不必须提交，这样就算请求头中没有User-Agent属性，也可以继续访问</p><p><img src="../assets/image/Spring_Image/image-20230605200308335.png" alt="image-20230605200308335"></p><p>Cookie值特殊，需要用特殊的注解获取@CookieValue</p><p><img src="../assets/image/Spring_Image/image-20230605200445310.png" alt="image-20230605200445310"></p><p><img src="../assets/image/Spring_Image/image-20230605200739049.png" alt="image-20230605200739049"></p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="文件上传客户端三要素"><a href="#文件上传客户端三要素" class="headerlink" title="文件上传客户端三要素"></a>文件上传客户端三要素</h3><p><img src="../assets/image/Spring_Image/image-20230606083616517.png" alt="image-20230606083616517"></p><p>文件上传原理</p><p><img src="../assets/image/Spring_Image/image-20230606084525462.png" alt="image-20230606084525462"></p><h3 id="单文件上传步骤"><a href="#单文件上传步骤" class="headerlink" title="单文件上传步骤"></a>单文件上传步骤</h3><p><img src="../assets/image/Spring_Image/image-20230606084701980.png" alt="image-20230606084701980"></p><p>第一步</p><p><img src="../assets/image/Spring_Image/image-20230606084721236.png" alt="image-20230606084721236"></p><p>第二步</p><p><img src="../assets/image/Spring_Image/image-20230606084849265.png" alt="image-20230606084849265"></p><p>第三步</p><p><img src="../assets/image/Spring_Image/image-20230607100141415.png" alt="image-20230607100141415"></p><p>如果不指定路径，默认为</p><p><img src="../assets/image/Spring_Image/image-20230607101118195.png" alt="image-20230607101118195"></p><h1 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><img src="../assets/image/Spring_Image/image-20230607110544253.png" alt="image-20230607110544253"></p><p>主义：只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的</p><h2 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h2><p><img src="../assets/image/Spring_Image/image-20230607111126956.png" alt="image-20230607111126956"></p><h2 id="自定义拦截器创建"><a href="#自定义拦截器创建" class="headerlink" title="自定义拦截器创建"></a>自定义拦截器创建</h2><p><img src="../assets/image/Spring_Image/image-20230607111300321.png" alt="image-20230607111300321"></p><p>1、写拦截器的类，实现HandlerInterceptor接口</p><p>接口中有3个方法，并且都有方法体，所以实现HandlerInterceptor接口后没有必须要重写的方法，只是需要哪个就重写哪个就行了</p><p>HandlerInterceptor接口内容：</p><p><img src="../assets/image/Spring_Image/image-20230607122443128.png" alt="image-20230607122443128"></p><p>写拦截器用的类；</p><p><img src="../assets/image/Spring_Image/image-20230607122512532.png" alt="image-20230607122512532"></p><p>其中的方法：</p><p>preHandle()</p><p>​    这个方法在要拦截的内容方法前执行</p><p>​    其中可以做一些处理，方法返回值为true时才会调用下一个          preHandle()或者目标资源，如果返回false则不会调用。所以可以在返回false前做一些处理，例如返回一个专门显示错误信息的jsp</p><p>postHandle()</p><p>​    这个方法在拦截的方法后执行，但在视图对象返回之前</p><p>afterCompletion()</p><p>​    最后执行</p><p>然后在spring-mvc.xml中配置</p><p>这里配置了两个拦截器，也就形成了拦截器链</p><p><img src="../assets/image/Spring_Image/image-20230607122823858.png" alt="image-20230607122823858"></p><p>执行顺序：MyInterceptor2的preHandle()  —-&gt;  MyInterceptor1的preHandle()  —-&gt;  目标资源执行  —-&gt;  MyInterceptor1的postHandle()  —-&gt;  MyInterceptor2的postHandle()  —-&gt;  视图对象返回  —-&gt;  MyInterceptor1的afterCompletion()  —-&gt;  MyInterceptor2的afterCompletion()</p><p><img src="../assets/image/Spring_Image/image-20230607122923203.png" alt="image-20230607122923203"></p><p>注意：执行顺序中在拦截器链前面的类的方法在目标资源执行前先执行，之后在拦截器链前面的类的方法都后执行</p><p>拦截器的方法详细说明：</p><p><img src="../assets/image/Spring_Image/image-20230607123702698.png" alt="image-20230607123702698"></p><h2 id="案例-用户登录权限控制"><a href="#案例-用户登录权限控制" class="headerlink" title="案例-用户登录权限控制"></a>案例-用户登录权限控制</h2><p><img src="../assets/image/Spring_Image/image-20230607192734604.png" alt="image-20230607192734604"></p><p>拦截器也可以配置不拦截哪些资源</p><p><img src="../assets/image/Spring_Image/image-20230607193905008.png" alt="image-20230607193905008"></p><h1 id="SpringMVC异常处理"><a href="#SpringMVC异常处理" class="headerlink" title="SpringMVC异常处理"></a>SpringMVC异常处理</h1><h2 id="异常处理的思路"><a href="#异常处理的思路" class="headerlink" title="异常处理的思路"></a>异常处理的思路</h2><p><img src="../assets/image/Spring_Image/image-20230607195612215.png" alt="image-20230607195612215"></p><p>配置异常处理器，在spring-mvc.xml中</p><p>配置默认错误视图和指定错误对应的视图</p><p><img src="../assets/image/Spring_Image/image-20230607202438481.png" alt="image-20230607202438481"></p><p>写一个专门抛出异常的类</p><p><img src="../assets/image/Spring_Image/image-20230607203325123.png" alt="image-20230607203325123"></p><p>在web层调用</p><p><img src="../assets/image/Spring_Image/image-20230607203359140.png" alt="image-20230607203359140"></p><h2 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h2><p>show5()抛出的就是自定义异常</p><p>写一个自定义异常类，继承Exception</p><p><img src="../assets/image/Spring_Image/image-20230607203530172.png" alt="image-20230607203530172"></p><p>写一个自定义异常处理器类，实现HandlerExceptionResolver</p><p><img src="../assets/image/Spring_Image/image-20230607203629158.png" alt="image-20230607203629158"></p><p>在spring-mvc.xml中声明这个类</p><p><img src="../assets/image/Spring_Image/image-20230607203813066.png" alt="image-20230607203813066"></p><p>和SpringMVC自带的异常处理器不同，自己写的异常处理器在spring-mvc.xml中声明要断的多，只需要一个bean，框架就可以调用类中的resolveException()来处理异常。</p><p>如果配置了多个异常处理器，其中都有同一个异常，那框架以在上面声明的异常处理器为主</p><p><img src="../assets/image/Spring_Image/image-20230607204705168.png" alt="image-20230607204705168"></p><h2 id="总结：异常处理步骤"><a href="#总结：异常处理步骤" class="headerlink" title="总结：异常处理步骤"></a>总结：异常处理步骤</h2><ol><li>创建异常处理器类实现HandlerExceptionResolver接口</li><li>配置异常处理器</li><li>编写异常页面</li><li>测试异常跳转</li></ol><h1 id="Spring-SpringMVC练习"><a href="#Spring-SpringMVC练习" class="headerlink" title="Spring+SpringMVC练习"></a>Spring+SpringMVC练习</h1><p>web层</p><p>​    尽量一个方法解决问题，将传入的参数传个这个方法</p><p>service层</p><p>​    尽量将大问题拆成几个小步骤，调用若干个方法进行实现</p><p>dao层</p><p>​    实现若干个小方法，留个service层调用</p><h2 id="环境搭建步骤"><a href="#环境搭建步骤" class="headerlink" title="环境搭建步骤"></a>环境搭建步骤</h2><p><img src="../assets/image/Spring_Image/image-20230608202124896.png" alt="image-20230608202124896"></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="web-xml-1"><a href="#web-xml-1" class="headerlink" title="web.xml"></a>web.xml</h4><ol><li>全局初始化参数</li><li>配置Spring监听器</li><li>SpringMVC前端控制器</li></ol><p><img src="../assets/image/Spring_Image/image-20230609112404748.png" alt="image-20230609112404748"></p><h4 id="spring-mvc-xml-1"><a href="#spring-mvc-xml-1" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h4><ol><li>MVC注解驱动</li><li>视图解析器</li><li>静态资源权限全开放</li></ol><p><img src="../assets/image/Spring_Image/image-20230609160409257.png" alt="image-20230609160409257"></p><h4 id="applicationContext-xml-1"><a href="#applicationContext-xml-1" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h4><ol><li>加载jdbc.properties配置文件</li><li>配置数据源</li><li>配置jdbc模板</li></ol><p><img src="../assets/image/Spring_Image/image-20230609112644396.png" alt="image-20230609112644396"></p><h4 id="给每个表编写一个类"><a href="#给每个表编写一个类" class="headerlink" title="给每个表编写一个类"></a>给每个表编写一个类</h4><p><img src="../assets/image/Spring_Image/image-20230609163953792.png" alt="image-20230609163953792"></p><p><img src="../assets/image/Spring_Image/image-20230609164003304.png" alt="image-20230609164003304"></p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>用户和角色之间是多对多关系</p><p>​        一个用户可以有多个角色，一个角色可以被多个用户拥有，所以他们之间的关系用另一个表记录</p><p><img src="../assets/image/Spring_Image/image-20230609113549707.png" alt="image-20230609113549707"></p><p>CEO:首席执行官</p><p>COO:首席运营官</p><p>CFO:首席财务官</p><p>CTO:首席技术官</p><p>role表</p><p><img src="../assets/image/Spring_Image/image-20230609113623333.png" alt="image-20230609113623333"></p><p>user表</p><p><img src="../assets/image/Spring_Image/image-20230609113639037.png" alt="image-20230609113639037"></p><p>user_role表：</p><p><img src="../assets/image/Spring_Image/image-20230609113655789.png" alt="image-20230609113655789"></p><h3 id="角色列表展示"><a href="#角色列表展示" class="headerlink" title="角色列表展示"></a>角色列表展示</h3><h4 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h4><p><img src="../assets/image/Spring_Image/image-20230609150749690.png" alt="image-20230609150749690"></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><img src="../assets/image/Spring_Image/image-20230609150758116.png" alt="image-20230609150758116"></p><h5 id="打开组件扫描"><a href="#打开组件扫描" class="headerlink" title="打开组件扫描"></a>打开组件扫描</h5><p>spring-mvc.xml</p><p><img src="../assets/image/Spring_Image/image-20230609163626091.png" alt="image-20230609163626091"></p><h5 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h5><p><img src="../assets/image/Spring_Image/image-20230609185121145.png" alt="image-20230609185121145"></p><h5 id="配置Dao层和Service的Bean"><a href="#配置Dao层和Service的Bean" class="headerlink" title="配置Dao层和Service的Bean"></a>配置Dao层和Service的Bean</h5><p>applicationCOntext.xml</p><p><img src="../assets/image/Spring_Image/image-20230609163751635.png" alt="image-20230609163751635"></p><h5 id="编写Dao层"><a href="#编写Dao层" class="headerlink" title="编写Dao层"></a>编写Dao层</h5><p><img src="../assets/image/Spring_Image/image-20230609163815759.png" alt="image-20230609163815759"></p><h5 id="编写Service层"><a href="#编写Service层" class="headerlink" title="编写Service层"></a>编写Service层</h5><p><img src="../assets/image/Spring_Image/image-20230609163832462.png" alt="image-20230609163832462"></p><h5 id="编写Controller层"><a href="#编写Controller层" class="headerlink" title="编写Controller层"></a>编写Controller层</h5><p><img src="../assets/image/Spring_Image/image-20230609163905690.png" alt="image-20230609163905690"></p><h5 id="修改超链接"><a href="#修改超链接" class="headerlink" title="修改超链接"></a>修改超链接</h5><p>在jsp中将对应的超链接改为Controller层中的对应方法</p><p><img src="../assets/image/Spring_Image/image-20230609164144033.png" alt="image-20230609164144033"></p><h3 id="角色添加"><a href="#角色添加" class="headerlink" title="角色添加"></a>角色添加</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><img src="../assets/image/Spring_Image/image-20230609183629603.png" alt="image-20230609183629603"></p><h5 id="编写Controller层-1"><a href="#编写Controller层-1" class="headerlink" title="编写Controller层"></a>编写Controller层</h5><p>提交完后重定向到/role/list下</p><p><img src="../assets/image/Spring_Image/image-20230609185958417.png" alt="image-20230609185958417"></p><h5 id="编写Service层-1"><a href="#编写Service层-1" class="headerlink" title="编写Service层"></a>编写Service层</h5><p><img src="../assets/image/Spring_Image/image-20230609190025182.png" alt="image-20230609190025182"></p><h5 id="编写Dao层-1"><a href="#编写Dao层-1" class="headerlink" title="编写Dao层"></a>编写Dao层</h5><p><img src="../assets/image/Spring_Image/image-20230609190049284.png" alt="image-20230609190049284"></p><h5 id="修改表单提交链接"><a href="#修改表单提交链接" class="headerlink" title="修改表单提交链接"></a>修改表单提交链接</h5><p><img src="../assets/image/Spring_Image/image-20230609190143789.png" alt="image-20230609190143789"></p><p>因为是用post方式提交，可能有乱码问题</p><h5 id="配置编码过滤器"><a href="#配置编码过滤器" class="headerlink" title="配置编码过滤器"></a>配置编码过滤器</h5><p>web.xml中</p><p><img src="../assets/image/Spring_Image/image-20230609190308082.png" alt="image-20230609190308082"></p><h3 id="用户列表展示"><a href="#用户列表展示" class="headerlink" title="用户列表展示"></a>用户列表展示</h3><h4 id="展示效果-1"><a href="#展示效果-1" class="headerlink" title="展示效果"></a>展示效果</h4><p><img src="../assets/image/Spring_Image/image-20230609191548547.png" alt="image-20230609191548547"></p><h4 id="给User类添加属性"><a href="#给User类添加属性" class="headerlink" title="给User类添加属性"></a>给User类添加属性</h4><p><img src="../assets/image/Spring_Image/image-20230609191711651.png" alt="image-20230609191711651"></p><h4 id="改页面中的超链接"><a href="#改页面中的超链接" class="headerlink" title="改页面中的超链接"></a>改页面中的超链接</h4><p><img src="../assets/image/Spring_Image/image-20230609191917227.png" alt="image-20230609191917227"></p><h4 id="编写Controller层-2"><a href="#编写Controller层-2" class="headerlink" title="编写Controller层"></a>编写Controller层</h4><p><img src="../assets/image/Spring_Image/image-20230609193514470.png" alt="image-20230609193514470"></p><h4 id="编写Service层-2"><a href="#编写Service层-2" class="headerlink" title="编写Service层"></a>编写Service层</h4><p><img src="../assets/image/Spring_Image/image-20230609193545907.png" alt="image-20230609193545907"></p><h4 id="编写Dao层-2"><a href="#编写Dao层-2" class="headerlink" title="编写Dao层"></a>编写Dao层</h4><p><img src="../assets/image/Spring_Image/image-20230609193603053.png" alt="image-20230609193603053"></p><h4 id="配置Service层、Dao层的bean"><a href="#配置Service层、Dao层的bean" class="headerlink" title="配置Service层、Dao层的bean"></a>配置Service层、Dao层的bean</h4><p><img src="../assets/image/Spring_Image/image-20230609193648087.png" alt="image-20230609193648087"></p><h4 id="jsp中引入核心标签库"><a href="#jsp中引入核心标签库" class="headerlink" title="jsp中引入核心标签库"></a>jsp中引入核心标签库</h4><p><img src="../assets/image/Spring_Image/image-20230609194314134.png" alt="image-20230609194314134"></p><p><img src="../assets/image/Spring_Image/image-20230609194325662.png" alt="image-20230609194325662"></p><h4 id="展示角色名称"><a href="#展示角色名称" class="headerlink" title="展示角色名称"></a>展示角色名称</h4><p>因为User表和Role表的关系存在外表中，想查到User对应的Role就要把Class User中的private List<Role> roles;  中的属性封装好</p><h5 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h5><p>不变，他只调用了Service层中的list()</p><p><img src="../assets/image/Spring_Image/image-20230610093414020.png" alt="image-20230610093414020"></p><h5 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h5><p>应为UserServiceImpl要调用RoleDao的方法，所以在xml中注入</p><p><img src="../assets/image/Spring_Image/image-20230610094728489.png" alt="image-20230610094728489"></p><p>遍历userList，主要使用每一个其中每一个User 的Id，利用Id调用Dao层的方法查询Role</p><p>一些经常用的操作，像findRoleByUserId就交给Dao层实现</p><p><img src="../assets/image/Spring_Image/image-20230610093442919.png" alt="image-20230610093442919"></p><h5 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h5><p>因为主要目的是findRole，所以这个方法放在RoleDaoImpl中</p><p><img src="../assets/image/Spring_Image/image-20230610094003364.png" alt="image-20230610094003364"></p><h4 id="user-list-jsp"><a href="#user-list-jsp" class="headerlink" title="user-list.jsp"></a>user-list.jsp</h4><p>前面将User中的private List<Role> roles;属性完成了封装</p><p>在jsp文件中就可以使用了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c<span class="keyword">:forEach</span> <span class="attribute">items</span>=<span class="string">&quot;<span class="variable">$&#123;userList&#125;</span>&quot;</span> <span class="attribute">var</span>=<span class="string">&quot;user&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>意思是遍历userList中的属性，每次取出的值名为user，即user是userList中的每一个元素，然后就可以通过user.来访问这个元素的对象</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c<span class="keyword">:forEach</span> <span class="attribute">items</span>=<span class="string">&quot;<span class="variable">$&#123;user.roles&#125;</span>&quot;</span> <span class="attribute">var</span>=<span class="string">&quot;role&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>遍历user中的roles属性，就是List<Role> roles，使用其中元素（Role实例）的roleName属性</p><p><img src="../assets/image/Spring_Image/image-20230610094123889.png" alt="image-20230610094123889"></p><h3 id="用户添加"><a href="#用户添加" class="headerlink" title="用户添加"></a>用户添加</h3><h4 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h4><p>因为在新建页面中，用户角色是要选择的，所以在从user-list.jsp跳到user-add.jsp的新建按钮上要将链接连接到方法上</p><p><img src="../assets/image/Spring_Image/image-20230610113940607.png" alt="image-20230610113940607"></p><p>在web层尽量使用service层的方法，而不是直接使用dao层的，所以这里注入新的属性，private RoleService roleService;使用其中的方法，查询数据库中存在的所有role的rolename,添加到ModelAndView的Model中</p><p><img src="../assets/image/Spring_Image/image-20230610113951453.png" alt="image-20230610113951453"></p><h4 id="user-add-jsp"><a href="#user-add-jsp" class="headerlink" title="user-add.jsp"></a>user-add.jsp</h4><p>中就可以使用放在ModelAndView中查询出来的roleList了</p><p><img src="../assets/image/Spring_Image/image-20230610114301033.png" alt="image-20230610114301033"></p><p>这样在每次打开新建用户界面时，用户角色的选项条就是从数据库中查出的最新的</p><h4 id="Service层-1"><a href="#Service层-1" class="headerlink" title="Service层"></a>Service层</h4><p><img src="../assets/image/Spring_Image/image-20230610135331934.png" alt="image-20230610135331934"></p><h4 id="Dao层-1"><a href="#Dao层-1" class="headerlink" title="Dao层"></a>Dao层</h4><p>使用save(User user)保存User实例，并将保存在数据库后生成的ID返回</p><p><img src="../assets/image/Spring_Image/image-20230610135353401.png" alt="image-20230610135353401"></p><p>jdbcTemplate.update()的不同使用方法</p><p>常见的使用方式：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(&quot;<span class="keyword">insert</span> <span class="keyword">into</span> sys_user_role <span class="keyword">values</span>(?,?)<span class="string">&quot;,userId,roleId);</span></span><br></pre></td></tr></table></figure><p>但是这里要求嗲用方法后还要返回ID，所以这么写</p><p>创建PreparedStatementCreator对象，将要执行的语句的格式和数据都封装在对象里。</p><p>创建GeneratedKeyHolder对象，在执行jdbcTemplate.update()时，会保存PreparedStatementCreator实例生成的ID</p><p>GeneratedKeyHolder的作用就是将还没传过去的主键保存下来</p><p><img src="../assets/image/Spring_Image/image-20230610135648256.png" alt="image-20230610135648256"></p><h3 id="用户删除"><a href="#用户删除" class="headerlink" title="用户删除"></a>用户删除</h3><p>删除和之前的不一样，需要从网页获取ID后返回后台</p><p>点击删除后调用delUser()</p><p>使用confirm()函数来在网页中跳出弹窗询问用户是否确认删除</p><p><img src="../assets/image/Spring_Image/image-20230610141223329.png" alt="image-20230610141223329"></p><p>delUser()负责提醒用户是否继续，如果是，就将userId返给后台</p><p><img src="../assets/image/Spring_Image/image-20230610141249752.png" alt="image-20230610141249752"></p><h4 id="Web层中"><a href="#Web层中" class="headerlink" title="Web层中"></a>Web层中</h4><p>使用网址来接受userId，使用注解@PathVariable(“userId”)将网址中的userId装递给参数</p><p><img src="../assets/image/Spring_Image/image-20230610142229279.png" alt="image-20230610142229279"></p><h4 id="Service层-2"><a href="#Service层-2" class="headerlink" title="Service层"></a>Service层</h4><p>这里没有级联删除，所以要先删除关系表中的数据</p><p><img src="../assets/image/Spring_Image/image-20230610142316603.png" alt="image-20230610142316603"></p><h4 id="Dao层-2"><a href="#Dao层-2" class="headerlink" title="Dao层"></a>Dao层</h4><p><img src="../assets/image/Spring_Image/image-20230610142352244.png" alt="image-20230610142352244"></p><h2 id="Ai总结"><a href="#Ai总结" class="headerlink" title="Ai总结"></a>Ai总结</h2><h3 id="spring中切面有几种类型的通知"><a href="#spring中切面有几种类型的通知" class="headerlink" title="spring中切面有几种类型的通知"></a>spring中切面有几种类型的通知</h3><p>在Spring框架中，切面（Aspect）是一种模块化的方式来实现横切关注点（cross-cutting concerns），通知（Advice）是切面中的具体行为。通知可以分为以下几种类型：</p><ol><li><p><strong>前置通知（Before Advice）：</strong> 在目标方法执行之前执行通知逻辑。前置通知可以用于验证输入参数或执行一些前期准备工作。</p></li><li><p><strong>后置通知（After Advice）：</strong> 在目标方法执行之后执行通知逻辑，无论目标方法是否抛出异常。后置通知通常用于执行清理工作或记录日志等。</p></li><li><p><strong>返回通知（After Returning Advice）：</strong> 仅在目标方法正常返回时执行通知逻辑。可以用于在方法成功执行后执行一些操作，如日志记录或数据处理。</p></li><li><p><strong>异常通知（After Throwing Advice）：</strong> 在目标方法抛出异常时执行通知逻辑。异常通知通常用于处理异常、日志记录或发送通知。</p></li><li><p><strong>环绕通知（Around Advice）：</strong> 环绕通知是最强大的通知类型，它包围目标方法的执行，在目标方法执行前后都可以定义通知逻辑。开发者可以完全控制目标方法的执行，包括是否执行目标方法以及如何处理其返回值。</p></li></ol><p>这些通知类型允许你将横切关注点的逻辑与应用程序的核心业务逻辑分离开来，从而提高了代码的模块化和可维护性。通常，切面会组合多种通知类型来实现所需的行为。</p>]]></content>
    
    
    <summary type="html">🍔本文汇总Spring和SpringMVC的开发步骤</summary>
    
    
    
    <category term="框架" scheme="https://momoao.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://momoao.github.io/tags/Spring/"/>
    
    <category term="SpringMVC" scheme="https://momoao.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://momoao.github.io/posts/202308281527.html"/>
    <id>https://momoao.github.io/posts/202308281527.html</id>
    <published>2023-08-28T07:27:00.000Z</published>
    <updated>2023-08-28T07:29:07.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="回顾原始jdbc操作"><a href="#回顾原始jdbc操作" class="headerlink" title="回顾原始jdbc操作"></a>回顾原始jdbc操作</h2><p>查询</p><p><img src="../assets/image/Mybatis_Image/image-20230610142612838.png" alt="image-20230610142612838"></p><p>插入</p><p><img src="../assets/image/Mybatis_Image/image-20230610142816805.png" alt="image-20230610142816805"></p><p>原始jdbc存在的问题和解决方案</p><p><img src="../assets/image/Mybatis_Image/image-20230610143103345.png" alt="image-20230610143103345"></p><h2 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis"></a>什么是Mybatis</h2><p><img src="../assets/image/Mybatis_Image/image-20230610143700208.png" alt="image-20230610143700208"></p><h1 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h1><p><img src="../assets/image/Mybatis_Image/image-20230611081715389.png" alt="image-20230611081715389"></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p><img src="../assets/image/Mybatis_Image/image-20230611085537432.png" alt="image-20230611085537432"></p><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><p>sqlMapConfig.xml</p><p><img src="../assets/image/Mybatis_Image/image-20230611085605028.png" alt="image-20230611085605028"></p><h3 id="sql语句文件"><a href="#sql语句文件" class="headerlink" title="sql语句文件"></a>sql语句文件</h3><p>UserMapper.xml</p><p><img src="../assets/image/Mybatis_Image/image-20230611085613972.png" alt="image-20230611085613972"></p><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><p><img src="../assets/image/Mybatis_Image/image-20230611085648930.png" alt="image-20230611085648930"></p><h3 id="必须要添加的坐标"><a href="#必须要添加的坐标" class="headerlink" title="必须要添加的坐标"></a>必须要添加的坐标</h3><p><img src="../assets/image/Mybatis_Image/image-20230611085757976.png" alt="image-20230611085757976"></p><h2 id="映射文件概述"><a href="#映射文件概述" class="headerlink" title="映射文件概述"></a>映射文件概述</h2><p><img src="../assets/image/Mybatis_Image/image-20230611090222574.png" alt="image-20230611090222574"></p><h1 id="增删改查操作"><a href="#增删改查操作" class="headerlink" title="增删改查操作"></a>增删改查操作</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>UserMapper.xml</p><p><img src="../assets/image/Mybatis_Image/image-20230611093202381.png" alt="image-20230611093202381"></p><p>测试代码</p><p>执行结果返回还是1，但是数据库并没有收影响</p><p><img src="../assets/image/Mybatis_Image/image-20230611093244040.png" alt="image-20230611093244040"></p><p>mybatis的事务默认是不提交的，原始的jdbc默认是提交的，所以要提交后数据才会进到数据库</p><p><img src="../assets/image/Mybatis_Image/image-20230611095203056.png" alt="image-20230611095203056"></p><p>提交后发现id是3而不是1，因为sql已经到了数据库，但是业务没提交，只有id自增了，但是表内的数据没变</p><p><img src="../assets/image/Mybatis_Image/image-20230611095217220.png" alt="image-20230611095217220"></p><p>注意事项</p><p><img src="../assets/image/Mybatis_Image/image-20230611101214983.png" alt="image-20230611101214983"></p><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p><img src="../assets/image/Mybatis_Image/image-20230611102918409.png" alt="image-20230611102918409"></p><p><img src="../assets/image/Mybatis_Image/image-20230611102928968.png" alt="image-20230611102928968"></p><p>注意事项</p><p><img src="../assets/image/Mybatis_Image/image-20230611103409878.png" alt="image-20230611103409878"></p><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>因为这里只有一个参数java.lang.Integer，所以#{}中写什么名字都行，写id是为了提高可读性</p><p><img src="../assets/image/Mybatis_Image/image-20230611103216866.png" alt="image-20230611103216866"></p><p><img src="../assets/image/Mybatis_Image/image-20230611103321664.png" alt="image-20230611103321664"></p><p>注意事项</p><p><img src="../assets/image/Mybatis_Image/image-20230611103421397.png" alt="image-20230611103421397"></p><h2 id="知识小结"><a href="#知识小结" class="headerlink" title="知识小结"></a>知识小结</h2><p><img src="../assets/image/Mybatis_Image/image-20230611105031427.png" alt="image-20230611105031427"></p><h1 id="核心配置文件概述"><a href="#核心配置文件概述" class="headerlink" title="核心配置文件概述"></a>核心配置文件概述</h1><h2 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h2><p><img src="../assets/image/Mybatis_Image/image-20230611154600251.png" alt="image-20230611154600251"></p><h2 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h2><p><img src="../assets/image/Mybatis_Image/image-20230611155133546.png" alt="image-20230611155133546"></p><p><img src="../assets/image/Mybatis_Image/image-20230611155345158.png" alt="image-20230611155345158"></p><h2 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h2><p><img src="../assets/image/Mybatis_Image/image-20230611160012398.png" alt="image-20230611160012398"></p><p><img src="../assets/image/Mybatis_Image/image-20230611160046561.png" alt="image-20230611160046561"></p><h2 id="Properties标签"><a href="#Properties标签" class="headerlink" title="Properties标签"></a>Properties标签</h2><p>在文件中引入配置文件</p><p><img src="../assets/image/Mybatis_Image/image-20230611160827286.png" alt="image-20230611160827286"></p><p><img src="../assets/image/Mybatis_Image/image-20230611160835561.png" alt="image-20230611160835561"></p><h2 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h2><p>作用是声明全局别名，例如将com.itheima.domain.User声明为user</p><p>在以后使用的时候就可以直接使用user了</p><p><img src="../assets/image/Mybatis_Image/image-20230611161044825.png" alt="image-20230611161044825"></p><p><img src="../assets/image/Mybatis_Image/image-20230611161202020.png" alt="image-20230611161202020"></p>]]></content>
    
    
    <summary type="html">🍔本文汇总使用Mybatis开发的基本步骤，简易提交看Spring的相关笔记</summary>
    
    
    
    <category term="框架" scheme="https://momoao.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="Mybatis" scheme="https://momoao.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>VSCode中C++环境配置</title>
    <link href="https://momoao.github.io/posts/202308241554.html"/>
    <id>https://momoao.github.io/posts/202308241554.html</id>
    <published>2023-08-09T10:19:03.000Z</published>
    <updated>2023-08-25T12:44:14.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h1><h1 id="c-环境配置"><a href="#c-环境配置" class="headerlink" title="c++环境配置"></a>c++环境配置</h1><ul><li><p>下载这个拓展，1.8.4版本<img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714165903555.png" alt="image-20230714165903555"></p></li><li><p>选择编译器第一个</p><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714170141470.png" alt="image-20230714170141470"></p></li><li><p>还是第一个</p><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714170213229.png" alt="image-20230714170213229"></p></li><li><p>运行后自动生成配置文件配置文件</p><ul><li><p>launch.json</p><ul><li>设置program指定exe文件生成路径</li><li>设置externalConsole指定是否在控制台中输出<ul><li>一般使用true（默认false），不然会有乱码问题</li></ul></li><li><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714170851815.png" alt="image-20230714170851815"></li></ul></li><li><p>task.json</p><ul><li>这里也指定exe文件的路径，需要与上面的一样</li><li><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714171026376.png" alt="image-20230714171026376"></li></ul></li></ul></li></ul><h1 id="自定义代码段配置"><a href="#自定义代码段配置" class="headerlink" title="自定义代码段配置"></a>自定义代码段配置</h1><ul><li></li><li><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714171247386.png" alt="image-20230714171247386"></li></ul><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjI2NTE2Mi0yNzRiZTI5ZWQxNGY3NWU4LnBuZw.png" alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjI2NTE2Mi0yNzRiZTI5ZWQxNGY3NWU4LnBuZw"></p><ul><li>文件中的配置</li><li><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714172404490.png" alt="image-20230714172404490"></li><li><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714172345791.png" alt="image-20230714172345791"></p></li><li><p>配置书写规范</p></li><li><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714172431725.png" alt="image-20230714172431725"></li></ul>]]></content>
    
    
    <summary type="html">🥧本文汇总VSCode中C++环境的配置和使用</summary>
    
    
    
    <category term="工具" scheme="https://momoao.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="VSCode" scheme="https://momoao.github.io/tags/VSCode/"/>
    
    <category term="软件配置" scheme="https://momoao.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式</title>
    <link href="https://momoao.github.io/posts/202310071038.html"/>
    <id>https://momoao.github.io/posts/202310071038.html</id>
    <published>2023-08-07T00:19:03.000Z</published>
    <updated>2023-10-22T06:14:11.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java设计模式"><a href="#Java设计模式" class="headerlink" title="Java设计模式"></a>Java设计模式</h1><ul><li>基本要素<ul><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果</li></ul></li><li>GoF 23<ul><li>一种思维、态度、进步</li></ul></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一共23种设计模式</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007110611172.png" alt="image-20231007110611172"></p><h2 id="OOP七大原则"><a href="#OOP七大原则" class="headerlink" title="OOP七大原则"></a>OOP七大原则</h2><ul><li>开闭原则<ul><li>如果需求发生改变，不允许修改，但是可以扩展功能</li></ul></li><li>里氏替换原则<ul><li>子类重写父类方法时，要保留父类方法中的功能</li></ul></li><li>依赖倒置原则<ul><li>降低程序耦合性，实现要建立在基础之上</li></ul></li><li>单一职责原则<ul><li>一个方法尽可能只实现一个功能</li></ul></li><li>接口隔离原则<ul><li>接口之间不能过于相似和相同</li></ul></li><li>迪米特原则<ul><li>例如：朋友关系A&lt;=&gt;B&lt;=&gt;C</li><li>当A想和C沟通时，一定要通过B</li></ul></li><li>合成复用原则<ul><li>它强调在创建新类时应优先使用组合而不是继承</li></ul></li></ul><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007111031937.png" alt="image-20231007111031937"></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>重点：</p><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><ul><li>构造方法私有化</li><li>在static代码块里创建一个对象，让内存中有且仅有这一个对象</li></ul><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007112654414.png" alt="image-20231007112654414"></p><h3 id="懒汉式单列"><a href="#懒汉式单列" class="headerlink" title="懒汉式单列"></a>懒汉式单列</h3><ul><li><p>私有构造器</p></li><li><p>在静态代码块中创建对象</p></li><li>使用双重检测锁模式</li><li>使用volatile防止指令重排，但不保证原子性</li></ul><p>第一个if的作用：如果没有第一个if，线程进入方法时，就需要先加锁在判断对象是否创建，锁的创建和释放很耗费资源，所以当线程进入方法时，直接判断对象是否存在而不进行和锁相关的操作</p><p>不加volatile可能出现的问题：线程A进入方法，执行到了创建对象那步，因为new不是原子操作，分为3个操作，可能发生指令重排，如果先执行1和3，那么对象不为null，因为有了内存空间（虽然还没初始化，但是也不为null了）；这时候线程B进入方法，发现第一个if进不去，之间执行return，会造成返回对象虽然不是null，但是内存空间中并没有数据</p><p>​    </p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007113609919.png" alt="image-20231007113609919"></p><h4 id="懒汉式另一种实现（静态内部类）"><a href="#懒汉式另一种实现（静态内部类）" class="headerlink" title="懒汉式另一种实现（静态内部类）"></a>懒汉式另一种实现（静态内部类）</h4><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007114836968.png" alt="image-20231007114836968"></p><h3 id="饿汉式和懒汉式区别"><a href="#饿汉式和懒汉式区别" class="headerlink" title="饿汉式和懒汉式区别"></a>饿汉式和懒汉式区别</h3><p>饿汉式直接创建了对象，方法是用于返回这个对象的</p><p>懒汉式一开始并没有创建对象，等调用方法的时候才创建对象并返回</p><h3 id="通过反射破坏单例"><a href="#通过反射破坏单例" class="headerlink" title="通过反射破坏单例"></a>通过反射破坏单例</h3><p>通过反射获得构造器，开启权限，使用构造器在创建一个对象</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007115053108.png" alt="image-20231007115053108"></p><p>防止反射破坏</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007115252302.png" alt="image-20231007115252302"></p><p>但是会有新问题</p><p>同时拿到</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007115713742.png" alt="image-20231007115713742"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007134938431.png" alt="image-20231007134938431"></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007135234179.png" alt="image-20231007135234179"></p><h3 id="简单工厂模式（静态工厂模式）"><a href="#简单工厂模式（静态工厂模式）" class="headerlink" title="简单工厂模式（静态工厂模式）"></a>简单工厂模式（静态工厂模式）</h3><p>不满足开闭原则</p><p><strong>在一个工厂类里实现所有车需要的操作</strong></p><p>工厂类</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007135713053.png" alt="image-20231007135713053"></p><p>消费者不关心车的细节，而是直接找工厂</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007140057080.png" alt="image-20231007140057080"></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>给工厂也创建接口</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007140356430.png" alt="image-20231007140356430"></p><p><strong>每个车型都有自己的工厂类，实现了工厂接口</strong>，<strong>并继承车类</strong></p><p><strong>要制作新车，就需要创建一个新的工厂类，实现工厂接口并继承车类</strong></p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007140519172.png" alt="image-20231007140519172"></p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007140851510.png" alt="image-20231007140851510"></p><p>结构复杂度：simple低</p><p>代码复杂度：simple低</p><p>根据设计原则：使用工厂方法模式</p><p>根据实际业务：使用简单工厂模式</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007141203815.png" alt="image-20231007141203815"></p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007135008003.png" alt="image-20231007135008003"></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>举例：工厂接口由小米和华为实现，他们都能生成手机，但是因为不是同一工厂，所以手机类型不一样</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007141417785.png" alt="image-20231007141417785"></p><p>概述</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007141504189.png" alt="image-20231007141504189"></p><p>产品族和产品等级</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007141709630.png" alt="image-20231007141709630"></p><p>创建接口：手机接口、路由器接口</p><ul><li>创建类：<ul><li>小米手机，实现手机接口</li><li>华为手机，实现手机接口</li><li>小米路由器，实现路由器接口</li><li>华为路由器，实现路由器接口</li></ul></li></ul><p>小米手机和华为手机属于同一产品等级</p><p>小米手机和小米路由器属于同一产品族</p><ul><li>创建抽象工厂接口<ul><li>内有手机生产接口和路由器生产接口</li></ul></li></ul><p>用小米工厂继承接口</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007143311460.png" alt="image-20231007143311460"></p><h3 id="想使用小米手机时"><a href="#想使用小米手机时" class="headerlink" title="想使用小米手机时"></a>想使用小米手机时</h3><ul><li>创建小米工厂</li><li>使用小米工厂创建手机工厂</li><li>使用手机工厂创建手机并使用</li></ul><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007144034863.png" alt="image-20231007144034863"></p><h3 id="如果想添加一个新产品电脑"><a href="#如果想添加一个新产品电脑" class="headerlink" title="如果想添加一个新产品电脑"></a>如果想添加一个新产品电脑</h3><ul><li>创建电脑接口</li><li>创建小米电脑类和华为电脑类，实现电脑接口</li><li>在抽象工厂接口中添加电脑方法</li><li>在小米工厂类和华为工厂类中实现抽象工厂接口中新添加的电脑方法</li></ul><p>违反开闭原则</p><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p><strong>这里的小米工厂就是工厂的工厂，是抽象工厂</strong></p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007144200356.png" alt="image-20231007144200356"></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007145026041.png" alt="image-20231007145026041"></p><p>分析</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007145056504.png" alt="image-20231007145056504"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>创建抽象建造者</p><p>不负责建房子，定义一些接口</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007163453973.png" alt="image-20231007163453973"></p><p>创建产品类</p><p>是具体的房子（平房或别墅）</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007163419211.png" alt="image-20231007163419211"></p><p>创建工人</p><p>具体的建造者，负责建造房子</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007163614894.png" alt="image-20231007163614894"></p><p>创建指挥者</p><p>调用抽象工人来盖房子</p><p>建造流程顺序需要指挥者来指定</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007163754871.png" alt="image-20231007163754871"></p><p>测试</p><p>这里指挥需要指定具体的工人</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007163855812.png" alt="image-20231007163855812"></p><h3 id="过程2"><a href="#过程2" class="headerlink" title="过程2"></a>过程2</h3><p>抽象建造者（各种食物）</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007164600278.png" alt="image-20231007164600278"></p><p>产品（具体的套餐）    </p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007164631127.png" alt="image-20231007164631127"></p><p>具体的建造者</p><ul><li>服务员（默认套餐）</li><li>顾客（自定义套餐）</li></ul><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007164736184.png" alt="image-20231007164736184"></p><p> 默认套餐</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007164922356.png" alt="image-20231007164922356"></p><p>使用链式编程模拟顾客</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007165025920.png" alt="image-20231007165025920"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>符合开闭原则</strong></p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007165206435.png" alt="image-20231007165206435"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007164110809.png" alt="image-20231007164110809"></p><h3 id="应用场景和比较"><a href="#应用场景和比较" class="headerlink" title="应用场景和比较"></a>应用场景和比较</h3><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007165312853.png" alt="image-20231007165312853"></p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>创建类，实现接口<code>Cloneable</code>，重写其中的<code>clone()</code></p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007174741698.png" alt="image-20231007174741698"></p><p>之后就可以在其他地方克隆这个类的对象了</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007175402855.png" alt="image-20231007175402855"></p><p>这里的clone()默认实现的是浅克隆，如果想实现深克隆需要自己重写clone()，在方法中复制所有成员，引用类型的成员也调用clone()方法</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>创建一个要被适配的类（网线）</p><p>创建一个适配器接口</p><p>创建一个适配器继承要被适配的类，实现适配器接口</p><p>创建电脑类</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007180600482.png" alt="image-20231007180600482"></p><p>方法二</p><p> 之前的方法一使用的继承方式（类适配器，单继承）</p><p>这里使用组合的方式（对象适配器：常用）</p><p>创建适配器</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007180816490.png" alt="image-20231007180816490"></p><p>创建测试</p><p>构造方法中参数是网线，之后调用电脑的上网方法，参数是适配器对象</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007180902318.png" alt="image-20231007180902318"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007180940906.png" alt="image-20231007180940906"></p><p>结构图</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007181207286.png" alt="image-20231007181207286"></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>对象适配器更好用</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007181220367.png" alt="image-20231007181220367"></p><h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2><p>结构</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007182633020.png" alt="image-20231007182633020"></p><p>创建代理</p><p>继承租房子接口，实现接口中的方法：调用房东的出租方法</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007183142188.png" alt="image-20231007183142188"></p><p>测试</p><p>创建代理，告诉代理房东是谁，然后调用代理的租房方法</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007183249929.png" alt="image-20231007183249929"></p><p>中介相对房东的增强功能</p><p>不仅调用房东的租房方法，还可以在方法里增加一些附属操作</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007183446462.png" alt="image-20231007183446462"></p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007183641917.png" alt="image-20231007183641917"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>一个真实角色就会产生一个代理角色，代码量翻倍</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007184116026.png" alt="image-20231007184116026"></p><p>了解两个类：Proxy  代理、 InvocationHandler 调用处理</p><p>之前的代理类是写死的，这里通过继承InvocationHandler接口来自动生成代理类</p><p>Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类</p><p>创建动态代理类</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007185744865.png" alt="image-20231007185744865"></p><p>创建测试</p><p><img src="../assets/image/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_Image/image-20231007190204644.png" alt="image-20231007190204644"></p><h2 id="Ai总结"><a href="#Ai总结" class="headerlink" title="Ai总结"></a>Ai总结</h2><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p>抽象类（Abstract Class）和接口（Interface）是面向对象编程中两种不同的概念，它们在某些方面有相似之处，但也有一些重要的区别。以下是抽象类和接口的主要区别：</p><ol><li><p><strong>方法实现：</strong></p><ul><li>抽象类可以包含抽象方法（没有方法体），也可以包含具体方法（有方法体）。子类继承抽象类时可以选择性地覆盖抽象方法，也可以使用已经实现的具体方法。</li><li>接口只能包含抽象方法，没有方法体。类实现接口时必须实现接口中定义的所有方法。</li></ul></li><li><p><strong>多继承：</strong></p><ul><li>在Java中，一个类只能继承一个父类（单继承），但可以实现多个接口（多实现）。这意味着如果一个类已经继承了一个抽象类，它不能再继承其他类，但可以实现多个接口。</li></ul></li><li><p><strong>构造函数：</strong></p><ul><li>抽象类可以有构造函数，而接口不能有构造函数。抽象类的构造函数用于初始化对象状态，而接口仅定义了方法签名，不包含实际的实现。</li></ul></li><li><p><strong>成员变量：</strong></p><ul><li>抽象类可以包含成员变量，这些变量可以是抽象的、具体的，或者静态的。接口只能包含常量（<code>public static final</code>）。</li></ul></li><li><p><strong>用途：</strong></p><ul><li>抽象类通常用于表示一种基本类或者某种具体类型，它可以包含一些通用的方法和属性，并且可以提供一些默认的实现。子类通过继承抽象类来扩展其功能。</li><li>接口用于定义一种契约，它规定了实现类必须提供的方法，以确保一致性。类可以实现多个接口，从而具备多个不同的行为。接口通常用于实现多态和解耦。</li></ul></li><li><p><strong>版本演化：</strong></p><ul><li>如果要在现有的抽象类中添加新方法，可能会破坏已有的子类，因为它们必须覆盖新方法。这可能会导致向后不兼容的变化。</li><li>接口的修改更加灵活，因为实现类只需实现接口中的必要方法，不会受到新方法的影响。</li></ul></li></ol><p>总之，抽象类和接口都是在面向对象编程中用于实现多态和封装的工具，但它们在设计和使用上有不同的约束和用途。选择使用哪种方式取决于您的需求和设计目标。通常，如果您希望为多个不相关的类提供一致的契约，使用接口更合适。如果您需要提供一些通用的方法和属性，并希望子类扩展这些方法，使用抽象类更合适。在实际应用中，通常会结合使用抽象类和接口，以达到更灵活的设计。</p><h3 id="创建、结构、行为这些设计模式的区别和特点"><a href="#创建、结构、行为这些设计模式的区别和特点" class="headerlink" title="创建、结构、行为这些设计模式的区别和特点"></a>创建、结构、行为这些设计模式的区别和特点</h3><p>设计模式是一种解决特定问题的通用方法，它们提供了在软件设计中常见问题的解决方案。设计模式通常分为三个主要类型：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns）。下面我将为您解释这三种类型的设计模式的区别和特点：</p><ol><li><p><strong>创建型模式（Creational Patterns）：</strong></p><ul><li><strong>目的：</strong> 创建型模式关注对象的创建过程，隐藏了创建对象的复杂性，提供了一种方便的方式来创建对象的实例。</li><li><strong>特点：</strong> 创建型模式有多种，包括单例模式、工厂模式、抽象工厂模式、建造者模式和原型模式等。它们的共同目标是封装对象的创建和实例化，使代码更加灵活和可维护。</li></ul></li><li><p><strong>结构型模式（Structural Patterns）：</strong></p><ul><li><strong>目的：</strong> 结构型模式关注对象如何组合成更大的结构，以满足系统的需求。它们通常涉及到类和对象的组合，以形成更复杂的结构。</li><li><strong>特点：</strong> 结构型模式有多种，包括适配器模式、桥接模式、组合模式、装饰者模式、外观模式、享元模式和代理模式等。它们的共同目标是改善系统的结构，使其更加灵活、可扩展和可维护。</li></ul></li><li><p><strong>行为型模式（Behavioral Patterns）：</strong></p><ul><li><strong>目的：</strong> 行为型模式关注对象之间的通信和职责分配。它们描述了对象之间的交互方式，以支持更松散耦合的系统。</li><li><strong>特点：</strong> 行为型模式有多种，包括观察者模式、策略模式、命令模式、状态模式、访问者模式、中介者模式、备忘录模式、解释器模式和职责链模式等。它们的共同目标是改善对象之间的通信和协作，使系统更加灵活和可维护。</li></ul></li></ol><p>总结一下，创建型模式关注对象的创建，结构型模式关注对象之间的组合，行为型模式关注对象之间的交互。选择适当的设计模式可以使代码更具可读性、可维护性和可扩展性，并有助于解决特定类型的问题。不同的设计模式适用于不同的情境，根据具体需求来选择和组合这些模式以满足项目的要求。</p><h3 id="Java中有哪些原子性操作"><a href="#Java中有哪些原子性操作" class="headerlink" title="Java中有哪些原子性操作"></a>Java中有哪些原子性操作</h3><p>在Java中，原子性操作是指一个操作在执行期间不会被其他线程干扰或中断，要么执行完全，要么不执行，不会出现部分执行的情况。Java提供了多种方式来实现原子性操作，其中包括以下几种：</p><ol><li><p><strong>synchronized关键字</strong>：使用synchronized关键字可以实现对临界区代码块的原子性操作。通过将关键代码块标记为synchronized，只有一个线程能够同时执行该代码块，从而保证原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>volatile关键字</strong>：volatile关键字可以用来声明一个变量，确保多个线程之间对该变量的操作是可见的，并且不会被重排序。虽然它不能解决所有原子性问题，但可以用来确保某些操作的原子性，例如在单次读取或写入操作中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure></li><li><p><strong>java.util.concurrent.atomic包</strong>：Java提供了java.util.concurrent.atomic包，其中包含了一系列原子类，用于执行原子性操作，如AtomicInteger、AtomicLong、AtomicBoolean等。这些类提供了一些方法，可以实现对变量的原子更新操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">// 原子性的自增操作</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Lock接口</strong>：Java提供了Lock接口的实现类，如ReentrantLock，用于支持更灵活的锁定机制。通过Lock接口，可以在代码中显式地锁定和解锁，以实现原子性操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这些方法提供了不同级别的原子性保证，开发者可以根据具体的需求选择适当的方式来实现原子性操作。需要注意的是，虽然这些方式可以确保某些操作的原子性，但仍然需要谨慎地设计多线程代码，以避免竞态条件和死锁等问题。</p>]]></content>
    
    
    <summary type="html">🍔本文汇总Java设计模式的基础知识点和基本使用</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="设计模式" scheme="https://momoao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://momoao.github.io/posts/202310030946.html"/>
    <id>https://momoao.github.io/posts/202310030946.html</id>
    <published>2023-08-03T10:19:03.000Z</published>
    <updated>2023-10-18T09:06:18.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h4><p><img src="../assets/image/JVM_Image/image-20231003094717616.png" alt="image-20231003094717616"></p><p>关系图</p><p><img src="../assets/image/JVM_Image/image-20231003094734373.png" alt="image-20231003094734373"></p><h4 id="多级缓存和一致性问题"><a href="#多级缓存和一致性问题" class="headerlink" title="多级缓存和一致性问题"></a>多级缓存和一致性问题</h4><p><img src="../assets/image/JVM_Image/image-20231003095905800.png" alt="image-20231003095905800"></p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p><img src="../assets/image/JVM_Image/image-20231003095930721.png" alt="image-20231003095930721"></p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><img src="../assets/image/JVM_Image/image-20231003100052920.png" alt="image-20231003100052920"></p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><img src="../assets/image/JVM_Image/image-20231003100437689.png" alt="image-20231003100437689"></p><h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>由于主内存和工作内存之间的具体交互协议，Java内存模型定义了以下八种操作来完成</p><p><img src="../assets/image/JVM_Image/image-20231003100853256.png" alt="image-20231003100853256"></p><p><img src="../assets/image/JVM_Image/image-20231003101710296.png" alt="image-20231003101710296"></p><h4 id="Java如何解决原子性、可见性、有序性问题"><a href="#Java如何解决原子性、可见性、有序性问题" class="headerlink" title="Java如何解决原子性、可见性、有序性问题"></a>Java如何解决原子性、可见性、有序性问题</h4><p><img src="../assets/image/JVM_Image/image-20231003100719947.png" alt="image-20231003100719947"></p><h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p><img src="../assets/image/JVM_Image/image-20231003102337524.png" alt="image-20231003102337524"></p><h4 id="先行发生原则（happens-before）"><a href="#先行发生原则（happens-before）" class="headerlink" title="先行发生原则（happens-before）"></a>先行发生原则（happens-before）</h4><p><img src="../assets/image/JVM_Image/image-20231003102356371.png" alt="image-20231003102356371"></p><p><img src="../assets/image/JVM_Image/image-20231003102531419.png" alt="image-20231003102531419"></p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><ul><li></li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="../assets/image/JVM_Image/image-20231008103808488.png" alt="image-20231008103808488"></p><ul><li>这种机制的好处<ul><li>安全性：因为加载类时都要先提交到启动类加载器，这保证了核心类的安全性不会被其他加载器破坏</li><li>因为有这种上下级结构，所以也可以避免重复加载导致程序混乱</li></ul></li></ul><p><img src="../assets/image/JVM_Image/image-20231008103825772.png" alt="image-20231008103825772"></p><p>父委托模型</p><p><img src="../assets/image/JVM_Image/image-20231008103920981.png" alt="image-20231008103920981"></p><h2 id="初识JVM"><a href="#初识JVM" class="headerlink" title="初识JVM"></a>初识JVM</h2><h3 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h3><p>JVM 全称是 Java Virtual Machine，中文译名 Java虚拟机。</p><p>JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。</p><p><img src="../assets/image/JVM_Image/image-20231012193457544.png" alt="image-20231012193457544"></p><p>JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。</p><p><img src="../assets/image/JVM_Image/image-20231012193717973.png" alt="image-20231012193717973"></p><h3 id="JVM的功能"><a href="#JVM的功能" class="headerlink" title="JVM的功能"></a>JVM的功能</h3><p><img src="../assets/image/JVM_Image/image-20231013101522763.png" alt="image-20231013101522763"></p><p>Java需要实时解释，主要是为了支持跨平台特性。</p><p><img src="../assets/image/JVM_Image/image-20231013101624030.png" alt="image-20231013101624030"></p><p>即时编译</p><p><img src="../assets/image/JVM_Image/image-20231013102403596.png" alt="image-20231013102403596"></p><h3 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h3><p><img src="../assets/image/JVM_Image/image-20231013102420137.png" alt="image-20231013102420137"></p><p>HotSpot发展历程</p><p><img src="../assets/image/JVM_Image/image-20231013102820437.png" alt="image-20231013102820437"></p><h2 id="详解字节码文件"><a href="#详解字节码文件" class="headerlink" title="详解字节码文件"></a>详解字节码文件</h2><h3 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h3><p><img src="../assets/image/JVM_Image/image-20231013103131068.png" alt="image-20231013103131068"></p><h3 id="字节码文件组成"><a href="#字节码文件组成" class="headerlink" title="字节码文件组成"></a>字节码文件组成</h3><p><img src="../assets/image/JVM_Image/image-20231013104953672.png" alt="image-20231013104953672"></p><ul><li><p>基本信息</p><ul><li><p>魔数：Java字节码文件中，将文件头称为magic魔数</p><ul><li>文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容</li><li>软件使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错</li></ul></li><li><p>主副版本号：版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容</p><ul><li><p>主副版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了</p><p>45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同</p><p>版本的标识，一般只需要关心主版本号。</p></li><li><p>出现问题时</p></li><li><img src="../assets/image/JVM_Image/image-20231013123504048.png" alt="image-20231013123504048"></li><li>两种方案<ul><li>升级JDK版本（容易引发其他的兼容性问题，并且需要大量的测试）</li><li>将第三方依赖的版本号降低或者更换依赖，以满足JDK版本的要求</li></ul></li></ul></li><li><p>总结</p><ul><li><img src="../assets/image/JVM_Image/image-20231013123550315.png" alt="image-20231013123550315"></li></ul></li></ul></li><li><p>常量池</p><ul><li>字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。</li><li>常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据</li><li>字节码指令中通过编号引用到常量池的过程称之为符号引用<ul><li><img src="../assets/image/JVM_Image/image-20231013123945822.png" alt="image-20231013123945822"></li></ul></li></ul></li><li><p>方法</p><ul><li>字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中。<ul><li><img src="../assets/image/JVM_Image/image-20231013124122149.png" alt="image-20231013124122149"></li></ul></li><li>操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置。<ul><li>从上往下，从(等号)右往左看，先有了数字0，所以iconst_0，在操作数栈中出现了0</li><li>istore_1：从栈中取出数字<code>移动</code>到局部变量表的1的位置</li><li>iload_1：将局部变量表中1中的数据<code>复制</code>到栈中</li><li>iconst_1：将常量1放入操作数栈</li><li>iadd：将操作数栈顶部的两个数相加并放回栈顶</li><li>istore_2：将栈顶的数移动到局部变量表2的位置</li><li><img src="../assets/image/JVM_Image/image-20231013124442717.png" alt="image-20231013124442717"></li></ul></li><li>讲解i++过程<ul><li><img src="../assets/image/JVM_Image/image-20231013132733102.png" alt="image-20231013132733102"></li></ul></li><li>讲解++i<ul><li>和上方不同的是：先iinc 1 by 1然后再iload_1</li><li><img src="../assets/image/JVM_Image/image-20231013133709235.png" alt="image-20231013133709235"></li></ul></li><li>案例<ul><li><img src="../assets/image/JVM_Image/image-20231013134014018.png" alt="image-20231013134014018"></li><li>分析i++<ul><li>int i = 5; i++;</li><li>0: iconst_5   ; 将整数常量5加载到操作数栈上<br>1: istore_1   ; 将5存储到局部变量1（i）<br>2: iload_1    ; 将局部变量1（i）加载到操作数栈上<br>3: iconst_1   ; 将整数常量1加载到操作数栈上<br>4: iadd       ; 执行加法操作<br>5: istore_1   ; 将结果存储回局部变量1（i）</li></ul></li><li>分析i += 1<ul><li>int x = 5; x += 3;</li><li>0: iconst_5   ; 将整数常量5加载到操作数栈上<br>1: istore_1   ; 将5存储到局部变量1（x）<br>2: iload_1    ; 将局部变量1（x）加载到操作数栈上<br>3: iconst_3   ; 将整数常量3加载到操作数栈上<br>4: iadd       ; 执行加法操作<br>5: istore_1   ; 将结果存储回局部变量1（x）</li></ul></li><li>分析i = i + 1<ul><li>int i = 5; i = i + 1;</li><li>0: iconst_5   ; 将整数常量5加载到操作数栈上<br>1: istore_1   ; 将5存储到局部变量1（i）<br>2: iload_1    ; 将局部变量1（i）加载到操作数栈上<br>3: iconst_1   ; 将整数常量1加载到操作数栈上<br>4: iadd       ; 执行加法操作<br>5: istore_1   ; 将结果存储回局部变量1（i）</li></ul></li></ul></li></ul></li></ul><h3 id="字节码常用工具"><a href="#字节码常用工具" class="headerlink" title="字节码常用工具"></a>字节码常用工具</h3><h4 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h4><p>javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内容。</p><p>直接输入javap查看所有参数。</p><p>输入javap -v 字节码文件名称 查看具体的字节码信息。（如果jar包需要先使用 jar –xvf 命令解压）</p><p><img src="../assets/image/JVM_Image/image-20231013135453011.png" alt="image-20231013135453011"></p><h4 id="jclasslib"><a href="#jclasslib" class="headerlink" title="jclasslib"></a>jclasslib</h4><p><img src="../assets/image/JVM_Image/image-20231013140303579.png" alt="image-20231013140303579"></p><h4 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h4><ul><li><p>Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修</p><p>改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。</p></li><li><p>官网：<a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></p></li><li><p><img src="../assets/image/JVM_Image/image-20231013140756295.png" alt="image-20231013140756295"></p></li><li><p>指令dashboard -i 2000 -n 1</p><ul><li><a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a> - 当前系统的实时数据面板</li><li>-i 表示每次显示的时间间隔（毫秒）</li><li>-n 表示显示几次</li></ul><p><img src="../assets/image/JVM_Image/image-20231013142600343.png" alt="image-20231013142600343"></p></li><li><p>dump 类的全限定名：dump已加载类的字节码文件到特定目录。</p><ul><li>dump -d D:/jvm/data/arthas.Demo</li></ul></li><li><p>jad 类的全限定名： 反编译已加载类的源码。</p><ul><li>jad arthas.Demo (某个包下的某个类)</li><li>输入后就显示类的源代码</li></ul></li><li></li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li><p>背景</p><ul><li><p>小李的团队昨天对系统进行了升级修复了某个bug，但是升级完之后发现bug还</p><p>是存在，小李怀疑是因为没有把最新的字节码文件部署到服务器上，请使用阿</p><p>里的arthas去确认升级完的字节码文件是不是最新的。</p></li></ul></li><li><p><strong>思路：</strong></p><ul><li>在出问题的服务器上部署一个 arthas，并启动。</li><li>连接 arthas的控制台，使用 jad命令加上想要查看的类名，反编译出源码。</li><li>jad com.example.MyClass<ul><li>反编译源代码并用vim进行修改</li></ul></li><li>jad com.example.MyClass —source <ul><li>重新编译代码，会生成一个class文件</li></ul></li><li>redefine -c com.example.MyClass /path/to/MyClass.class<ul><li>对新的class文件进行热加载；问题修复</li></ul></li><li>热加载操作风险较高，一般还是不用</li></ul></li></ul><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><h4 id="生命周期概述"><a href="#生命周期概述" class="headerlink" title="生命周期概述"></a>生命周期概述</h4><p><img src="../assets/image/JVM_Image/image-20231013150945016.png" alt="image-20231013150945016"></p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>1、加载(Loading)阶段第一步是类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。</p><p>程序员可以使用Java代码拓展的不同的渠道。</p><ul><li>不同的渠道<ul><li><img src="../assets/image/JVM_Image/image-20231013151032653.png" alt="image-20231013151032653"></li></ul></li></ul><p>2、类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区（逻辑概念）中。</p><p>3、生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息</p><p><img src="../assets/image/JVM_Image/image-20231013151234026.png" alt="image-20231013151234026"></p><p>4、同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象。</p><p>作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）</p><p><img src="../assets/image/JVM_Image/image-20231013151321949.png" alt="image-20231013151321949"></p><p>对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息。</p><p>这样Java虚拟机就能很好地控制开发者访问数据的范围</p><p><img src="../assets/image/JVM_Image/image-20231013151424395.png" alt="image-20231013151424395"></p><p>推荐使用 JDK自带的hsdb工具查看Java虚拟机内存信息。工具位于JDK安装目录下lib文件夹中的sa-jdi.jar中。</p><p>启动命令：java -cp sa-jdi.jar sun.jvm.hotspot.HSDB</p><p><img src="../assets/image/JVM_Image/image-20231013151543597.png" alt="image-20231013151543597"></p><h4 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h4><p><img src="../assets/image/JVM_Image/image-20231013152133402.png" alt="image-20231013152133402"></p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>一共四部分</p><ol><li>文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求<ol><li><img src="../assets/image/JVM_Image/image-20231013152526229.png" alt="image-20231013152526229"></li></ol></li><li>元信息验证，例如类必须有父类（super不能为空）<ol><li><img src="../assets/image/JVM_Image/image-20231013152602411.png" alt="image-20231013152602411"></li></ol></li><li>验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。<ol><li><img src="../assets/image/JVM_Image/image-20231013152613495.png" alt="image-20231013152613495"></li></ol></li><li>.符号引用验证，例如是否访问了其他类中private的方法等</li></ol><p><strong>验证案例</strong></p><p>主版本号不能高于运行环境主版本号，如果主版本号相等，副版本号也不能超过。</p><p><img src="../assets/image/JVM_Image/image-20231013152757639.png" alt="image-20231013152757639"></p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段为静态变量（static）分配内存并设置初始值</p><p><img src="../assets/image/JVM_Image/image-20231013160932903.png" alt="image-20231013160932903"></p><p>准备阶段只会给静态变量赋初始值，而每一种基本数据类型和引用数据类型都有其初始值。</p><p><img src="../assets/image/JVM_Image/image-20231013160948366.png" alt="image-20231013160948366"></p><p>final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。</p><p><img src="../assets/image/JVM_Image/image-20231013161117629.png" alt="image-20231013161117629"></p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析阶段主要是将常量池中的符号引用替换为直接引用</p><p>符号引用就是在字节码文件中使用编号来访问常量池中的内容</p><p><img src="../assets/image/JVM_Image/image-20231013161223957.png" alt="image-20231013161223957"></p><p>直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。</p><p><img src="../assets/image/JVM_Image/image-20231013161242824.png" alt="image-20231013161242824"></p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>初始化阶段会执行静态代码块中的代码，并为静态变量赋值。</p><p>初始化阶段会执行字节码文件中clinit部分的字节码指令。</p><p><img src="../assets/image/JVM_Image/image-20231013161804372.png" alt="image-20231013161804372"></p><p><img src="../assets/image/JVM_Image/image-20231013163505886.png" alt="image-20231013163505886"></p><ul><li>以下几种方式会导致类的初始化<ul><li>访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化。</li><li>调用Class.forName(String className)。</li><li>new一个该类的对象时</li><li>执行Main方法的当前类</li></ul></li></ul><p><img src="../assets/image/JVM_Image/image-20231013164509318.png" alt="image-20231013164509318"></p><p>执行顺序举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 这是静态初始化块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这是实例初始化块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;实例初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这是构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，执行顺序是：</p><ol><li>静态初始化块中的代码。</li><li>实例初始化块中的代码。</li><li>构造方法中的代码。</li></ol><p>clinit指令在特定情况下不会出现，比如：如下几种情况是不会进行初始化指令执行的。</p><ul><li>无静态代码块且无静态变量赋值语句</li><li>有静态变量的声明，但是没有赋值语句。</li><li>静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化</li></ul><p>直接访问父类的静态变量，不会触发子类的初始化。</p><p>子类的初始化clinit调用之前，会先调用父类的clinit初始化方法</p><p><img src="../assets/image/JVM_Image/image-20231013165959472.png" alt="image-20231013165959472"></p><p>这里只调用了父类的静态变量，所以只初始化父类</p><p><img src="../assets/image/JVM_Image/image-20231013170045387.png" alt="image-20231013170045387"></p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p><img src="../assets/image/JVM_Image/image-20231013170818971.png" alt="image-20231013170818971"></p><p>final修饰的变量等号右边也是常量就不会初始化</p><p>但是这里等号右边是表达式，所以在准备阶段无法进行初始化，只能在初始化阶段进行初始化</p><p><img src="../assets/image/JVM_Image/image-20231013170944059.png" alt="image-20231013170944059"></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术</p><p>类加载器只参与加载过程中的字节码获取并加载到内存这一部分</p><p><img src="../assets/image/JVM_Image/image-20231013171318091.png" alt="image-20231013171318091"></p><p>应用场景</p><p><img src="../assets/image/JVM_Image/image-20231013171331752.png" alt="image-20231013171331752"></p><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p>类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的</p><p><img src="../assets/image/JVM_Image/image-20231013171514272.png" alt="image-20231013171514272"></p><p>类加载器的设计JDK8和8之后的版本差别较大，JDK8及之前的版本中默认的类加载器有如下几种</p><p><img src="../assets/image/JVM_Image/image-20231013171626958.png" alt="image-20231013171626958"></p><p><strong>Arthas中类加载器相关的功能</strong></p><p>类加载器的详细信息可以通过classloader命令查看</p><p>classloader - 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource</p><p><img src="../assets/image/JVM_Image/image-20231013171711791.png" alt="image-20231013171711791"></p><h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h5><p>启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器</p><p>默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，tools.jar，resources.jar等</p><ul><li>如何使用启动类加载器加载用户的jar包<ul><li>放入jre/lib下进行扩展<ul><li>不推荐，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载</li></ul></li><li>使用参数进行扩展<ul><li>推荐，使用-Xbootclasspath/a:jar包目录/jar包名 进行扩展</li></ul></li></ul></li></ul><h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><p>·扩展类加载器和应用程序类加载器都是JDK中提供的、使用Java编写的类加载器</p><p>它们的源码都位于sun.misc.Launcher中，是一个静态内部类。继承自URLClassLoader。具备通过目录或者指定jar包将字节码文件加载到内存中。</p><p><img src="../assets/image/JVM_Image/image-20231013171954944.png" alt="image-20231013171954944"></p><p>扩展类加载器默认加载Java安装目录/jre/lib/ext下的类文件</p><ul><li>如果使用扩展类加载器加载用户的jar包<ul><li>放入/jre/lib/ext下进行扩展<ul><li>不推荐，尽可能不要去更改JDK安装目录中的内容</li></ul></li><li>使用参数进行扩展<ul><li>推荐，使用-Djava.ext.dirs=jar包目录 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos/linux)追加上原始目录</li></ul></li></ul></li></ul><h5 id="应用类加载器"><a href="#应用类加载器" class="headerlink" title="应用类加载器"></a>应用类加载器</h5><p>加载classpath下的类文件</p><p>在Arthas中</p><p>类加载器的加载路径可以通过classloader –c hash值 查看</p><p><img src="../assets/image/JVM_Image/image-20231013172306376.png" alt="image-20231013172306376"></p><h4 id="双亲委派机制-1"><a href="#双亲委派机制-1" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><ul><li>在Java中如何使用代码的方式去主动加载一个类呢？<ul><li>方式1：使用Class.forName方法，使用当前类的类加载器去加载指定的类。</li><li>方式2：获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载</li></ul></li></ul><p>com.itheima.my.A这个类在扩展类加载器的范畴下</p><p><img src="../assets/image/JVM_Image/image-20231013172811959.png" alt="image-20231013172811959"></p><p>每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器，可以理解为它的上级，并不是继承关系。</p><p><img src="../assets/image/JVM_Image/image-20231014091813736.png" alt="image-20231014091813736"></p><p>应用程序类加载器的parent父类加载器是扩展类加载器，而扩展类加载器的parent是空</p><p>启动类加载器使用C++编写，没有上级类加载器</p><p><img src="../assets/image/JVM_Image/image-20231014091852748.png" alt="image-20231014091852748"></p><p>类加载器的继承关系可以通过classloader –t 查看</p><p><img src="../assets/image/JVM_Image/image-20231014091910377.png" alt="image-20231014091910377"></p><p>在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器</p><p><img src="../assets/image/JVM_Image/image-20231014091952683.png" alt="image-20231014091952683"></p><p>如果类加载的parent为null，则会提交给启动类加载器处理</p><p><img src="../assets/image/JVM_Image/image-20231014092010328.png" alt="image-20231014092010328"></p><p>如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。</p><p><img src="../assets/image/JVM_Image/image-20231014092036564.png" alt="image-20231014092036564"></p><p>第二次再去加载相同的类，仍然会向上进行委派，如果某个类加载器加载过就会直接返回</p><p><img src="../assets/image/JVM_Image/image-20231014092055240.png" alt="image-20231014092055240"></p><p><strong>双亲委派机制指的是：自底向上查找是否加载过，再由顶向下进行加载。</strong></p><p><img src="../assets/image/JVM_Image/image-20231014092618371.png" alt="image-20231014092618371"></p><ul><li><p>如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？</p><ul><li>启动类加载器加载，根据双亲委派机制，它的优先级是最高的</li></ul></li><li><p>在自己的项目中去创建一个java.lang.String类，会被加载吗</p><ul><li>不能，会交由启动类加载器加载在rt.jar包中的String类</li></ul></li><li><p>这几个类加载器彼此之间存在关系吗？</p><ul><li>应用类加载器的父类加载器是扩展类加载器，扩展类加载器没有父类加载器，但是会委派给启动类加载器加载</li></ul></li></ul><p><strong>双亲委派机制有什么用？</strong></p><ul><li><strong>保证类加载的安全性</strong><ul><li>通过双亲委派机制，让顶层的类加载器去加载核心类，避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心库的完整性和安全性。</li></ul></li><li><strong>避免重复加载</strong><ul><li>双亲委派机制可以避免同一个类被多次加载，上层的类加载器如果加载过类，就会直接返回该类，避免重复加载。</li></ul></li></ul><h4 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h4><ul><li>三种方式<ul><li>自定义类加载器并且重写loadClass方法，就可以将双亲委派机制的代码去除<ul><li>Tomcat通过这种方式实现应用之间类隔离</li></ul></li><li>利用上下文类加载器加载类，比如JDBC和JNDI等</li><li>历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载</li></ul></li></ul><h5 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h5><ul><li>一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类。</li><li>如果不打破双亲委派机制，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了。</li></ul><p>Tomcat使用了自定义类加载器来实现应用之间类的隔离</p><p>每一个应用会有一个独立的类加载器加载对应的类</p><p><img src="../assets/image/JVM_Image/image-20231014094842864.png" alt="image-20231014094842864"></p><p>先来分析ClassLoader的原理，ClassLoader中包含了4个核心方法。</p><p>双亲委派机制的核心代码就位于loadClass方法中。</p><p><img src="../assets/image/JVM_Image/image-20231014094915247.png" alt="image-20231014094915247"></p><p><img src="../assets/image/JVM_Image/image-20231014095200440.png" alt="image-20231014095200440"></p><p>自定义类加载器父类怎么是AppClassLoader呢？</p><p><img src="../assets/image/JVM_Image/image-20231014095213110.png" alt="image-20231014095213110"></p><p>自定义类加载器默认的父类加载器</p><p>以Jdk8为例，ClassLoader类中提供了构造方法设置parent的内容：</p><p><img src="../assets/image/JVM_Image/image-20231014095233878.png" alt="image-20231014095233878"></p><p>这个构造方法由另外一个构造方法调用，其中父类加载器由getSystemClassLoader方法设置，该方法返回的是AppClassLoader。</p><p><img src="../assets/image/JVM_Image/image-20231014095332893.png" alt="image-20231014095332893"></p><ul><li>两个自定义类加载器加载相同限定名的类，不会冲突吗？<ul><li>不会冲突，在同一个Java虚拟机中，只有相同类加载器+相同的类限定名才会被认为是同一个类</li></ul></li><li>在Arthas中使用sc –d 类名的方式查看具体的情况。</li></ul><h5 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h5><p>JDBC案例</p><p>JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。</p><p><img src="../assets/image/JVM_Image/image-20231014095457628.png" alt="image-20231014095457628"></p><p>DriverManager类位于rt.jar包中，由启动类加载器加载</p><p><img src="../assets/image/JVM_Image/image-20231014095518311.png" alt="image-20231014095518311"></p><p>依赖中的mysql驱动对应的类，由应用程序类加载器来加载</p><p><img src="../assets/image/JVM_Image/image-20231014095556372.png" alt="image-20231014095556372"></p><p>DriverManager属于rt.jar是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，这就违反了双亲委派机制。</p><p><img src="../assets/image/JVM_Image/image-20231014095701932.png" alt="image-20231014095701932"></p><p>DriverManager怎么知道jar包中要加载的驱动在哪儿？</p><p>总结</p><p><img src="../assets/image/JVM_Image/image-20231014104021886.png" alt="image-20231014104021886"></p><p>这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制</p><p>使用阿里arthas不停机解决线上问题</p><p><img src="../assets/image/JVM_Image/image-20231014105525337.png" alt="image-20231014105525337"></p><p><img src="../assets/image/JVM_Image/image-20231014105642830.png" alt="image-20231014105642830"></p><h4 id="JDK9之后的类加载器"><a href="#JDK9之后的类加载器" class="headerlink" title="JDK9之后的类加载器"></a>JDK9之后的类加载器</h4><p>JDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的sun.misc.Launcher.java。</p><p><img src="../assets/image/JVM_Image/image-20231014105845666.png" alt="image-20231014105845666"></p><ul><li>由于JDK9引入了module的概念，类加载器在设计上发生了很多变化<ul><li>启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中</li><li>Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。</li><li>启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。</li><li><img src="../assets/image/JVM_Image/image-20231014110059658.png" alt="image-20231014110059658"></li></ul></li><li>扩展类加载器被替换成了平台类加载器（Platform Class Loader）。<ul><li>平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了</li><li>BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件</li><li>平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑</li></ul></li></ul><ul><li><p>类加载器的作用是什么？</p><ul><li>类加载器（ClassLoader）负责在类加载过程中的字节码获取并加载到内存这一部分。通过加载字节码数据放入内存转换成byte[]，接下来调用虚拟机底层方法将byte[]转换成方法区和堆中的数据</li></ul></li><li><p>有几种类加载器？</p><ul><li>启动类加载器（Bootstrap ClassLoader）加载核心类</li><li>扩展类加载器（Extension ClassLoader）加载扩展类</li><li>应用程序类加载器（Application ClassLoader）加载应用classpath中的类</li><li>自定义类加载器，重写findClass方法</li><li>JDK9及之后扩展类加载器（Extension ClassLoader）变成了平台类加载器（PlatformClassLoader）</li><li><img src="../assets/image/JVM_Image/image-20231014114810759.png" alt="image-20231014114810759"></li></ul></li><li><p>什么是双亲委派机制？</p><ul><li>每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器。自底向上查找是否加载过，再由顶向下进行加载。避免了核心类被应用程序重写并覆盖的问题，提升了安全性</li><li><img src="../assets/image/JVM_Image/image-20231014114830256.png" alt="image-20231014114830256"></li></ul></li><li><p>怎么打破双亲委派机制？</p><ul><li><p>1、重写loadClass方法，不再实现双亲委派机制。</p><p>2、JNDI、JDBC、JCE、JAXB和JBI等框架使用了SPI机制+线程上下文类加载器。</p><p>3、OSGi实现了一整套类加载机制，允许同级类加载器之间互相调用</p></li></ul></li></ul><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="JVM组成-1"><a href="#JVM组成-1" class="headerlink" title="JVM组成"></a>JVM组成</h3><p>java代码编译成字节码之后，JVM中的类加载器，将字节码加载到内存中，之后执行引擎配合本地接口完成运行</p><p><img src="../assets/image/JVM_Image/image-20231014115107905.png" alt="image-20231014115107905"></p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>Java虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区</p><p><img src="../assets/image/JVM_Image/image-20231014115332767.png" alt="image-20231014115332767"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（<strong>Program Counter Register</strong>）也叫<strong>PC</strong>寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。</p><p><img src="../assets/image/JVM_Image/image-20231014181457829.png" alt="image-20231014181457829"></p><p>一个计数器的具体案例</p><p><img src="../assets/image/JVM_Image/image-20231014181635653.png" alt="image-20231014181635653"></p><p>在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个内存地址。（过程：加载、连接、初始化、使用、卸载）</p><p>在多线程执行情况下，<strong>Java</strong>虚拟机需要通过程序计数器记录<strong>CPU</strong>切换前解释执行到那一句指令并继续解释运行。</p><p><img src="../assets/image/JVM_Image/image-20231014181952547.png" alt="image-20231014181952547"></p><ul><li>程序计数器在运行中会出现内存溢出吗？<ul><li>内存溢出指的是程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限。</li><li>因为每个线程只存储一个固定长度的内存地址，程序计数器是不会发生内存溢出的。</li><li>程序员无需对程序计数器做任何处理</li></ul></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h1 id="Ai总结"><a href="#Ai总结" class="headerlink" title="Ai总结"></a>Ai总结</h1><h2 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h2><p>Java的内存结构包括几个不同的区域，每个区域都有特定的作用和用途。以下是Java内存结构的主要部分：</p><ol><li><p><strong>方法区（Method Area）</strong>：</p><ul><li>方法区是用于存储类的信息、静态变量、常量和方法字节码的内存区域。</li><li>类加载器将类加载到方法区中，并在运行时维护类的信息。</li><li>字符串常量池也位于方法区中，用于存储字符串常量。</li></ul></li><li><p><strong>堆内存（Heap）</strong>：</p><ul><li>堆内存是用于存储对象实例的主要区域。在堆中分配的内存由Java的垃圾回收器来管理。</li><li>所有通过 <code>new</code> 操作符创建的对象都存储在堆内存中。</li><li>堆内存可以分为新生代（Young Generation）、老年代（Old Generation）和持久代（PermGen，或者在Java 8+ 中被称为元空间 Metaspace）等不同的部分。</li></ul></li><li><p><strong>栈内存（Stack）</strong>：</p><ul><li>栈内存用于存储方法调用的局部变量、方法参数和方法调用的状态。</li><li>每个线程都有自己的栈，它包括栈帧（Stack Frame），每个栈帧对应一个方法调用。</li><li>栈内存中的数据是线程私有的，不存在线程安全问题。</li></ul></li><li><p><strong>本地方法栈（Native Method Stack）</strong>：</p><ul><li>本地方法栈用于存储Java程序调用本地方法（Native Method）的信息。</li><li>本地方法是用其他编程语言编写的，例如C或C++，并通过JNI（Java Native Interface）与Java程序进行交互。</li></ul></li><li><p><strong>程序计数器（Program Counter Register）</strong>：</p><ul><li>程序计数器是一个小的内存区域，用于存储当前线程正在执行的字节码指令的地址。</li><li>在多线程环境下，每个线程都有自己的程序计数器，用于跟踪线程执行的位置。</li></ul></li><li><p><strong>直接内存（Direct Memory）</strong>：</p><ul><li>直接内存不是Java虚拟机的一部分，但是在Java程序中使用了<code>java.nio</code>包的一些类，例如<code>ByteBuffer</code>，它们可以分配直接内存，而不是堆内存。</li><li>直接内存由操作系统管理，通常用于I/O操作，可以提高性能。</li></ul></li></ol><p>这些内存区域在Java应用程序的运行过程中扮演不同的角色，而且它们的大小和管理方式都可以通过Java虚拟机的启动参数进行调整。了解这些内存区域对于理解Java内存管理和解决性能问题非常重要。</p><h2 id="Java如何解决原子性、可见性、有序性问题-1"><a href="#Java如何解决原子性、可见性、有序性问题-1" class="headerlink" title="Java如何解决原子性、可见性、有序性问题"></a>Java如何解决原子性、可见性、有序性问题</h2><p>Java通过使用关键字 <code>volatile</code>、<code>synchronized</code>、<code>java.util.concurrent</code> 包以及原子类来解决原子性、可见性和有序性问题。</p><ol><li><p><strong>原子性（Atomicity）</strong>：</p><ul><li>原子性问题指的是多线程环境下，一个操作是否能够被看作是不可分割的单个操作。</li><li>Java提供了原子操作的支持，主要通过 <code>java.util.concurrent.atomic</code> 包中的原子类来实现。例如，<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code> 等。</li><li>这些原子类提供了一系列的原子操作，可以保证在多线程环境下某个操作的原子性，而不需要显式地使用<code>synchronized</code>关键字。</li></ul></li><li><p><strong>可见性（Visibility）</strong>：</p><ul><li>可见性问题指的是一个线程对共享变量的修改是否能够被其他线程立即看到。</li><li>使用 <code>volatile</code> 关键字可以保证可见性。当一个变量被声明为 <code>volatile</code>，对它的写操作将会立即刷新到主内存，并且对它的读操作也会从主内存中读取，而不是从线程的本地缓存中读取。</li><li>同时，Java的锁机制（例如 <code>synchronized</code>）也可以保证可见性，因为在释放锁之前，所有对共享变量的修改都会刷新到主内存。</li></ul></li><li><p><strong>有序性（Ordering）</strong>：</p><ul><li>有序性问题指的是程序中的操作是否按照预期的顺序执行。</li><li>Java提供了一些机制来保证操作的有序性。首先，<code>volatile</code> 关键字可以保证变量的读写顺序，这意味着在一个线程写入一个 <code>volatile</code> 变量之后，它后面的所有操作都不会被重排序到写操作之前。</li><li>另外，<code>synchronized</code> 块也可以保证进入和退出临界区的代码不会被重排序。</li></ul></li></ol><p>总结：<br>Java提供了多种机制来解决并发编程中的原子性、可见性和有序性问题。选择合适的机制取决于具体的需求和场景。在Java 5及以后的版本中，使用 <code>java.util.concurrent</code> 包中的工具和原子类可以更容易地编写线程安全的代码。</p><h2 id="as-if-serial-1"><a href="#as-if-serial-1" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p>“as-if-serial” 是Java内存模型（Java Memory Model，JMM）中的一个概念，用于描述编译器和处理器对程序代码的重排序和优化。</p><p>“as-if-serial” 原则的核心思想是，编译器和处理器可以对程序代码进行各种优化，只要在单线程执行程序时的最终结果与按照程序的顺序执行得到的结果一致，就是合法的。换句话说，即使编译器和处理器对指令重排序、缓存优化等进行了优化，只要这些优化不会改变程序在单线程执行时的行为，就被认为是符合 “as-if-serial” 原则的。</p><p>这个原则的存在是为了允许编译器和处理器在不破坏程序正确性的前提下进行性能优化。在多线程环境下，”as-if-serial” 原则对于确保多线程程序的正确性也是非常重要的。虽然编译器和处理器可以对指令进行重排序，但它们需要遵守一些规则和约束，以确保多线程程序的可见性和正确性。这些规则包括使用 <code>volatile</code> 关键字、<code>synchronized</code> 块、<code>final</code> 字段等来禁止某些重排序操作，以确保多线程程序的行为与单线程执行时的行为一致。</p><p>总之，”as-if-serial” 原则是Java内存模型中的一个基本概念，它允许编译器和处理器在不改变程序正确性的前提下进行各种优化，从而提高程序的性能。但在多线程编程中，需要谨慎处理并确保正确使用同步机制来保证线程安全。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>“happens-before” 是Java内存模型（Java Memory Model，JMM）中的一个关键概念，用于描述多线程程序中操作之间的顺序和可见性规则。”happens-before” 规则定义了在多线程环境下，一个操作对另一个操作的可见性和顺序的影响。</p><p>具体来说，”happens-before” 规则包括以下情况：</p><ol><li><p><strong>程序顺序规则（Program Order Rule）</strong>：</p><ul><li>在单个线程中，操作按照程序中的顺序执行，也就是说，程序中的操作顺序必须被保留。</li></ul></li><li><p><strong>监视器锁规则（Monitor Lock Rule）</strong>：</p><ul><li>对一个监视器（synchronized块或方法）的解锁操作 <code>unlock</code> 必须在随后的锁操作 <code>lock</code> 之前执行，确保在一个线程释放锁之后，另一个线程能够获取相同的锁。</li></ul></li><li><p><strong>volatile变量规则（Volatile Variable Rule）</strong>：</p><ul><li>对一个 <code>volatile</code> 变量的写操作必须在随后的读操作之前执行，确保写操作对其他线程可见。</li></ul></li><li><p><strong>线程启动规则（Thread Start Rule）</strong>：</p><ul><li>在一个线程中，启动另一个线程的操作 <code>Thread.start()</code> 必须在新线程的任何操作之前执行，确保新线程能够看到启动线程的操作。</li></ul></li><li><p><strong>线程结束规则（Thread Termination Rule）</strong>：</p><ul><li>在一个线程中，线程的所有操作必须在另一个线程检测到线程已经终止之前执行。</li></ul></li><li><p><strong>传递性规则（Transitivity）</strong>：</p><ul><li>如果操作 A “happens-before” 操作 B，且操作 B “happens-before” 操作 C，那么操作 A “happens-before” 操作 C。</li></ul></li></ol><p>“happens-before” 规则帮助程序员理解多线程程序中操作之间的顺序和可见性，确保程序在不同线程之间能够正确地协同工作。这些规则对于避免竞态条件（Race Condition）和确保线程安全非常重要。在实际编码中，通常会使用同步机制（例如<code>synchronized</code>关键字和<code>volatile</code>关键字）来确保 “happens-before” 规则的正确应用。</p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>在Java中，堆（Heap）和栈（Stack）是两种不同的内存区域，用于存储不同类型的数据和对象。它们具有不同的特性和用途：</p><ol><li><p><strong>堆（Heap）</strong>：</p><ul><li><p><strong>用途</strong>：堆是用来存储对象实例的内存区域。在堆中分配的对象拥有较长的生命周期，通常存活于方法之外，直到没有引用指向它们时才会被垃圾回收。</p></li><li><p><strong>特点</strong>：堆是在JVM启动时分配的，所有线程共享它。堆内存的大小可以通过启动JVM时的参数来调整。Java的垃圾回收器会定期清理不再被引用的对象，释放堆内存。</p></li><li><p><strong>对象存储</strong>：在堆中存储的对象可以动态分配和释放。对象的生命周期由其引用决定，当没有引用指向一个对象时，它就会成为垃圾，等待垃圾回收。</p></li><li><p><strong>多线程共享</strong>：多个线程可以同时访问堆，并在堆中分配对象。因此，堆是线程安全的，但需要注意同步问题。</p></li></ul></li><li><p><strong>栈（Stack）</strong>：</p><ul><li><p><strong>用途</strong>：栈主要用来存储线程的方法调用和局部变量，它的生命周期与线程的生命周期相同，即在方法调用时创建，方法返回时销毁。</p></li><li><p><strong>特点</strong>：每个线程都有自己的栈，栈是线程私有的。栈内存的大小通常比堆小得多，它在JVM启动时分配给每个线程，因此每个线程有自己独立的栈。</p></li><li><p><strong>方法调用</strong>：栈用于存储方法的调用栈帧。每当一个方法被调用，一个新的栈帧会被压入栈顶，用于存储方法的局部变量、方法参数和方法返回地址等信息。当方法返回时，栈帧被弹出，恢复上一个方法的上下文。</p></li><li><p><strong>局部变量</strong>：局部变量（如基本数据类型和对象引用）通常存储在栈中，它们的生命周期与方法的执行周期相对应。</p></li><li><p><strong>线程安全</strong>：由于每个线程都有自己的栈，栈是线程安全的，不需要显式的同步措施。</p></li></ul></li></ol><p>总结：</p><ul><li>堆和栈是Java中两种不同的内存区域，用于存储不同类型的数据和对象。</li><li>堆用于存储对象实例，拥有较长的生命周期，由垃圾回收器管理。</li><li>栈用于存储方法调用和局部变量，生命周期与方法的执行周期相对应，是线程私有的。</li><li>堆和栈在内存管理和生命周期方面有不同的特性，了解它们的区别对于编写高效和正确的Java程序非常重要。</li></ul><h2 id="Java字节码常见指令"><a href="#Java字节码常见指令" class="headerlink" title="Java字节码常见指令"></a>Java字节码常见指令</h2><p>Java 字节码是一种中间代码，它是Java源代码编译后生成的，然后由Java虚拟机（JVM）执行的指令集。下面是一些常见的Java字节码指令：</p><ol><li><strong>aload</strong>: 将引用类型的局部变量加载到操作数栈上。</li><li><strong>astore</strong>: 将操作数栈上的引用类型的值存储到局部变量中。</li><li><strong>istore</strong>：指令用于将操作数栈上的整数值存储到局部变量中</li><li><strong>iconst</strong>: 将整数常量（通常是-1、0、1、2、3、4、5）加载到操作数栈上。</li><li><strong>bipush</strong>: 将一个字节值（-128 到 127）加载到操作数栈上。</li><li><strong>sipush</strong>: 将一个短整数值（-32,768 到 32,767）加载到操作数栈上。</li><li><strong>iadd</strong>, <strong>isub</strong>, <strong>imul</strong>, <strong>idiv</strong>, <strong>irem</strong>: 分别执行整数的加法、减法、乘法、除法和取余操作。</li><li><strong>ladd</strong>, <strong>lsub</strong>, <strong>lmul</strong>, <strong>ldiv</strong>, <strong>lrem</strong>: 分别执行长整数的加法、减法、乘法、除法和取余操作。</li><li><strong>fadd</strong>, <strong>fsub</strong>, <strong>fmul</strong>, <strong>fdiv</strong>: 分别执行单精度浮点数的加法、减法、乘法和除法。</li><li><strong>dadd</strong>, <strong>dsub</strong>, <strong>dmul</strong>, <strong>ddiv</strong>: 分别执行双精度浮点数的加法、减法、乘法和除法。</li><li><strong>iinc</strong>: 对局部整数变量进行增量操作。</li><li><strong>if&lt;条件&gt;</strong>: 根据条件跳转到不同的指令。</li><li><strong>goto</strong>: 无条件跳转到指定的指令。</li><li><strong>return</strong>: 从方法返回。</li><li><strong>invokevirtual</strong>, <strong>invokespecial</strong>, <strong>invokestatic</strong>: 分别用于调用虚拟方法、特殊方法（构造函数等）和静态方法。</li><li><strong>new</strong>: 创建一个新的对象。</li><li><strong>dup</strong>: 复制栈顶的数值。</li><li><strong>pop</strong>: 弹出栈顶的数值。</li><li><strong>checkcast</strong>: 检查对象是否能够转换为指定的类型。</li><li><strong>instanceof</strong>: 检查对象是否是指定类型的实例。</li></ol><p>这只是一小部分常见的Java字节码指令，Java字节码包含了更多的指令和操作码，用于执行各种操作，包括方法调用、条件分支、异常处理等。每个指令都有特定的操作码，参数和操作数，它们在JVM中执行Java程序时起到关键作用。</p><h2 id="Arthas-1"><a href="#Arthas-1" class="headerlink" title="Arthas"></a>Arthas</h2><p><img src="../assets/image/JVM_Image/image-20231013143940911.png" alt="image-20231013143940911"></p><h2 id="堆区和方法区"><a href="#堆区和方法区" class="headerlink" title="堆区和方法区"></a>堆区和方法区</h2><p>JVM中的堆区（Heap）和方法区（Method Area）不同，它们具有不同的作用和存储内容：</p><ol><li><p>堆区（Heap）：</p><ul><li>堆区是用于存储对象实例的内存区域。</li><li>所有通过<code>new</code>关键字创建的对象都存储在堆区中。</li><li>堆区是Java中最大的内存区域之一，用于动态分配内存，支持垃圾回收。</li><li>堆区中的内存管理是基于分代的，分为新生代和老年代，以便更有效地进行垃圾回收。</li></ul></li><li><p>方法区（Method Area）：</p><ul><li>方法区是用于存储类的元数据信息、静态成员变量、常量池和方法字节码等数据的内存区域。</li><li>方法区中包含了类的结构信息，包括类的字段、方法、构造函数、常量池、方法字节码以及其他类相关的元信息。</li><li>方法区在Java虚拟机规范中通常是永久代（PermGen）的一部分，尽管在Java 8及以后的版本中，永久代被元数据区（Metaspace）取代。</li><li>方法区主要用于支持Java类的加载、解析和运行时动态生成类。</li></ul></li></ol><p>虽然堆区和方法区在JVM中都扮演着重要的角色，但它们的职责和存储内容完全不同。堆区用于存储对象实例，而方法区用于存储类的元数据和方法相关的信息。在Java 8及以后的版本中，方法区被替代为元数据区（Metaspace），因此这两个区域的实现和管理方式也存在显著差异。</p>]]></content>
    
    
    <summary type="html">🍔本文汇总JVM的基础知识点</summary>
    
    
    
    <category term="底层" scheme="https://momoao.github.io/categories/%E5%BA%95%E5%B1%82/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://momoao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>C++QT</title>
    <link href="https://momoao.github.io/posts/202308241636.html"/>
    <id>https://momoao.github.io/posts/202308241636.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-27T07:39:45.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-QT"><a href="#C-QT" class="headerlink" title="C++QT"></a>C++QT</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><p>QT（Qt）是一个跨平台的应用程序开发框架，用于开发图形界面应用程序和嵌入式系统。它由Qt Company（前身为Nokia）开发并维护，采用C++编写，并提供了丰富的库和工具，以简化软件开发过程。</p><p>Qt提供了一套完整的工具和组件，使开发人员能够构建高性能、可扩展和易于维护的应用程序。它支持多种操作系统，包括Windows、macOS、Linux、Android和iOS等。使用Qt，开发人员可以编写一次代码，然后将其移植到不同平台上运行，从而实现跨平台开发。</p><p>Qt框架的主要特点包括：</p><ol><li><p>跨平台：Qt允许开发人员在不同的操作系统上进行开发，并提供了一致的API和工具。</p></li><li><p>可视化设计：Qt提供了一套可视化设计工具，如Qt Designer，可帮助开发人员轻松设计和布局图形界面。</p></li><li><p>丰富的库：Qt提供了许多功能强大的库，涵盖了各种领域，包括图形渲染、网络通信、数据库访问、多媒体处理等。</p></li><li><p>信号与槽机制：Qt引入了信号与槽机制，用于实现对象之间的通信和事件处理，使得应用程序的逻辑更加灵活和易于组织。</p></li><li><p>多线程支持：Qt提供了多线程编程的支持，使开发人员能够轻松地编写并发和并行的应用程序。</p></li></ol><p>Qt广泛用于开发各种类型的应用程序，包括桌面应用程序、移动应用程序、嵌入式系统和图形化工具等。它被广泛应用于行业领域，如自动化、医疗、游戏开发、航空航天等。</p><p>总而言之，Qt是一个跨平台的应用程序开发框架，用于开发图形界面应用程序和嵌入式系统。它提供了丰富的库和工具，使开发人员能够轻松构建跨平台、高性能和可扩展的应用程序。</p><h2 id="QML"><a href="#QML" class="headerlink" title="QML"></a>QML</h2><p>QML（Qt Meta-Object Language）是一种用于构建用户界面的声明性语言，由Qt框架提供支持。它被广泛用于开发跨平台的桌面、移动和嵌入式应用程序。QML的设计理念是将界面的结构、外观和交互逻辑分离，使开发人员能够以一种直观和灵活的方式创建富有吸引力的用户界面。</p><p>以下是QML的一些重要特点和概念：</p><ol><li><p><strong>声明性语言</strong>：QML是一种声明性语言，它通过描述界面元素之间的关系和属性来定义用户界面。开发人员可以使用简洁的语法来声明界面的结构、样式和行为，而无需编写大量的代码。</p></li><li><p><strong>对象模型</strong>：QML基于对象模型，其中界面元素被表示为可重用的对象。这些对象可以具有属性、信号和方法，可以嵌套和组合形成层次结构。这种对象模型使得构建复杂的界面变得容易，并支持代码的模块化和重用。</p></li><li><p><strong>视觉元素</strong>：QML提供了丰富的视觉元素来构建用户界面，包括矩形、圆角矩形、文本、图像、按钮、列表视图等。这些元素可以通过设置属性来定制外观和行为，并可以使用动画和过渡效果来增强用户体验。</p></li><li><p><strong>布局和位置</strong>：QML提供了灵活的布局和位置管理器，使开发人员能够定义界面元素的位置和大小。可以使用垂直布局、水平布局、栅格布局等来自动排列元素，并支持锚点、填充、对齐等属性来控制元素的位置。</p></li><li><p><strong>信号和槽机制</strong>：QML支持信号和槽机制，用于处理用户输入和界面元素之间的通信。可以定义信号并将其连接到特定的槽函数，以响应事件或数据的变化。这种机制使得实现交互逻辑和处理用户操作变得简单和直观。</p></li><li><p><strong>动画和过渡效果</strong>：QML具有内置的动画和过渡效果系统，使开发人员能够创建平滑的界面动画。可以在属性之间定义动画，例如淡入淡出、平移、旋转等，以及在不同界面状态之间定义过渡效果，例如页面切换效果。</p></li><li><p><strong>与C++的交互</strong>：QML可以与C++代码进行无缝集成，通过Qt的元对象系统实现跨语言交互。可以将QML界面与后端的C++逻辑相结合，使开</p></li></ol><p>发人员能够充分利用Qt框架提供的强大功能和库。</p><p>总而言之，QML是一种强大的用户界面开发语言，它以声明性的方式描述界面元素，具有灵活的布局和位置管理，支持动画和过渡效果，并能与C++代码进行交互。通过使用QML，开发人员可以更快速、更高效地构建出色的跨平台应用程序。</p><h2 id="信号和槽机制"><a href="#信号和槽机制" class="headerlink" title="信号和槽机制"></a>信号和槽机制</h2><p>在Qt中，信号（Signals）和槽（Slots）机制是一种用于实现对象间通信的重要机制。它是Qt框架中的核心特性之一，用于解耦和连接不同的对象。</p><p>信号（Signals）是Qt对象在特定事件发生时发出的消息。一个信号可以被视为一个特定事件的发出者。例如，当按钮被点击时，QPushButton类可以发出一个clicked（点击）信号。</p><p>槽（Slots）是Qt对象中的成员函数，用于响应信号的发出。槽可以被视为信号的接收者，它定义了当特定信号发生时应该执行的操作。例如，你可以创建一个槽函数来处理按钮点击事件，并执行相应的操作。</p><p>信号和槽机制的连接是通过使用QObject类的connect()函数来实现的。这个函数接受一个发出信号的对象、一个信号的名称、一个接收信号的对象和一个槽函数的名称作为参数。当信号被发出时，与之连接的槽函数会被自动调用。</p><p>以下是一个简单的示例，演示了信号和槽的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(QObject *parent = <span class="literal">nullptr</span>) : <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">        QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click me&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">connect</span>(button, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleButtonClick</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button clicked!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyClass myObject;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，MyClass是一个自定义的QObject子类，它包含一个按钮（QPushButton）。当按钮被点击时，clicked()信号会被发出。这个信号与MyClass类中的handleButtonClick()槽函数连接起来。当点击按钮时，handleButtonClick()函数会被调用，并输出”Button clicked!”。</p><p>需要注意的是，为了使用信号和槽机制，必须将QObject子类的头文件包含进来，并在类的定义中使用Q_OBJECT宏。这个宏会为类添加必要的元对象（Meta-Object）信息，以支持信号和槽的连接。</p><p>总结一下，信号和槽机制是Qt中一种强大的对象间通信方式，它允许对象之间的解耦和灵活连接。通过使用信号和槽，你可以实现事件的响应和数据的传递，使得Qt程序更加灵活和可扩展。</p><h1 id="界面解读"><a href="#界面解读" class="headerlink" title="界面解读"></a>界面解读</h1><h2 id="设计界面"><a href="#设计界面" class="headerlink" title="设计界面"></a>设计界面</h2><p><img src="../assets/image/C++QT_Image/image-20230622134750896.png" alt="image-20230622134750896"></p><h3 id="Layouts-布局"><a href="#Layouts-布局" class="headerlink" title="Layouts-布局"></a>Layouts-布局</h3><p><img src="../assets/image/C++QT_Image/image-20230622135030754.png" alt="image-20230622135030754"></p><p>水平布局</p><p>垂直布局</p><p>网格布局        （计算器）</p><p>表单布局</p><h3 id="Spacers-弹簧"><a href="#Spacers-弹簧" class="headerlink" title="Spacers-弹簧"></a>Spacers-弹簧</h3><p><img src="../assets/image/C++QT_Image/image-20230622135023591.png" alt="image-20230622135023591"></p><p>水平弹簧</p><p>竖直弹簧</p><p><img src="../assets/image/C++QT_Image/image-20230622135014724.png" alt="image-20230622135014724"></p><p>例如：确定的左边就空了好多地方，就是因为有一个水平的弹簧</p><h3 id="Buttons-按钮"><a href="#Buttons-按钮" class="headerlink" title="Buttons-按钮"></a>Buttons-按钮</h3><p><img src="../assets/image/C++QT_Image/image-20230622135116717.png" alt="image-20230622135116717"></p><p>普通按钮</p><p>工具按钮</p><p>单选按钮</p><p>复选按钮</p><p>命令链接按钮</p><p>对话框按钮盒</p><h3 id="Item-Views-Model-Based-单元视图"><a href="#Item-Views-Model-Based-单元视图" class="headerlink" title="Item Views(Model-Based)-单元视图"></a>Item Views(Model-Based)-单元视图</h3><p><img src="../assets/image/C++QT_Image/image-20230622152529030.png" alt="image-20230622152529030"></p><p>列表视图</p><p>树形视图</p><p>表格视图</p><h2 id="界面元素"><a href="#界面元素" class="headerlink" title="界面元素"></a>界面元素</h2><p>从上到下表明了继承关系</p><p><img src="../assets/image/C++QT_Image/image-20230622154010513.png" alt="image-20230622154010513"></p><h1 id="按钮操作"><a href="#按钮操作" class="headerlink" title="按钮操作"></a>按钮操作</h1><h2 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h2><p>右键按钮选择转到槽</p><p><img src="../assets/image/C++QT_Image/image-20230622162057438.png" alt="image-20230622162057438"></p><p>之后选择一种信号类型</p><p><img src="../assets/image/C++QT_Image/image-20230622162121883.png" alt="image-20230622162121883"></p><p>在widget.h文件中就会自动生成</p><p><img src="../assets/image/C++QT_Image/image-20230622162157178.png" alt="image-20230622162157178"></p><p>在widget.cpp文件中就会自动生成</p><p><img src="../assets/image/C++QT_Image/image-20230622162213901.png" alt="image-20230622162213901"></p><p>之后在方法体里写点击按钮后执行的操作</p><p>获取对象文本，执行这个进程</p><p>例如：输入notepad后就会打开记事本</p><p><img src="../assets/image/C++QT_Image/image-20230622162236358.png" alt="image-20230622162236358"></p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>在构造方法中使用connect函数</p><p><img src="../assets/image/C++QT_Image/image-20230622162400415.png" alt="image-20230622162400415"></p><h1 id="connect-使用"><a href="#connect-使用" class="headerlink" title="connect()使用"></a>connect()使用</h1><p>在Qt中，<code>connect()</code>函数是用于建立信号与槽（Signal-Slot）之间的连接，实现对象之间的通信。以下是<code>connect()</code>函数的基本语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(signal), receiver, <span class="built_in">SLOT</span>(slot));</span><br></pre></td></tr></table></figure><p>例如：</p><p><img src="../assets/image/C++QT_Image/image-20230623123021722.png" alt="image-20230623123021722"></p><p>其中，<code>sender</code>是发送信号的对象，<code>signal</code>是信号的名称，<code>receiver</code>是接收信号的对象，<code>slot</code>是槽的名称。</p><p>下面是一个使用<code>connect()</code>函数的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">mySignal</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">(<span class="type">const</span> QString&amp; message)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receiveSlot</span><span class="params">(<span class="type">const</span> QString&amp; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="literal">nullptr</span>, <span class="string">&quot;Message&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    Sender sender;</span><br><span class="line">    Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接信号和槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;sender, <span class="built_in">SIGNAL</span>(<span class="built_in">mySignal</span>(<span class="type">const</span> QString&amp;)), &amp;receiver, <span class="built_in">SLOT</span>(<span class="built_in">receiveSlot</span>(<span class="type">const</span> QString&amp;)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    sender.<span class="built_in">sendSignal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，定义了两个类：<code>Sender</code>和<code>Receiver</code>。<code>Sender</code>类有一个<code>sendSignal()</code>函数，它通过<code>emit</code>关键字发出一个带有字符串参数的自定义信号<code>mySignal</code>。<code>Receiver</code>类有一个<code>receiveSlot()</code>槽函数，它接收一个字符串参数，并使用<code>QMessageBox::information()</code>显示消息框。</p><p>在<code>main()</code>函数中，创建了<code>Sender</code>和<code>Receiver</code>的实例。然后，使用<code>connect()</code>函数将<code>Sender</code>对象的<code>mySignal</code>信号与<code>Receiver</code>对象的<code>receiveSlot</code>槽函数进行连接。</p><p>最后，调用<code>sender.sendSignal()</code>发送信号，当信号发出时，会自动触发槽函数<code>receiver.receiveSlot()</code>，并在消息框中显示收到的消息。</p><p>需要注意的是，为了正确使用信号和槽机制，需要在相应的类声明中添加<code>Q_OBJECT</code>宏，并使用<code>SIGNAL()</code>和<code>SLOT()</code>宏来指定信号和槽的名称。此外，还需要使用Qt的元对象系统（Meta-Object System）来支持信号和槽的连接，因此需要在代码中包含<code>&lt;QObject&gt;</code>头文件，并在构建配置文件中添加相应的Qt模块依赖。</p><p>这只是一个简单的<code>connect()</code>函数使用示例，实际中可以根据具体的需求和场景来连接不同的信号和槽。在Qt的官方文档中可以找到更详细的<code>connect()</code>函数用法和示例。</p><h2 id="QT自带信号"><a href="#QT自带信号" class="headerlink" title="QT自带信号"></a>QT自带信号</h2><p>Qt框架自带了许多常用的信号，可以在各种Qt类中使用。以下是一些常见的Qt自带信号的示例：</p><ol><li><p>QPushButton类的信号：</p><ul><li>clicked()：按钮被点击时发出的信号。</li><li>pressed()：按钮被按下时发出的信号。</li><li>released()：按钮被释放时发出的信号。</li></ul></li><li><p>QCheckBox类的信号：</p><ul><li>clicked()：复选框被点击时发出的信号。</li><li>stateChanged(int)：复选框状态改变时发出的信号，参数是新的状态值。</li></ul></li><li><p>QLineEdit类的信号：</p><ul><li>textChanged(const QString&amp;)：文本框内容改变时发出的信号，参数是新的文本内容。</li><li>editingFinished()：编辑完成时发出的信号。</li></ul></li><li><p>QComboBox类的信号：</p><ul><li>currentIndexChanged(int)：下拉框当前选项改变时发出的信号，参数是新选中的选项索引。</li></ul></li><li><p>QSlider类的信号：</p><ul><li>valueChanged(int)：滑动条值改变时发出的信号，参数是新的值。</li></ul></li><li><p>QListWidget类的信号：</p><ul><li>itemClicked(QListWidgetItem*)：列表项被点击时发出的信号，参数是被点击的列表项对象。</li></ul></li><li><p>QTimer类的信号：</p><ul><li>timeout()：定时器超时时发出的信号。</li></ul></li></ol><p>以上只是一些常见的Qt类的信号示例，实际上Qt框架中还有很多其他类的信号可供使用。你可以通过查阅Qt的官方文档来获取完整的信号列表和使用说明，以便在编程中选择适合的信号来实现所需的功能。</p><p>附加：</p><p><code>returnPressed()</code>是Qt中某些组件（如QLineEdit）的一个信号。当用户在该组件上按下回车键时，就会发出<code>returnPressed()</code>信号。</p><h1 id="组件中值的获取"><a href="#组件中值的获取" class="headerlink" title="组件中值的获取"></a>组件中值的获取</h1><p>在Qt的UI中，可以使用各种组件（例如QLineEdit、QComboBox、QSlider等）来接收用户的输入或选择。要获取这些组件中的值，可以使用相应的方法或属性。下面是一些常见组件值获取的示例：</p><ol><li><p>QLineEdit（文本框）：</p><ul><li>使用<code>text()</code>方法获取文本框中的文本值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLineEdit* lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">QString text = lineEdit-&gt;<span class="built_in">text</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>QComboBox（下拉框）：</p><ul><li>使用<code>currentText()</code>方法获取当前选中项的文本值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QComboBox* comboBox = <span class="keyword">new</span> <span class="built_in">QComboBox</span>(<span class="keyword">this</span>);</span><br><span class="line">QString selectedText = comboBox-&gt;<span class="built_in">currentText</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>QSlider（滑动条）：</p><ul><li>使用<code>value()</code>方法获取滑动条的当前值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSlider* slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="type">int</span> value = slider-&gt;<span class="built_in">value</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>QCheckBox（复选框）：</p><ul><li>使用<code>isChecked()</code>方法获取复选框的选中状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox* checkBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="type">bool</span> checked = checkBox-&gt;<span class="built_in">isChecked</span>();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>QRadioButton（单选按钮）：</p><ul><li>使用<code>isChecked()</code>方法获取单选按钮的选中状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton* radioButton = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="type">bool</span> checked = radioButton-&gt;<span class="built_in">isChecked</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>这些是一些常见组件值获取的示例，每个组件都有适用于获取值的方法。可以根据具体的组件类型和需求，查阅Qt的官方文档以获取更多关于组件的属性和方法的详细信息。</p><p>另外，还可以使用信号和槽机制来捕获组件值的变化。例如，可以连接文本框的<code>textChanged()</code>信号或滑动条的<code>valueChanged()</code>信号，当值发生变化时触发相应的槽函数，在槽函数中获取最新的值并进行处理。</p><h1 id="添加图片资源"><a href="#添加图片资源" class="headerlink" title="添加图片资源"></a>添加图片资源</h1><p>右键项目添加新文件</p><p><img src="../assets/image/C++QT_Image/image-20230623131551654.png" alt="image-20230623131551654"></p><p>将图片文件放在一个res文件夹内，并放在项目下</p><p><img src="../assets/image/C++QT_Image/image-20230623131634103.png" alt="image-20230623131634103"></p><p>将rcc.exe添加到环境变量中</p><p>D:\QT5.9\5.9\mingw53_32\bin</p><p>在cmd中使用rcc指令将qrc中包含的图片文件变为二进制文件plane.rcc</p><p><strong>rcc -binary res.qrc -o plane.rcc</strong></p><p><img src="../assets/image/C++QT_Image/image-20230623131736291.png" alt="image-20230623131736291"></p><p>使用这个二进制文件时，需要包含头文件</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <QResource></h1><p>注册二进制文件信息</p><p>之后就可以通过QResource::registerResource(GAME_RES_PATH);来指明引入了什么资源，可以删除qrc文件，但是res文件夹要留着</p><p>注意：这里的路径是项目的所在目录，而不是项目目录下</p><h1 id="define-GAME-RES-PATH-“PlaneWar-plane-rcc”"><a href="#define-GAME-RES-PATH-“PlaneWar-plane-rcc”" class="headerlink" title="define GAME_RES_PATH “PlaneWar/plane.rcc”"></a>define GAME_RES_PATH “PlaneWar/plane.rcc”</h1><p><img src="../assets/image/C++QT_Image/image-20230623132226055.png" alt="image-20230623132226055"></p><p>在初始化方法中设置图标即可在窗口左上角加载</p><p>需要#include <QIcon></p><p><img src="../assets/image/C++QT_Image/image-20230623132645766.png" alt="image-20230623132645766"></p><h1 id="程序开发"><a href="#程序开发" class="headerlink" title="程序开发"></a>程序开发</h1><h2 id="地图滚动"><a href="#地图滚动" class="headerlink" title="地图滚动"></a>地图滚动</h2><h3 id="map-h"><a href="#map-h" class="headerlink" title="map.h"></a>map.h</h3><p>负责定义地图的坐标计算方法</p><p><img src="../assets/image/C++QT_Image/image-20230623162142354.png" alt="image-20230623162142354"></p><h3 id="map-cpp"><a href="#map-cpp" class="headerlink" title="map.cpp"></a>map.cpp</h3><p>在构造方法里加载地图图片，初始化这两个图片Y坐标，设置滚动速度</p><p>地图的坐标改变计算</p><p><img src="../assets/image/C++QT_Image/image-20230623163427376.png" alt="image-20230623163427376"></p><h3 id="mainscene-h"><a href="#mainscene-h" class="headerlink" title="mainscene.h"></a>mainscene.h</h3><p><img src="../assets/image/C++QT_Image/image-20230624082153740.png" alt="image-20230624082153740"></p><h3 id="mainscene-cpp"><a href="#mainscene-cpp" class="headerlink" title="mainscene.cpp"></a>mainscene.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainscene.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QIcon&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">MainScene::<span class="built_in">MainScene</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化场景</span></span><br><span class="line">    <span class="built_in">initScene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动游戏</span></span><br><span class="line">    <span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainScene::~<span class="built_in">MainScene</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::initScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置窗口固定尺寸</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(GAME_WIDTH,GAME_HEIGHT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(GAME_TITLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载图标</span></span><br><span class="line">    <span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(GAME_ICON));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器初始化</span></span><br><span class="line">    m_Timer.<span class="built_in">setInterval</span>(GAME_RATE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    m_Timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听监听器发送的信号</span></span><br><span class="line">    <span class="comment">//（哪个监听器，时间到了发送什么信号，用方法处理）</span></span><br><span class="line">    <span class="built_in">connect</span>(&amp;m_Timer,&amp;QTimer::timeout,[=]()&#123;</span><br><span class="line">        <span class="comment">//更新游戏中所有元素的坐标</span></span><br><span class="line">        <span class="built_in">updatePosition</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制到屏幕上</span></span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制地图</span></span><br><span class="line">    <span class="comment">//(x坐标，y坐标，QPixmap对象)</span></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,m_map.m_map1_posY,m_map.m_map1);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,m_map.m_map2_posY,m_map.m_map2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::updatePosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_map.<span class="built_in">mapPosition</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Clion-QT开发"><a href="#Clion-QT开发" class="headerlink" title="Clion QT开发"></a>Clion QT开发</h1><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>新建项目</p><p><img src="../assets/image/C++QT_Image/image-20230622185007059.png" alt="image-20230622185007059"></p><p>创建目录方便管理</p><p>右键项目目录新建qtui文件</p><p>将.ui文件放在Forms中</p><p>将.h文件放在Headers中</p><p>将.cpp文件放在Sources中</p><p><img src="../assets/image/C++QT_Image/image-20230622185031539.png" alt="image-20230622185031539"></p><p>在CMakeLists.txt中添加</p><p>该命令用于告诉 CMake 编译器在编译过程中要搜索头文件的路径</p><p><img src="../assets/image/C++QT_Image/image-20230622185231986.png" alt="image-20230622185231986"></p><p>改mainwindow.cpp文件包含的头文件地址</p><p>将#include “ui_MainWindow.h”改为</p><p>​    #include “Forms/ui_MainWindow.h”</p><p><img src="../assets/image/C++QT_Image/image-20230622185351011.png" alt="image-20230622185351011"></p><p>改main.cpp文件中的内容</p><p><img src="../assets/image/C++QT_Image/image-20230622185430456.png" alt="image-20230622185430456"></p><p>在设置中找到外部工具</p><p><img src="../assets/image/C++QT_Image/image-20230622185459076.png" alt="image-20230622185459076"></p><p>添加用于编写UI的designer.exe</p><p><img src="../assets/image/C++QT_Image/image-20230622185532722.png" alt="image-20230622185532722"></p><p>之后就可以在clion的右键菜单中直接使用</p><p><img src="../assets/image/C++QT_Image/image-20230622185602055.png" alt="image-20230622185602055"></p><h2 id="添加额外头文件"><a href="#添加额外头文件" class="headerlink" title="添加额外头文件"></a>添加额外头文件</h2><p>例如要添加Network相关的库</p><p>在CMakeLists.txt文件中</p><p>这两个地方添加Network的描述</p><p>然后在Clion中使用#include <QNetworkAccessManager>时不会报错并且有代码提示，但是运行还是会闪退</p><p><img src="../assets/image/C++QT_Image/image-20230622190238095.png" alt="image-20230622190238095"></p><p><img src="../assets/image/C++QT_Image/image-20230622190246224.png" alt="image-20230622190246224"></p><p>还需要将下面路径中的文件复制到cmake-build-debug文件夹下</p><p>D:\QT\6.2.4\mingw_64\bin\Qt6Network.dll</p><p><img src="../assets/image/C++QT_Image/image-20230622190424926.png" alt="image-20230622190424926"></p><h2 id="添加信号和槽"><a href="#添加信号和槽" class="headerlink" title="添加信号和槽"></a>添加信号和槽</h2><p>在mainwindow.h文件中</p><p>在类MainWindow中</p><p>添加以下代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_commitButton_clicked</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_cancelButton_clicked</span>()</span>;</span><br></pre></td></tr></table></figure><p>表示给commitButton组件添加clicked信号</p><p>表示给cancelButton组件添加clicked信号</p><p><img src="../assets/image/C++QT_Image/image-20230622191908562.png" alt="image-20230622191908562"></p><p>在文件mainwindow.cpp文件中进行实现</p><p><img src="../assets/image/C++QT_Image/image-20230622192226007.png" alt="image-20230622192226007"></p>]]></content>
    
    
    <summary type="html">🍔本文汇总QT编程的基础内容，和QTCreator的基本使用</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://momoao.github.io/tags/C/"/>
    
    <category term="QT" scheme="https://momoao.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://momoao.github.io/posts/202308241930.html"/>
    <id>https://momoao.github.io/posts/202308241930.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-25T12:42:33.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h1 id="零碎问题"><a href="#零碎问题" class="headerlink" title="零碎问题"></a>零碎问题</h1><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>在C++中，指针（Pointers）和引用（References）都是用于处理内存和变量的重要概念，但它们有一些重要的区别。让我来解释一下它们的区别：</p><ol><li><p>内存地址：</p><ul><li>指针：指针是一个变量，存储的是一个内存地址，指向某个变量或对象在内存中的位置。</li><li>引用：引用是某个变量或对象的别名，没有自己的内存地址。它与被引用的变量共享相同的内存地址。</li></ul></li><li><p>初始化：</p><ul><li>指针：指针在定义时需要显式地初始化为一个有效的内存地址，可以是nullptr（空指针）或者指向某个对象。</li><li>引用：引用在定义时必须初始化为一个已存在的变量或对象，且不能被重新赋值为引用其他变量。</li></ul></li><li><p>空值（null）：</p><ul><li>指针：指针可以是空指针（nullptr），即不指向任何有效的内存地址。</li><li>引用：引用必须始终引用某个已存在的变量或对象，不存在空引用的概念。</li></ul></li><li><p>重定向：</p><ul><li>指针：指针可以在运行时重新指向不同的变量或对象。</li><li>引用：一旦引用被初始化，它将一直引用同一个变量或对象，无法改变引用的目标。</li></ul></li><li><p>空间占用：</p><ul><li>指针：指针本身占据内存空间（通常是4个字节或8个字节，取决于系统）。</li><li>引用：引用在内存中不占据额外的空间，它只是被引用变量的别名。</li></ul></li><li><p>空间符号：</p><ul><li>指针：使用<code>*</code>来声明指针变量，并使用<code>*</code>来访问指针指向的对象（解引用）。</li><li>引用：使用<code>&amp;</code>来声明引用，但在使用时不需要加<code>&amp;</code>符号，直接使用引用即可。</li></ul></li></ol><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x; <span class="comment">// 指针ptr指向变量x</span></span><br><span class="line"><span class="type">int</span>&amp; ref = x;  <span class="comment">// 引用ref是变量x的别名</span></span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 修改指针ptr指向的变量的值（x变为20）</span></span><br><span class="line">ref = <span class="number">30</span>;  <span class="comment">// 修改引用ref所引用的变量的值（x变为30）</span></span><br></pre></td></tr></table></figure><p>总结：<br>指针和引用在C++中都是非常有用的工具，它们都用于处理变量和内存。选择使用指针还是引用取决于具体的情况和需求。通常情况下，如果你需要在运行时更改指向的对象，或者需要支持空值，使用指针是更好的选择。如果你只需要别名来简化代码并且不需要重新指向其他对象，使用引用可能更方便和安全。</p><h2 id="final和const区别"><a href="#final和const区别" class="headerlink" title="final和const区别"></a>final和const区别</h2><p><code>final</code>和<code>const</code>是两个不同的关键字，用于不同的目的和场景。它们之间的区别如下：</p><ol><li><p>用途和作用：</p><ul><li><code>final</code>关键字用于类、函数和继承关系，用于限制继承、函数重写和继承链的扩展性。</li><li><code>const</code>关键字用于声明常量、指示对象为只读，以及修饰函数参数和成员函数，用于控制数据的不可修改性。</li></ul></li><li><p>应用范围：</p><ul><li><code>final</code>关键字适用于类的声明、虚函数的声明和派生类的声明。</li><li><code>const</code>关键字适用于变量、函数参数、函数返回类型和成员函数。</li></ul></li><li><p>修改限制：</p><ul><li><code>final</code>关键字用于禁止类被继承、虚函数被重写和派生类的进一步派生。</li><li><code>const</code>关键字用于声明常量或指示对象为只读，不能修改被声明为<code>const</code>的对象。</li></ul></li><li><p>作用于对象：</p><ul><li><code>final</code>关键字作用于类和函数，用于限制其可继承性和重写性。</li><li><code>const</code>关键字作用于变量和函数，用于声明常量、指示只读性以及限制对被修饰对象的修改。</li></ul></li></ol><p>总的来说，<code>final</code>关键字用于限制继承和函数重写的扩展性，而<code>const</code>关键字用于声明常量和指示对象的只读性。它们在用途、应用范围和作用于对象上都有明显的差异。</p><h2 id="使用-和-gt-的区别"><a href="#使用-和-gt-的区别" class="headerlink" title="使用 .和-&gt;的区别"></a>使用 .和-&gt;的区别</h2><p>在C++中，使用<code>.</code>和<code>-&gt;</code>是用于访问指针所指向的对象的成员的两种方式。</p><ol><li><p>点操作符（.）：点操作符用于直接访问对象的成员，它只能用于对象本身，而不能用于指针。如果要使用点操作符，需要将指针解引用为对象。</p></li><li><p>箭头操作符（-&gt;）：箭头操作符用于通过指针间接访问对象的成员，它是指针特有的操作符。使用箭头操作符时，不需要将指针解引用为对象。</p></li></ol><p>下面是一个简单的示例代码，演示了<code>.</code>和<code>-&gt;</code>的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.value = <span class="number">42</span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>();      <span class="comment">// 使用点操作符直接访问对象成员，输出: Value: 42</span></span><br><span class="line"></span><br><span class="line">    MyClass* ptr = &amp;obj;</span><br><span class="line">    ptr-&gt;value = <span class="number">24</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">printValue</span>();     <span class="comment">// 使用箭头操作符通过指针间接访问对象成员，输出: Value: 24</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个<code>MyClass</code>类，其中包含一个整型成员变量<code>value</code>和一个成员函数<code>printValue()</code>。在<code>main()</code>函数中，我们创建了一个<code>MyClass</code>对象<code>obj</code>，并通过点操作符直接访问了对象的成员变量<code>value</code>和成员函数<code>printValue()</code>。</p><p>然后，我们创建了一个指向<code>obj</code>的指针<code>ptr</code>，并使用箭头操作符通过指针间接访问了对象的成员变量<code>value</code>和成员函数<code>printValue()</code>。注意，使用箭头操作符时，不需要解引用指针。</p><p>总结起来：</p><ul><li>使用<code>.</code>操作符用于直接访问对象的成员，需要对象本身而不是指针。</li><li>使用<code>-&gt;</code>操作符用于通过指针间接访问对象的成员，不需要解引用指针。</li></ul><h2 id="为什么说是万能头文件"><a href="#为什么说是万能头文件" class="headerlink" title="为什么说是万能头文件"></a>为什么说<bits/stdc++.h>是万能头文件</h2><p>在C++编程中，<code>&lt;bits/stdc++.h&gt;</code>是一个非标准头文件，它通常被用于竞赛编程和快速原型开发，被认为是”万能头文件”。这个头文件包含了大量常用的标准C++库的其他头文件，因此在使用它之后，就不需要为每个标准库引入单独的头文件了。</p><p>使用<code>&lt;bits/stdc++.h&gt;</code>头文件的好处是它简化了代码的编写，因为只需要包含一个头文件即可使用大部分标准库的功能，不需要考虑具体的头文件路径和引入顺序。这在竞赛编程中尤为方便，因为可以节省编写和调试代码所需的时间。</p><p>然而，需要注意的是，<code>&lt;bits/stdc++.h&gt;</code>不是标准C++的一部分，它只是某些编译器（如GCC和MinGW）的扩展。因此，在一些特定的开发环境中，可能无法使用这个头文件。此外，它包含了大量标准库的内容，可能会导致编译时间增加，因此在大型项目或需要精细控制的场景中，最好使用具体的标准库头文件，而不是依赖于<code>&lt;bits/stdc++.h&gt;</code>。</p><p>总而言之，尽管<code>&lt;bits/stdc++.h&gt;</code>头文件方便编写快速原型和竞赛代码，但在实际开发中，建议使用精确的标准库头文件来保证代码的可读性和可维护性。</p><h2 id="中常量和静态变量的区别"><a href="#中常量和静态变量的区别" class="headerlink" title="中常量和静态变量的区别"></a>中常量和静态变量的区别</h2><p>在C++中，常量和静态变量是两种不同的概念。</p><ol><li><p>常量（Constants）：</p><ul><li>常量是指在程序中声明的固定值，其值在整个程序执行期间不可改变。</li><li>常量可以使用<code>const</code>关键字声明，并且必须在声明时进行初始化。</li><li>常量的值在编译时确定，并且不能在程序运行时修改。</li><li>常量在内存中通常被视为字面值，并且可能会被编译器进行优化。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li><li><p>静态变量（Static Variables）：</p><ul><li>静态变量是指在函数内部或者类的成员变量中声明的变量，在程序执行期间保持其值不变。</li><li>静态变量在内存中只有一份拷贝，被所有对象或者函数所共享。</li><li>静态变量在函数内部时，只会在第一次执行函数时进行初始化，并且在函数调用结束后不会被销毁。</li><li>静态成员变量在类中时，可以通过类名和作用域解析运算符来访问。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  count++;</span><br><span class="line">  cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> instanceCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::instanceCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><p>总结：<br>常量是指在程序中声明的固定值，其值在整个程序执行期间不可改变。而静态变量是在函数或类中声明的变量，它们的值在程序执行期间保持不变。常量在声明时必须初始化，而静态变量可以在声明时初始化，也可以在需要的时候进行赋值。常量在内存中通常被视为字面值，而静态变量在内存中只有一份拷贝。</p><h2 id="为什么常量引用就可以赋普通数值"><a href="#为什么常量引用就可以赋普通数值" class="headerlink" title="为什么常量引用就可以赋普通数值"></a>为什么常量引用就可以赋普通数值</h2><p>在C++中，常量引用可以绑定到普通数值，是因为编译器会进行隐式类型转换。</p><p>当一个常量引用被初始化为一个普通数值时，编译器会自动进行类型转换，将普通数值转换为一个临时的匿名常量。这个匿名常量与原始的普通数值具有相同的值，但是它被视为一个常量，因此可以绑定到常量引用。</p><p>这种隐式类型转换在编译器层面进行，开发者不需要手动进行类型转换操作。这样的设计使得常量引用能够更灵活地与普通数值进行交互，同时保持了对常量的限制。</p><p>以下是一个示例，展示了常量引用绑定到普通数值的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(number);  <span class="comment">// 常量引用绑定到普通数值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>printValue</code>函数接受一个常量引用参数，然后打印该值。在<code>main</code>函数中，我们将一个普通数值<code>number</code>作为参数传递给<code>printValue</code>函数。编译器会进行隐式类型转换，将普通数值<code>number</code>转换为一个匿名常量，并将其绑定到函数中的常量引用参数。</p><p>需要注意的是，这种隐式类型转换只适用于常量引用，而不能直接应用于非常量引用。如果尝试将一个非常量引用绑定到普通数值，则会引发编译错误。</p><h2 id="c-版本"><a href="#c-版本" class="headerlink" title="c++版本"></a>c++版本</h2><p>C++98是C++语言的第一个标准化版本，于1998年发布。在C++98之后，还发布了几个C++标准版本，每个版本都引入了新的特性和语言改进。以下是C++98之后的一些重要版本及其主要特性：</p><ol><li><p>C++03（C++98修正版）：</p><ul><li>C++03于2003年发布，是对C++98标准的一些小修正和改进。</li><li>主要修正了一些语言和库的缺陷，提供了更好的兼容性和稳定性。</li></ul></li><li><p>C++11（C++0x）：</p><ul><li>C++11于2011年发布，是C++标准的重大更新。</li><li>引入了许多新的语言特性，如自动类型推导（auto关键字）、统一的初始化语法（初始化列表和花括号初始化）、lambda表达式、右值引用（移动语义）、智能指针、范围-based for循环等。</li><li>添加了一些标准库组件，如std::thread（多线程编程）、std::regex（正则表达式库）、std::chrono（时间和时钟库）等。</li><li>引入了异常规范的改进和新的关键字（例如noexcept和constexpr）。</li></ul></li><li><p>C++14：</p><ul><li>C++14于2014年发布，是对C++11的一些小改进和扩展。</li><li>改进了类型推导规则，简化了代码书写。</li><li>增加了二进制字面值、通用的lambda捕获初始化、返回类型推导、constexpr函数的放宽等新特性。</li><li>扩展了标准库，包括std::make_unique（智能指针的增强版）、std::user-defined literals（自定义字面值）等。</li></ul></li><li><p>C++17：</p><ul><li>C++17于2017年发布，引入了一些重要的新功能。</li><li>增加了结构化绑定（structured bindings）、if语句中的初始化、折叠表达式（fold expressions）等语言特性。</li><li>扩展了标准库，包括std::optional（可选值）、std::variant（变体类型）、std::any（类型安全的任意类型容器）等。</li></ul></li><li><p>C++20：</p><ul><li>C++20于2020年发布，是一个较大的标准更新。</li><li>引入了一些新的语言特性，如概念（Concepts）、协程（Coroutines）、三方运算符（Three-Way Comparison）等。</li><li>扩展了标准库，包括std::span（跨度类型）、std::ranges（范围库）、std::format（格式化字符串）等。</li></ul></li></ol><p>每个C++标准版本都带来了新的语言特性和库扩展，以提供更好的编程体验和更强大的功能。开发者可以根据目标平台和</p><h2 id="CMake是什么"><a href="#CMake是什么" class="headerlink" title="CMake是什么"></a>CMake是什么</h2><p>CMake是一个跨平台的开源构建工具，用于管理软件项目的构建过程。它可以生成适用于不同编译器和操作系统的构建配置文件（如Makefile、Visual Studio项目文件等），使得开发者能够在不同的平台上方便地构建和管理项目。</p><p>CMake的设计目标是提供一种简化和标准化的构建系统，使得开发者能够更容易地跨平台开发和构建软件。它使用一种声明式的方式来描述项目的构建过程，开发者可以编写CMakeLists.txt文件，其中包含了构建配置和规则。</p><p>CMake具有以下特点和功能：</p><ol><li><p>跨平台支持：CMake可以在各种操作系统上工作，包括Windows、macOS、Linux等，以及多种编译器和构建工具。</p></li><li><p>简化的语法：CMake使用一种简化的声明式语法，开发者可以通过编写CMakeLists.txt文件来描述项目的构建规则，包括源文件、编译选项、链接库等。</p></li><li><p>自动检测依赖：CMake能够自动检测项目所依赖的外部库和组件，并生成相应的构建配置，以确保构建过程中的依赖关系得到满足。</p></li><li><p>多种构建系统支持：CMake可以生成各种常见的构建系统配置文件，如Makefile、Ninja、Visual Studio项目文件等，使得开发者可以选择他们熟悉的构建工具进行项目构建。</p></li><li><p>嵌套项目支持：CMake支持管理和构建多个嵌套的子项目，使得大型项目可以被分解为多个模块，并方便地进行组织和构建。</p></li></ol><p>使用CMake，开发者可以根据自己的需求和目标平台，编写CMakeLists.txt文件来定义项目的构建过程。然后，通过运行CMake命令来生成适合于不同平台和编译器的构建配置文件，最后使用相应的构建工具进行项目构建。</p><p>总结起来，CMake是一个跨平台的开源构建工具，用于管理软件项目的构建过程。它提供了一种简化和标准化的构建系统，使得开发者能够更容易地跨平台开发和构建软件。</p><h2 id="头文件条件编译指令"><a href="#头文件条件编译指令" class="headerlink" title="头文件条件编译指令"></a>头文件条件编译指令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span></span><br><span class="line">什么意思</span><br></pre></td></tr></table></figure><p>这段代码是C++中的条件编译指令，用于在编译过程中控制头文件的包含。下面解释每一行的含义：</p><ol><li><p><code>#ifndef EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是条件编译指令的开始部分。<code>#ifndef</code>表示”if not defined”，即如果<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>未定义，执行后续操作。</p></li><li><p><code>#define EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是宏定义指令。它定义了一个名为<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>的宏，并将其设置为非零值。这个宏的作用是用于条件判断，后续可以根据这个宏是否被定义来执行不同的代码。</p></li><li><p><code>#endif //EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是条件编译指令的结束部分。<code>#endif</code>表示结束条件编译块，此处是与<code>#ifndef</code>对应的结束。<code>//EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>是一个注释，用于提供对<code>#ifndef</code>的标识说明。</p></li></ol><p>整个代码的作用是，当<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>宏未定义时，执行后续的代码，即将头文件的内容包含在条件编译块中。这样可以避免重复包含头文件，防止多重定义错误。</p><p>常见的做法是将这样的条件编译指令放在头文件的开头和结尾，以确保头文件只被编译一次。这样可以防止在多个源文件中包含同一个头文件时出现重复定义的问题。</p><h2 id="Clang-Tidy-Function-‘getId’-should-be-marked-nodiscard"><a href="#Clang-Tidy-Function-‘getId’-should-be-marked-nodiscard" class="headerlink" title="Clang-Tidy: Function ‘getId’ should be marked [[nodiscard]]"></a>Clang-Tidy: Function ‘getId’ should be marked [[nodiscard]]</h2><p>这个提示来自于Clang-Tidy，它建议在函数<code>getId</code>上添加<code>[[nodiscard]]</code>属性。</p><p><code>[[nodiscard]]</code>是C++17引入的一种属性，用于指示函数的返回值应该被使用，而不是被忽略。当函数被标记为<code>[[nodiscard]]</code>时，编译器会在函数返回值没有被使用时产生警告。</p><p>在你的情况下，Clang-Tidy建议在<code>getId</code>函数上添加<code>[[nodiscard]]</code>属性，这意味着调用该函数后应该使用其返回值。如果忽略了该返回值，编译器会发出警告，提醒开发者检查和处理函数的返回值。</p><p>为了解决这个警告，你可以按照建议在<code>getId</code>函数声明或定义的地方添加<code>[[nodiscard]]</code>属性，以明确表示该函数的返回值应该被使用。</p><p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; ... &#125;  <span class="comment">// 函数声明或定义处添加[[nodiscard]]属性</span></span><br></pre></td></tr></table></figure></p><p>通过遵循这个提示，可以提高代码的可读性和健壮性，防止因为未使用函数返回值而导致的潜在错误。</p><h2 id="Clang-Tidy是什么"><a href="#Clang-Tidy是什么" class="headerlink" title="Clang-Tidy是什么"></a>Clang-Tidy是什么</h2><p>Clang-Tidy是一个静态代码分析工具，用于检查和改进C++代码的质量。它是基于LLVM/Clang项目开发的，可以通过对C++代码进行静态分析和规则检查，提供有关代码潜在问题和改进建议的警告和建议。</p><p>Clang-Tidy使用Clang编译器的词法和语法分析功能，对代码进行静态分析，以识别潜在的错误、低效的代码、不规范的编码风格以及其他可能影响代码质量和性能的问题。它基于一组预定义的规则（检查器）执行静态代码分析，并生成相应的警告和建议。</p><p>Clang-Tidy的一些主要功能和特点包括：</p><ol><li><p>丰富的检查器集合：Clang-Tidy提供了多个内置的检查器，覆盖了各种代码问题，如潜在的错误、代码风格违规、性能问题等。每个检查器都有一个独立的规则集，可以根据需要启用或禁用。</p></li><li><p>可配置性：Clang-Tidy允许用户通过配置文件或命令行选项自定义检查器的行为。用户可以选择性地启用或禁用特定的检查器、调整警告级别，并提供自定义规则和扩展。</p></li><li><p>集成到构建系统：Clang-Tidy可以与常见的构建系统（如CMake和Make）集成，通过构建工具自动执行静态分析，并将警告和建议集成到编译过程中。</p></li><li><p>自动修复：在某些情况下，Clang-Tidy可以自动修复一些常见的代码问题，如修复不规范的代码风格或潜在的错误。这减少了手动修复的工作量，并提高了代码的一致性。</p></li></ol><p>通过使用Clang-Tidy，开发者可以更早地发现和纠正潜在的代码问题，改进代码质量和可维护性，并遵循良好的编码实践。它可以在开发过程中作为一种辅助工具，帮助开发者编写更高质量、更健壮的C++代码。</p><h2 id="C-中域是什么"><a href="#C-中域是什么" class="headerlink" title="C++中域是什么"></a>C++中域是什么</h2><p>在C++中，域（Scope）是指程序中定义和访问标识符（变量、函数、类等）的可见性和生命周期的范围。每个标识符都存在于特定的域中，并且只能在其所属的域中被访问和使用。</p><p>C++中有以下几种类型的域：</p><ol><li><p>全局域（Global Scope）：</p><ul><li>全局域是整个程序的最外层域，其中定义的标识符在整个程序中都可见。</li><li>全局域中定义的变量和函数可以在程序的任何地方使用。</li></ul></li><li><p>命名空间域（Namespace Scope）：</p><ul><li>命名空间是一种用于组织标识符的机制，在C++中可以通过<code>namespace</code>关键字定义。</li><li>在命名空间中定义的标识符只在该命名空间中可见，需要使用命名空间限定符才能访问。</li></ul></li><li><p>类域（Class Scope）：</p><ul><li>类域是指类中定义的成员变量和成员函数的可见范围。</li><li>在类中定义的成员变量和成员函数只能在类的成员函数中使用，可以通过成员访问操作符（<code>.</code>或<code>-&gt;</code>）来访问。</li></ul></li><li><p>局部域（Local Scope）：</p><ul><li>局部域是指在函数、代码块或循环结构中定义的标识符的可见范围。</li><li>在局部域中定义的变量只在其所属的代码块或函数内部可见，超出该范围后将不再可访问。</li></ul></li><li><p>语句域（Statement Scope）：</p><ul><li>语句域是指在语句中定义的标识符的可见范围。</li><li>在语句中定义的变量只在该语句中可见，超出该语句后将不再可访问。</li></ul></li></ol><p>每个域都有其特定的可见性和生命周期规则。标识符的可见性决定了它在程序的哪些位置可以被访问，而生命周期则指定了标识符在内存中存在的时间范围。理解和正确使用域是编写正确和可维护的C++程序的重要方面。</p><h2 id="常见编译器"><a href="#常见编译器" class="headerlink" title="常见编译器"></a>常见编译器</h2><p>C++有多个常用的编译器可用，包括但不限于以下几种：</p><ol><li><p>GCC（GNU Compiler Collection）：这是一个开源的编译器套件，包含了C++编译器（g++）。它是许多Linux发行版的默认编译器，并且可在其他操作系统上使用。</p></li><li><p>Clang：Clang是LLVM项目的一部分，是一个开源的编译器套件。它提供了高性能和高度可配置的C++编译器。Clang也可以作为一个可替代的编译器选择。</p></li><li><p>Microsoft Visual C++：这是Windows平台上的官方C++编译器。它是Microsoft Visual Studio集成开发环境的一部分，提供了丰富的工具和功能。</p></li><li><p>Intel C++ Compiler：这是Intel提供的针对英特尔体系结构的C++编译器。它专注于优化性能，并且在某些情况下可以生成更高效的代码。</p></li><li><p>Clang-CL：这是基于Clang的微软开发的一种编译器，兼容于Windows平台，支持Microsoft Visual Studio开发环境。</p></li></ol><p>以上是一些常用的C++编译器，每个编译器都有其特点和优势。选择编译器时，可以根据特定的需求、平台和个人偏好做出决策。</p><h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>MinGW（Minimalist GNU for Windows）是一个开源的软件开发工具包，旨在为Windows平台提供GNU工具集和开发环境。它基于GCC（GNU Compiler Collection）和binutils，并包括了一系列的工具，如C/C++编译器、链接器、调试器等。</p><p>MinGW的目标是在Windows上提供一个轻量级的开发环境，以便开发人员可以使用类Unix的工具和命令来编译、链接和调试他们的代码。它使用GNU工具链，因此能够提供广泛的开发功能和特性。</p><p>MinGW的主要优点之一是它允许开发人员在Windows上使用常见的Unix工具和库，而无需依赖于Windows特定的API和工具。这使得开发人员能够更容易地将他们的代码从Unix/Linux平台移植到Windows平台。</p><p>另一个重要的特点是MinGW提供了一个轻量级的替代品，相对于使用完整的Visual Studio开发环境，它可以更快地进行编译和构建。这使得MinGW成为一种流行的选择，特别是对于需要快速原型设计和小型项目开发的开发人员。</p><p>总而言之，MinGW是一个提供GNU工具集和开发环境的软件开发工具包，用于在Windows平台上进行C/C++开发。它为开发人员提供了一种在Windows上使用Unix工具和库的简便方式，以及更快的编译和构建速度。</p><h2 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h2><p>GNU是一个自由软件运动的项目，目标是为用户提供自由的计算机操作系统。GNU项目的全称是“GNU’s Not Unix”，这是一个递归缩写，意思是“GNU不是Unix”。它的目标是创建一个类Unix的操作系统，但不依赖于Unix的代码。</p><p>GNU项目始于1983年，由理查德·斯托曼（Richard Stallman）发起。斯托曼意识到许多计算机用户面临私有软件的限制，无法查看、修改和分享软件的源代码。为了解决这个问题，他发起了GNU项目，旨在开发一个完全自由的操作系统。</p><p>GNU项目包括了许多关键的组件，如GNU编译器集合（GCC）、GNU调试器（GDB）、GNU Bash shell、GNU核心工具集（Coreutils）等。这些组件形成了一个完整的自由软件堆栈，可用于构建自由操作系统。</p><p>然而，GNU项目中唯一尚未完成的部分是操作系统内核。为了填补这个空白，GNU项目与Linux内核相结合，形成了今天被广泛使用的GNU/Linux操作系统。GNU/Linux操作系统的基础是Linux内核，但它包含了许多GNU项目的组件，使得用户能够使用自由软件构建和定制他们的系统。</p><p>总而言之，GNU是一个自由软件运动的项目，旨在为用户提供自由的计算机操作系统。它的组件构成了一个完整的自由软件堆栈，并与Linux内核结合形成了GNU/Linux操作系统。GNU项目强调用户自由、开放源代码和共享，对于自由软件的发展和推广做出了重要贡献。</p><h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><p>OpenGL（Open Graphics Library）是一个用于渲染2D和3D图形的跨平台编程接口（API）。它是一个开放标准，由Khronos Group维护和推进。OpenGL提供了一系列的函数，用于操作图形硬件和执行图形计算，使开发人员能够创建高性能的图形应用程序。</p><p>OpenGL可以用于各种平台，包括Windows、macOS、Linux以及移动平台如Android和iOS。它与硬件无关，能够利用图形加速硬件（如图形处理器）来实现快速而逼真的图形渲染。</p><p>OpenGL提供了一系列功能和操作，包括几何图元绘制、纹理映射、光照、深度测试、着色器编程等。它使用一种状态机模型，通过设置不同的状态来定义绘图操作和渲染效果。开发人员可以使用OpenGL来创建各种类型的图形应用程序，包括游戏、可视化工具、模拟器、CAD软件等。</p><p>OpenGL的主要优点包括：</p><ol><li><p>跨平台：OpenGL可在多个平台上使用，使开发人员能够编写一次代码并在不同的系统上运行。</p></li><li><p>高性能：OpenGL能够利用硬件加速来实现高效的图形渲染，提供流畅的用户体验。</p></li><li><p>可扩展性：OpenGL支持扩展，开发人员可以利用额外的功能和特性来满足特定需求。</p></li><li><p>开放标准：OpenGL是一个开放的标准，各个硬件和软件供应商可以实现和支持它，确保了广泛的兼容性和可移植性。</p></li></ol><p>总而言之，OpenGL是一个跨平台的图形渲染API，用于创建高性能的2D和3D图形应用程序。它提供了丰富的功能和操作，可用于绘制几何图元、应用纹理、执行光照和着色器编程等。通过利用硬件加速，OpenGL能够实现快速而逼真的图形渲染，广泛应用于游戏开发、可视化工具、CAD软件等领域。</p><h2 id="Iceberg"><a href="#Iceberg" class="headerlink" title="Iceberg"></a>Iceberg</h2><p>在计算机科学中，”Iceberg”（冰山）技术通常指的是一种数据管理和查询优化技术，用于处理大规模数据集中的稀疏数据。</p><p>Iceberg技术的目标是提高处理大型数据集中稀疏数据的效率。在许多实际应用中，数据集中只有少部分数据是频繁访问的，而大部分数据则很少被使用。传统的数据存储和查询方法会对整个数据集进行处理，包括那些很少被使用的数据，从而浪费了计算资源和存储空间。</p><p>Iceberg技术通过将数据分成热数据（频繁访问的数据）和冷数据（很少访问的数据）两个部分来解决这个问题。热数据通常被保留在高性能的存储介质上，而冷数据则被移动到低成本的存储介质上，如分布式文件系统或对象存储。这样一来，只有热数据需要频繁访问，而冷数据可以以更低的成本存储和管理。</p><p>Iceberg技术还可以针对热数据应用各种优化技术，例如数据压缩、索引和分区，以提高查询性能。此外，它还提供了数据版本控制和事务支持，使得数据的更新和变更能够被有效地管理和追踪。</p><p>Iceberg技术在大数据处理领域得到了广泛应用，特别是在数据湖和数据仓库的构建和管理中。它提供了一种灵活而高效的方式来处理和查询大规模数据集，同时减少了存储成本和查询时间。</p><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>HDFS（Hadoop Distributed File System）是Apache Hadoop生态系统中的一项关键技术，它是一种用于存储和处理大规模数据集的分布式文件系统。</p><p>HDFS的设计目标是在大规模集群上提供高容错性、高吞吐量和可伸缩性的数据存储解决方案。它基于主从架构，其中包括一个主节点（NameNode）和多个从节点（DataNode）组成。HDFS将数据划分为固定大小的数据块，并将这些数据块存储在从节点上。主节点负责管理文件系统的元数据，如文件的名称、位置和权限等。</p><p>HDFS的主要特点包括：</p><ol><li><p>分布式存储：数据被分散存储在多个从节点上，可以横向扩展以适应大规模数据集的存储需求。</p></li><li><p>冗余备份：HDFS会将数据块复制到多个从节点上，以提供数据的冗余备份和容错性。通常，默认情况下，每个数据块会有三个副本存储在不同的从节点上。</p></li><li><p>高容错性：当从节点发生故障或数据损坏时，HDFS能够自动检测和恢复数据，确保数据的可靠性。</p></li><li><p>适合大数据处理：HDFS的设计使其适合处理大规模数据集的工作负载。它通过数据本地性和并行计算来提高数据处理的效率。</p></li></ol><p>HDFS被广泛应用于大数据处理和分析领域。它为许多分布式计算框架（如MapReduce）提供了数据存储和访问的基础，并支持对大规模数据集的高效处理和分析。</p><h2 id="Opencv"><a href="#Opencv" class="headerlink" title="Opencv"></a>Opencv</h2><p>OpenCV（Open Source Computer Vision）是一个开源的计算机视觉库，旨在提供一系列用于图像处理、计算机视觉和机器学习的函数和工具。它是一个广泛使用的库，可用于开发各种视觉应用程序，包括图像和视频处理、目标检测和跟踪、人脸识别、机器学习等。</p><p>OpenCV最初由英特尔公司于1999年发起，后来成为一个跨平台的开源项目。它使用C++语言编写，但也提供了许多其他编程语言的接口，包括Python、Java和MATLAB等，使得开发人员可以方便地在不同的环境中使用OpenCV。</p><p>OpenCV提供了大量的函数和算法，用于处理图像和视频数据。它支持基本的图像操作（如裁剪、调整大小、滤波等）、特征提取和描述（如边缘检测、角点检测、直线检测等）、图像匹配和配准、运动估计、三维重建等。此外，OpenCV还包含了许多机器学习算法的实现，如支持向量机（SVM）、随机森林（Random Forests）、神经网络等，用于目标分类和识别。</p><p>OpenCV被广泛应用于计算机视觉领域的研究和开发中，它在学术界和工业界都有很高的声誉和应用价值。无论是进行基础的图像处理还是复杂的计算机视觉任务，OpenCV都提供了丰富的功能和工具，使得开发者能够快速实现他们的视觉应用。</p><h2 id="命名空间在项目开发中的作用"><a href="#命名空间在项目开发中的作用" class="headerlink" title="命名空间在项目开发中的作用"></a>命名空间在项目开发中的作用</h2><p>在项目开发中，命名空间具有以下几个重要的作用：</p><ol><li><p>避免命名冲突：命名空间可以将代码标识符（变量、函数、类等）分组和隔离，避免不同部分的代码之间的命名冲突。不同的命名空间中可以使用相同名称的标识符，因为它们的作用域被限定在各自的命名空间内。</p></li><li><p>提供代码组织和模块化：通过将相关的代码放置在同一个命名空间中，可以提供逻辑上的分组和组织，使得代码结构更加清晰和可维护。命名空间可以按照功能、模块或层次结构进行组织，使得开发人员能够更容易地理解和维护代码。</p></li><li><p>增加可读性和可扩展性：通过在代码中使用命名空间，可以提高代码的可读性和可理解性。命名空间可以为代码添加上下文和语义，使得代码的意图更加清晰。此外，命名空间也为项目的扩展性提供了支持，因为新的代码可以添加到现有的命名空间中，而无需修改或重构现有代码。</p></li><li><p>允许使用相同名称的标识符：不同的命名空间中可以使用相同名称的标识符，而不会发生冲突。这对于与第三方库或其他模块集成时特别有用，可以避免不同模块之间的名称冲突，并支持更好的代码重用和组合。</p></li><li><p>限定标识符的作用域：命名空间通过命名空间限定符（<code>::</code>）来限定标识符的作用域。这可以使得代码更加明确和可控，避免全局作用域的滥用。只有在需要使用特定命名空间中的标识符时，才需要显式地引用它们，提高了代码的可维护性和可读性。</p></li></ol><p>总的来说，命名空间在项目开发中起到了隔离、组织和管理代码的作用。它们提供了一种结构化的方式来处理命名冲突，并提高了代码的可读性、可维护性和可扩展性。通过合理地使用命名空间，可以更好地组织项目代码，减少潜在的问题，并提高团队协作的效率。</p><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>在C++中，<code>explicit</code>是一个关键字，用于修饰类的单参数构造函数（或除默认参数外的多参数构造函数）。使用<code>explicit</code>关键字可以防止隐式的类型转换发生。</p><p>通常情况下，当我们定义一个只有一个参数的构造函数时，编译器会自动将该构造函数用于隐式类型转换。这意味着，当我们使用该类的对象进行赋值、初始化或作为函数参数时，编译器会自动进行类型转换。</p><p>下面是一个示例，展示了没有使用<code>explicit</code>关键字时，构造函数的隐式类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with MyClass object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">5</span>;   <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="built_in">doSomething</span>(<span class="number">10</span>);   <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code>类定义了一个单参数构造函数，该构造函数接受一个<code>int</code>类型的参数。在<code>main()</code>函数中，我们使用整数值进行赋值和函数调用，编译器会自动进行隐式类型转换来创建<code>MyClass</code>对象。</p><p>然而，有时候我们希望明确地控制类型转换，避免出现意外的转换行为。这时就可以使用<code>explicit</code>关键字来声明构造函数，并禁止隐式类型转换。</p><p>下面是使用<code>explicit</code>关键字修饰构造函数的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> : m_value(value) &#123;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with MyClass object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">5</span>;    <span class="comment">// 错误，禁止隐式类型转换</span></span><br><span class="line">    <span class="built_in">doSomething</span>(<span class="number">10</span>);    <span class="comment">// 错误，禁止隐式类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们在构造函数前面加上了<code>explicit</code>关键字。这意味着构造函数只能被显式调用，而禁止了隐式类型转换。在<code>main()</code>函数中的赋值和函数调用将会导致编译错误。</p><p>通过使用<code>explicit</code>关键字，我们可以更加明确地控制对象的创建和类型转换，避免一些潜在的错误和意外行为。但需要注意，使用<code>explicit</code>关键字可能会导致一些代码的冗长性和不便利性，需要根据实际需求和设计考虑是否使用。</p><h2 id="构造函数的-后面加上-是什么意思"><a href="#构造函数的-后面加上-是什么意思" class="headerlink" title="构造函数的()后面加上;是什么意思"></a>构造函数的()后面加上;是什么意思</h2><p>在C++中，构造函数的()后面加上;是表示一个成员初始化列表（member initializer list）的开始。</p><p>构造函数在创建对象时被调用，用于初始化对象的成员变量。成员初始化列表提供了一种在构造函数体之前初始化成员变量的方式。通过在构造函数的定义中使用成员初始化列表，可以直接为成员变量赋值或调用它们的构造函数。</p><p>下面是一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述示例中，构造函数的定义是 <code>MyClass(int value) : m_value(value) &#123;&#125;</code>。在<code>:</code>之后是成员初始化列表，其中的<code>m_value(value)</code>表示将参数<code>value</code>的值赋给成员变量<code>m_value</code>。这样，在构造函数体之前，成员变量<code>m_value</code>就已经被初始化。</p><p>通过使用成员初始化列表，可以在构造函数体之前对成员变量进行初始化，避免在构造函数体中进行赋值操作，提高代码的效率和可读性。此外，对于一些类类型的成员变量，成员初始化列表还可以调用它们的构造函数进行初始化。</p><p>需要注意的是，成员初始化列表只能用于构造函数中，用于初始化成员变量，不能用于其他成员函数。并且，成员初始化列表的顺序应该与成员变量在类中声明的顺序一致，以避免出现潜在的问题。</p><p>总结起来，构造函数的()后面加上;表示一个成员初始化列表的开始。成员初始化列表用于在构造函数体之前对成员变量进行初始化，提供了一种效率高且可读性好的初始化方式。通过成员初始化列表，可以直接为成员变量赋值或调用它们的构造函数。</p><h2 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h2><p>C++的NDK（Native Development Kit）是一组工具和库，用于开发使用C++编写的Android应用程序。NDK允许开发人员在Android平台上编写高性能的原生代码，通常用于处理计算密集型任务、访问系统硬件和优化性能。</p><p>以下是关于C++的NDK的一些关键概念和使用方法：</p><ol><li><p>NDK的目的：NDK的主要目的是提供一种在Android应用程序中使用C++编写的原生代码的方法。使用C++可以在性能上优化应用程序，处理复杂的计算任务，访问系统级别的API和设备功能，或重用现有的C/C++库。</p></li><li><p>NDK工具链：NDK提供了一套工具链，包括交叉编译器、调试器和构建工具。这些工具链允许将C++代码编译为适用于Android平台的本机机器码。</p></li><li><p>CMake构建系统：NDK推荐使用CMake作为构建系统，用于生成Android应用程序的本机代码。CMake是一个跨平台的构建工具，它可以帮助您定义构建过程和依赖关系，并生成适用于Android的Makefile。</p></li><li><p>JNI接口：在使用NDK开发时，C++代码与Java代码之间的交互通过JNI（Java Native Interface）实现。JNI允许在Java和C++之间进行函数调用和数据传递。</p></li><li><p>支持的ABI：ABI（Application Binary Interface）是指应用程序和操作系统之间的二进制接口规范。NDK支持多个ABI，包括armeabi、armeabi-v7a、arm64-v8a、x86和x86_64。开发人员可以选择适合其应用程序的ABI，以实现最佳的性能和兼容性。</p></li><li><p>使用第三方库：NDK还允许开发人员使用现有的C/C++库，如OpenCV、Boost等。通过在NDK构建脚本中配置和链接这些库，可以轻松地将它们与Android应用程序集成在一起。</p></li><li><p>调试和性能分析：NDK提供了调试工具和性能分析工具，以帮助开发人员调试和优化其原生代码。例如，可以使用ndk-gdb命令行工具进行调试，使用perf工具进行性能分析。</p></li></ol><p>请注意，使用NDK编写原生代码需要一定的C++编程知识和Android开发经验。它主要适用于需要高性能计算、底层硬件访问或与现有C/C++库集成的情况。对于一般的Android应用程序开发，通常建议优先考虑使用Java或Kotlin编写代码。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083744623.png" alt="image-20230613083744623"></p><h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083845493.png" alt="image-20230613083845493"></p><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083858532.png" alt="image-20230613083858532"></p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083909897.png" alt="image-20230613083909897"></p><h2 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083920385.png" alt="image-20230613083920385"></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> studentId, <span class="type">const</span> std::string&amp; studentName, <span class="type">int</span> studentAge) &#123;</span><br><span class="line">        id = studentId;</span><br><span class="line">        name = studentName;</span><br><span class="line">        age = studentAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Student ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取学生姓名</span></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置学生姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; studentName)</span> </span>&#123;</span><br><span class="line">        name = studentName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>在C++中，关键字<code>this</code>表示当前对象的指针。它是一个隐式的指针，指向调用成员函数的对象本身。通过<code>this</code>指针，可以在类的成员函数中访问和操作当前对象的成员变量和成员函数。</p><p>以下是一个简单的示例代码，演示了<code>this</code>关键字的用途：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_value = value;  <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Address: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;  <span class="comment">// 打印this指针的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>();     <span class="comment">// 输出: Value: 42</span></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">24</span>);     <span class="comment">// 使用成员函数设置新的值</span></span><br><span class="line">    obj.<span class="built_in">printValue</span>();     <span class="comment">// 输出: Value: 24</span></span><br><span class="line">    obj.<span class="built_in">printAddress</span>();   <span class="comment">// 打印对象的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>MyClass</code>类包含一个整型成员变量<code>m_value</code>和几个成员函数。在<code>setValue()</code>函数中，使用<code>this</code>指针访问并修改了当前对象的成员变量<code>m_value</code>。<code>printAddress()</code>函数使用<code>this</code>指针打印了当前对象的地址。</p><p>在<code>main()</code>函数中，我们创建了一个<code>MyClass</code>对象<code>obj</code>并调用了一系列成员函数。通过使用<code>this</code>指针，我们可以在成员函数中访问和操作对象的成员变量，确保了对当前对象的正确引用。</p><p>需要注意的是，<code>this</code>指针在成员函数内部是一个自动提供的指针，无需显式声明或初始化。它是一个常量指针，不允许修改它指向的对象。</p><p>总结起来，<code>this</code>关键字在C++中表示当前对象的指针，用于在类的成员函数中访问和操作当前对象的成员变量和成员函数。通过使用<code>this</code>指针，可以确保正确引用当前对象，并进行对象内部的操作和交互。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在C++中，继承是一种面向对象编程的重要概念，它允许你创建一个新类（称为子类或派生类），该类继承了另一个类（称为基类或父类）的属性和行为。子类可以继承基类的成员变量和成员函数，并且可以扩展或修改它们。以下是关于继承的一些要点：</p><ol><li><p>基类和派生类：</p><ul><li>基类是已经存在的类，它提供了一组通用的属性和行为。</li><li>派生类是从基类派生而来的新类，它继承了基类的属性和行为，并且可以添加自己的属性和行为。</li></ul></li><li><p>语法：</p><ul><li>在C++中，使用冒号 <code>:</code> 来指定派生类继承基类。例如：<code>class Derived : public Base</code> 表示派生类 <code>Derived</code> 继承了基类 <code>Base</code>。</li><li>继承关系可以是公有（public）、私有（private）或保护（protected）。公有继承意味着基类的公有成员在派生类中仍然是公有的，私有继承和保护继承会有相应的访问限制。</li></ul></li><li><p>继承类型：</p><ul><li>公有继承（public inheritance）：派生类继承了基类的公有成员和保护成员，但私有成员不可直接访问。</li><li>私有继承（private inheritance）：派生类继承了基类的所有成员，但它们都变成了私有成员，只能在派生类内部访问。</li><li>保护继承（protected inheritance）：派生类继承了基类的保护成员和公有成员，但它们都变成了保护成员，只能在派生类内部和派生类的子类中访问。</li></ul></li><li><p>成员访问权限：</p><ul><li>派生类可以访问基类的公有和保护成员，但不能直接访问基类的私有成员。</li><li>派生类可以通过成员函数和友元函数来访问基类的私有成员。</li><li>在派生类中，可以使用作用域解析运算符 <code>::</code> 来引用基类的成员。</li></ul></li><li><p>重写和扩展：</p><ul><li>派生类可以重写（override）基类的成员函数，即在派生类中重新实现基类中已有的函数。这允许派生类提供自己的实现。</li><li>派生类还可以添加新的成员函数和数据成员，从而扩展基类的功能。</li></ul></li></ol><p>以下是一个简单的示例，演示了继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; <span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">Shape</span>(w, h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">Shape</span>(w, h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="继承和访问关系"><a href="#继承和访问关系" class="headerlink" title="继承和访问关系"></a>继承和访问关系</h2><div class="table-container"><table><thead><tr><th></th><th>基类的公有成员</th><th>基类的保护成员</th><th>基类的私有成员</th></tr></thead><tbody><tr><td>公有继承</td><td>可访问</td><td>可访问</td><td>不可访问</td></tr><tr><td>保护继承</td><td>保护</td><td>保护</td><td>不可访问</td></tr><tr><td>私有继承</td><td>私有</td><td>私有</td><td>不可访问</td></tr></tbody></table></div><h2 id="派生类访问基类私有成员"><a href="#派生类访问基类私有成员" class="headerlink" title="派生类访问基类私有成员"></a>派生类访问基类私有成员</h2><p>在C++中，派生类是基类的扩展，可以继承基类的成员（公有、受保护和私有）。私有成员是基类中具有最高访问权限的成员，只能在基类的成员函数和友元函数中直接访问。然而，派生类可以通过以下两种方式访问基类的私有成员：</p><ol><li><p>成员函数：</p><ul><li>派生类可以通过继承基类的公有和受保护成员函数，间接地访问基类的私有成员。</li><li>由于派生类继承了基类的成员函数，这些成员函数在派生类中仍然可以访问基类的私有成员。</li></ul></li><li><p>友元函数：</p><ul><li>如果基类将派生类声明为友元类，那么派生类的成员函数和友元函数可以直接访问基类的私有成员。</li><li>友元函数是在类外部声明的函数，可以访问该类的私有成员，因此通过将派生类声明为基类的友元类，可以使派生类的成员函数和友元函数访问基类的私有成员。</li></ul></li></ol><p>通过这两种方式，派生类可以在某种程度上访问基类的私有成员，但需要注意的是，派生类应该尽量遵循封装原则，尽量不直接访问基类的私有成员，以保持类的封装性和数据的安全性。</p><p>以下是一个示例，演示了派生类通过成员函数和友元函数访问基类的私有成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Derived</span>;  <span class="comment">// 将Derived声明为Base的友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessBasePrivateMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> val = privateVar;  <span class="comment">// 可以访问基类的私有成员</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&#x27;s privateVar through Derived: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    derived.<span class="built_in">accessBasePrivateMember</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>Base</code> 类具有一个私有成员变量 <code>privateVar</code>，而 <code>Derived</code> 类通过公有继承继承了 <code>Base</code> 类，并且将 <code>Derived</code> 声明为 <code>Base</code> 的友元类。因此，<code>Derived</code> 类的成员函数 <code>accessBasePrivateMember()</code> 可以直接访问基类 <code>Base</code> 的私有成员变量 <code>privateVar</code>。</p><p>需要注意的是，友元关系是单向的，即在上面的示例中，<code>Derived</code> 类可以访问 <code>Base</code> 类的私有成员，但 <code>Base</code> 类不能访问 <code>Derived</code> 类的私有成员。友元关系应该谨慎使用，以确保访问权限的正确性和安全性。</p><h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>在C++中，<code>override</code> 关键字用于显式地标识派生类中的成员函数，表示该函数是对基类中的虚函数进行重写。<code>override</code> 关键字有助于提高代码的可读性，并在编译时进行检查，以确保正确地重写了基类的虚函数。</p><p>使用 <code>override</code> 的一般语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">Derived::function_name</span><span class="params">(parameters)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在派生类中重写基类的虚函数时，使用 <code>override</code> 关键字将其放置在函数声明的末尾。编译器会验证该函数是否正确地重写了基类的虚函数，如果未找到匹配的基类虚函数，或者函数签名不匹配，则会产生编译错误。</p><p>下面是一个示例，演示了如何使用 <code>override</code> 关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is the base class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is the derived class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    basePtr-&gt;<span class="built_in">printMessage</span>();  <span class="comment">// 输出: &quot;This is the derived class.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>Base</code> 类定义了一个虚函数 <code>printMessage()</code>，而 <code>Derived</code> 类通过公有继承重写了该函数。在 <code>Derived</code> 类中，使用 <code>override</code> 关键字标识了对基类函数的重写。</p><p>在 <code>main()</code> 函数中，我们创建了一个指向 <code>Derived</code> 类对象的基类指针 <code>basePtr</code>，并调用了 <code>printMessage()</code> 函数。由于基类指针指向派生类对象，因此调用的是派生类中重写的函数。输出结果为 “This is the derived class.”。</p><p>通过使用 <code>override</code> 关键字，可以确保在派生类中正确地重写了基类的虚函数，以实现多态行为。如果派生类中的函数签名与基类虚函数不匹配，编译器将发出错误提示，帮助我们检测潜在的错误。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数是在基类中声明为虚函数的成员函数，用于实现多态性（polymorphism）。多态性是面向对象编程的一个重要特性，它允许通过基类的指针或引用来调用派生类的特定实现。</p><p>虚函数的作用包括：</p><ol><li><p>实现运行时多态：通过基类的指针或引用调用虚函数时，根据实际对象的类型确定要调用的函数版本。这样可以在运行时确定调用哪个派生类的函数实现，实现了多态性。</p></li><li><p>提供接口的扩展性：通过在基类中声明虚函数，可以让派生类根据需要进行函数的重写，从而实现接口的扩展。这样，基类的指针或引用可以灵活地调用不同派生类的不同实现。</p></li></ol><p>要将函数声明为虚函数，需要在基类中使用 <code>virtual</code> 关键字进行声明。派生类中重写虚函数时，可以使用 <code>override</code> 关键字显式标识。</p><p>以下是一个示例，演示了虚函数的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: &quot;Drawing a circle.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>Shape</code> 类是一个基类，其中的 <code>draw()</code> 函数被声明为虚函数。<code>Circle</code> 和 <code>Rectangle</code> 类分别是 <code>Shape</code> 类的派生类，并在派生类中重写了 <code>draw()</code> 函数。</p><p>在 <code>main()</code> 函数中，我们创建了一个基类指针 <code>shapePtr</code>，并将其指向 <code>Circle</code> 类的对象。通过该指针调用 <code>draw()</code> 函数时，由于函数是虚函数，程序在运行时确定要调用的函数版本，因此调用的是 <code>Circle</code> 类中重写的函数。输出结果为 “Drawing a circle.”。</p><p>通过使用虚函数，我们可以根据实际对象的类型来动态选择要调用的函数版本，实现了多态性和接口的扩展性。这是面向对象编程中的重要概念，有助于编写灵活、可扩展的代码。</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>在C++中，<code>const</code>是一个关键字，用于声明常量或指示对象为只读。<code>const</code>关键字可以应用于变量、函数参数、函数返回类型和成员函数。</p><p>以下是<code>const</code>关键字的使用方法和注意事项：</p><ol><li>声明常量：<code>const</code>关键字可以用于声明常量，即数值在程序执行期间不可修改的值。常量在声明时必须进行初始化，并且在后续的代码中不能被修改。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><ol><li>声明只读变量：将<code>const</code>关键字应用于变量时，表示该变量的值不可被修改。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* constPtr = &amp;x;  <span class="comment">// 指向常量的指针，不可通过指针修改变量的值</span></span><br><span class="line"><span class="comment">// *constPtr = 10;  // 错误，不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">10</span>;  <span class="comment">// 声明只读变量，不可修改</span></span><br><span class="line"><span class="comment">// y = 20;  // 错误，不可修改</span></span><br></pre></td></tr></table></figure><ol><li>函数参数：将参数声明为<code>const</code>可以确保在函数内部不会修改参数的值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value = 10;  // 错误，不可修改</span></span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>函数返回类型：将函数返回类型声明为<code>const</code>表示返回的对象是只读的，不可在调用端进行修改。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">getValue</span>();</span><br><span class="line"><span class="comment">// getValue() = 10;  // 错误，不可修改返回值</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>声明为<code>const</code>的变量必须在声明时进行初始化，并且不能在后续的代码中修改。</li><li>声明为<code>const</code>的对象只能调用其成员函数中被声明为<code>const</code>的函数。</li><li><code>const</code>修饰符在指针类型中具有两个作用：<code>const int*</code>表示指向常量的指针，<code>int* const</code>表示常量指针（指针本身是常量）。</li><li>当将<code>const</code>修饰符应用于类的成员函数时，表示该函数不会修改类的成员变量。</li></ul><p>使用<code>const</code>关键字可以增加代码的可读性和安全性，防止不必要的变量修改和意外的副作用。合理使用<code>const</code>可以帮助编译器进行优化，并提供更好的代码维护性。同时，需要注意在使用<code>const</code>修饰时，确保遵守<code>const</code>修饰符的规则，避免出现编译错误。</p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p><code>final</code>是C++11引入的关键字，用于限制类、函数和继承关系的扩展性。以下是<code>final</code>关键字的使用方法和一些注意事项：</p><ol><li>类的<code>final</code>修饰：将<code>final</code>关键字放在类声明的末尾，表示该类不能被继承。这样可以防止其他类从该类派生，并覆盖或扩展其功能。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  <span class="comment">// 错误，无法从final类Derived继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>函数的<code>final</code>修饰：将<code>final</code>关键字放在虚函数声明的末尾，表示该虚函数不能在派生类中被重写。这样可以确保派生类无法修改基类的特定行为。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 错误，无法重写被声明为final的虚函数foo()</span></span><br><span class="line">    <span class="comment">// void foo() override &#123;</span></span><br><span class="line">    <span class="comment">//     // ...</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>继承关系中的<code>final</code>修饰：将<code>final</code>关键字放在派生类声明的末尾，表示该派生类不能有后续的派生类。这样可以在继承链上指定最后一个派生类，防止进一步的扩展。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> <span class="keyword">final</span> : <span class="keyword">public</span> Derived1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived3</span> : <span class="keyword">public</span> Derived2 &#123;  <span class="comment">// 错误，无法从final类Derived2继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>final</code>关键字的注意事项：</p><ul><li><code>final</code>关键字用于限制扩展性，应谨慎使用。在设计类和继承关系时，应仔细考虑是否真正需要限制继承和函数重写。</li><li>使用<code>final</code>关键字可以增强类的安全性和稳定性，特别是用于基类或核心函数，以防止它们被修改。</li><li>避免滥用<code>final</code>关键字，过多地使用可能导致继承层次结构变得过于僵硬和不灵活。</li><li>在继承关系中，使用<code>final</code>关键字可以明确地指定最后一个派生类，以确保继承链的终结。</li><li><code>final</code>关键字适用于类、虚函数和继承关系，但不适用于非虚普通函数。</li><li>在使用<code>final</code>关键字时，应保持代码清晰，以便其他开发人员能够理解和维护代码。</li></ul><p>总的来说，<code>final</code>关键字提供了一种在类、函数和继承关系中限制扩展性的</p><p>机制。适当地使用<code>final</code>可以增强代码的安全性和稳定性，但需要注意不要滥用它，以免造成代码的僵化和不灵活。</p><h1 id="指针和引用的区别-1"><a href="#指针和引用的区别-1" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><p>指针和引用是C++中用于处理内存和对象的重要概念，它们有以下区别：</p><ol><li><p>指针可以被重新赋值，而引用一旦绑定到对象，就不能更改绑定的对象。</p></li><li><p>指针可以是空值（nullptr），即指向空地址，而引用必须在声明时绑定到一个对象。</p></li><li><p>指针可以指向多个不同的对象，而引用只能绑定到一个对象，并且不能更改为引用其他对象。</p></li><li><p>指针可以进行指针运算（如指针加法、指针减法等），而引用没有指针运算。</p></li><li><p>指针可以被重新分配内存，而引用不能。</p></li><li><p>引用通常用作函数的参数或返回类型，以实现传递参数或返回值的效果。指针也可以用于相同的目的，但引用通常更直观和安全。</p></li></ol><p>下面是一些示例代码来说明指针和引用之间的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyPointer</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;  <span class="comment">// 修改指针所指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyReference</span><span class="params">(<span class="type">int</span>&amp; ref)</span> </span>&#123;</span><br><span class="line">    ref = <span class="number">200</span>;  <span class="comment">// 修改引用所绑定的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;num;  <span class="comment">// 指针指向num</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = num;  <span class="comment">// 引用绑定到num</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">modifyPointer</span>(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value after modifying pointer: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">// 输出: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">modifyReference</span>(ref);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value after modifying reference: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">// 输出: 200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个整数变量 <code>num</code>，并创建了一个指向该变量的指针 <code>ptr</code> 和一个引用 <code>ref</code>。然后，我们编写了两个函数 <code>modifyPointer()</code> 和 <code>modifyReference()</code>，分别用于修改指针和引用所指向的值。</p><p>在 <code>main()</code> 函数中，我们首先通过指针调用 <code>modifyPointer()</code> 函数来修改指针所指向的值，并输出修改后的值。然后，通过引用调用 <code>modifyReference()</code> 函数来修改引用所绑定的值，并再次输出修改后的值。在两次输出中，我们可以看到变量 <code>num</code> 的值被成功修改。</p><p>通过比较指针和引用的使用方式和功能，可以选择适合特定情况的方法。指针提供了更大的灵活性，可以用于动态分配内存和处理数据结构，而引用提供了更简洁的语法和更安全的操作，常用于函数参数传递和返回值。</p><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><p>在C++中，宏定义（Macro Definition）是一种预处理指令，用于在编译之前将代码中的标识符替换为指定的文本。它们是通过预处理器（Preprocessor）在编译阶段执行的，而不是在运行时。</p><p>宏定义使用<code>#define</code>指令来创建，语法形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名称 替换文本</span></span><br></pre></td></tr></table></figure><p>其中，宏名称是你自定义的标识符，替换文本是要替换成的代码片段或值。宏名称通常使用大写字母命名，以便与其他标识符区分开来。</p><p>宏定义可以用于替换任意代码片段，包括表达式、语句、函数调用等。例如，下面是一个简单的宏定义示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    <span class="type">double</span> area = PI * radius * radius;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，宏定义<code>#define PI 3.14159</code>将标识符<code>PI</code>替换为值<code>3.14159</code>。在<code>main()</code>函数中，我们使用<code>PI</code>宏来计算圆的面积。</p><p>宏定义还可以带有参数，称为宏函数（Macro Function）。宏函数的语法与函数类似，可以接受参数并在替换文本中使用它们。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">SQUARE</span>(<span class="number">5</span>);   <span class="comment">// 展开为 ((5) * (5))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，宏函数<code>#define SQUARE(x) ((x) * (x))</code>将传入的参数<code>x</code>平方并返回结果。</p><p>需要注意的是，宏定义是简单的文本替换，没有类型检查和作用域限制。它们在预处理阶段直接替换代码，可能导致一些意想不到的行为。因此，在使用宏定义时需要谨慎，避免引入不可预测的问题。</p><p>此外，C++中还有一些预定义的宏，如<code>__FILE__</code>（当前源文件名）、<code>__LINE__</code>（当前行号）和<code>__cplusplus</code>（用于检查C++编译环境）等。这些预定义的宏在不同的编译器中可能有所差异，可以根据需要使用它们来获取一些编译时的信息。</p><p>总结起来，宏定义是C++中的预处理指令，用于在编译之前将标识符替换为指定的文本。它们可以用于定义常量、简单的代码替换和宏函数等。但需要注意宏定义的潜在问题，如缺乏类型检查和作用域限制。在实际使用中，应该慎重考虑宏</p><h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>在C++中，友元（friend）是一种机制，允许某个类或函数访问其他类的私有成员。友元关系可以用于增强类之间的协作和封装性。当一个类将另一个类声明为友元时，被声明的类就可以访问该类的私有成员。</p><p>友元关系有两种形式：类友元和函数友元。</p><ol><li>类友元：<br>类友元允许另一个类访问当前类的私有成员。在类定义中声明另一个类为友元时，友元类可以访问当前类的私有和保护成员。这种关系是双向的。</li></ol><p>下面是一个示例代码，演示了类友元的应用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 前置声明类B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">privateData</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 类B是类A的友元</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Private data in class A: &quot;</span> &lt;&lt; privateData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyPrivateData</span><span class="params">(A&amp; obj, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        obj.privateData = data;  <span class="comment">// 可以访问类A的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，类A将类B声明为友元。类B的成员函数<code>modifyPrivateData()</code>可以访问类A的私有成员<code>privateData</code>。这允许类B修改类A的私有数据。</p><ol><li><p>函数友元：<br>函数友元允许一个独立的函数访问某个类的私有成员。函数友元不属于任何类，但可以访问被声明为友元的类的私有和保护成员。</p><p><strong>这个函数的声明需要在类中，并在声明前加上friend关键字，定义可以在类中或类外，因为友元函数不属于类的成员函数，所以在调用友元函数时不需要声明作用域</strong></p></li></ol><p>下面是一个示例代码，演示了函数友元的应用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">privateData</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">(A&amp; obj)</span></span>;  <span class="comment">// displayPrivateData函数是类A的友元</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Private data in class A: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，函数<code>displayPrivateData()</code>被声明为类A的友元。该函数可以直接访问类A的私有成员<code>privateData</code>。</p><p>友元关系的应用方式可以有多种，例如：</p><ul><li>可以将其他类声明为友元，以便它们可以访问私有成员，从而实现类之间的数据共享或协作。</li><li>可以声明一些独立函数作为友元，以便它们可以直接访问类的私有成员，提供额外的功能或实现特定的操作。</li></ul><p>请注意，友元关系会破坏封装性，因此应谨慎使用。只有在确实需要访问私有成员并且信任友元类或函数时，才应使用友元关系。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>在C++中，枚举（enumeration）是一种用于定义命名常量集合的数据类型。枚举提供了一种方便的方式来表示一组相关的离散值，并可以增加代码的可读性和可维护性。</p><p>以下是使用枚举的基本语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumName</span> &#123;</span><br><span class="line">    Value1,</span><br><span class="line">    Value2,</span><br><span class="line">    Value3 = <span class="number">10</span>,</span><br><span class="line">    Value4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>EnumName</code> 是枚举类型的名称。<code>Value1</code>、<code>Value2</code>、<code>Value3</code> 和 <code>Value4</code> 是枚举常量，它们代表了枚举类型的不同取值。默认情况下，第一个枚举常量的值为 0，后续的枚举常量的值递增。但是，您也可以为枚举常量指定特定的值（如 <code>Value3 = 10</code>），后续的枚举常量将按照前一个常量的值递增。</p><p>枚举的常量可以在程序中直接使用，就像其他常量一样。以下是一个使用枚举的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Day today = Wednesday;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (today == Wednesday) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Today is Wednesday.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Today is not Wednesday.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个表示星期几的枚举类型 <code>Day</code>，然后使用枚举类型创建了一个变量 <code>today</code>，并将其赋值为 <code>Wednesday</code>。然后，我们可以使用条件语句来检查 <code>today</code> 是否等于 <code>Wednesday</code>，并输出相应的消息。</p><p>枚举可以与整数类型进行隐式转换，也可以通过强制类型转换将整数值转换为枚举类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Day day = <span class="built_in">static_cast</span>&lt;Day&gt;(<span class="number">2</span>);  <span class="comment">// 将整数值 2 转换为 Day 枚举类型</span></span><br></pre></td></tr></table></figure><p>枚举类型可以用作函数的参数类型或返回类型，以提供更具可读性的代码。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Day <span class="title">getNextDay</span><span class="params">(Day currentDay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Day&gt;((currentDay + <span class="number">1</span>) % <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数接受一个 <code>Day</code> 类型的参数 <code>currentDay</code>，并返回下一天的枚举值。</p><p>需要注意的是，枚举中的常量名称在同一作用域中是唯一的，不能重复定义相同名称的枚举常量。</p><p>通过使用枚举，您可以更清晰地表示一组相关的常量，并使代码更易于理解和维护。</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>在C++中，结构体（struct）是一种用户定义的数据类型，用于组合不同类型的数据成员。它类似于类（class），但有一些区别。下面是关于C++结构体的一些重要信息：</p><ol><li>定义结构体：结构体定义使用<code>struct</code>关键字，后面紧跟结构体的名称和一对花括号。在花括号中，您可以声明结构体的数据成员。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为<code>Person</code>的结构体，它有三个数据成员：<code>age</code>（整数类型），<code>name</code>（字符数组类型），和<code>height</code>（浮点数类型）。</p><ol><li>创建结构体变量：要使用结构体，您需要创建结构体的一个或多个实例（变量）。创建结构体变量时，可以使用结构体名称后跟变量名称，并用结构体的数据成员初始化它们。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1;</span><br><span class="line">person1.age = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(person1.name, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">person1.height = <span class="number">175.5</span>;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个名为<code>person1</code>的<code>Person</code>结构体变量，并设置了其成员的值。</p><ol><li>访问结构体成员：可以使用点（<code>.</code>）运算符来访问结构体变量的成员。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person1.name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; person1.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; person1.height &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上述代码演示了如何访问<code>person1</code>结构体变量的成员并将其输出。</p><ol><li>结构体作为函数参数：结构体可以作为函数的参数传递。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonInfo</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; p.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数并传递结构体变量</span></span><br><span class="line"><span class="built_in">printPersonInfo</span>(person1);</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为<code>printPersonInfo</code>的函数，它接受一个<code>Person</code>结构体参数，并打印该结构体的成员信息。</p><p>这些是关于C++结构体的基本概念和用法。结构体允许您在一个数据类型中组合多个相关数据成员，以便更方便地操作和管理数据。</p><h1 id="共同体"><a href="#共同体" class="headerlink" title="共同体"></a>共同体</h1><p>在C++中，共同体（union）是一种特殊的数据类型，允许在同一内存空间中存储不同类型的数据。与结构体不同，共同体的所有成员共享同一块内存。共同体的大小等于其最大成员的大小。</p><p>下面是有关C++共同体的一些重要信息：</p><ol><li>定义共同体：使用<code>union</code>关键字定义共同体，后跟共同体的名称和一对花括号。在花括号中，您可以声明共同体的成员。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> intValue;</span><br><span class="line">    <span class="type">float</span> floatValue;</span><br><span class="line">    <span class="type">char</span> stringValue[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为<code>Data</code>的共同体，它有三个成员：<code>intValue</code>（整数类型），<code>floatValue</code>（浮点数类型），和<code>stringValue</code>（字符数组类型）。</p><ol><li>使用共同体：可以创建共同体的实例，并对其成员进行赋值。共同体的所有成员将共享同一块内存。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data data;</span><br><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line">data.floatValue = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br><span class="line"><span class="built_in">strcpy</span>(data.stringValue, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String value: &quot;</span> &lt;&lt; data.stringValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个名为<code>data</code>的<code>Data</code>共同体实例，并对其不同的成员赋值。注意，对一个成员的赋值将会影响其他成员的值，因为它们共享同一块内存。</p><ol><li>访问共同体成员：由于共同体的成员共享同一块内存，只能同时访问一个成员。可以使用点（<code>.</code>）运算符来访问共同体的成员。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">data.floatValue = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(data.stringValue, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String value: &quot;</span> &lt;&lt; data.stringValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在上面的示例中，每次访问共同体的不同成员之前，先为该成员赋值，以确保正确访问和解释共同体的内容。</p><ol><li>共同体的应用：共同体常用于在不同类型之间进行类型转换或节省内存。通过为共同体的不同成员赋值，可以将数据以不同类型进行解释和操作。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Data data;</span><br><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">data.floatValue = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(data.intValue);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在上述代码中，通过将整数值赋给共同体的<code>intValue</code>成员，然后将其强制转换为浮点数类型，可以在不改变内存中的值的情况下以不同类型解释该值。</p><p>这些是关于C++</p><p>共同体的基本概念和用法。共同体提供了一种在相同内存空间中存储不同类型数据的方法，但需要小心使用，确保正确解释和访问共同体的成员。</p><h1 id=""><a href="#" class="headerlink" title="[=]"></a>[=]</h1><p>在C++中，<code>[=]</code>是一种lambda表达式的捕获列表（Capture List）形式，用于指定lambda表达式中的外部变量的访问方式。</p><p>Lambda表达式是C++11引入的一种匿名函数形式，它可以用于定义一个可调用的函数对象。Lambda表达式可以捕获局部变量，即在定义lambda表达式时，可以访问其所在作用域中的变量。</p><p>捕获列表<code>[=]</code>表示通过值捕获方式来访问外部变量。具体而言，使用<code>[=]</code>捕获列表会导致lambda表达式内部对外部变量进行值拷贝，以便在lambda表达式执行时使用。</p><p>以下是一个使用<code>[=]</code>捕获列表的lambda表达式示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [=]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x + y = &quot;</span> &lt;&lt; x + y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lambda</span>();  <span class="comment">// 输出结果：x + y = 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，lambda表达式使用了<code>[=]</code>捕获列表来捕获外部变量<code>x</code>和<code>y</code>。这意味着lambda表达式内部可以访问并使用这些变量的值。</p><p>当执行lambda表达式时，会输出变量<code>x</code>和<code>y</code>的和，即30。这是因为在lambda表达式定义时，通过值捕获方式将<code>x</code>和<code>y</code>的值拷贝到lambda对象中。</p><p>需要注意的是，通过值捕获方式捕获的外部变量是只读的，即无法在lambda表达式内部修改这些变量的值。如果希望能够修改外部变量，可以使用引用捕获方式（<code>[&amp;]</code>）来捕获外部变量。</p><h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p><code>static_cast</code>是C++中的一种类型转换操作符，用于进行静态类型转换。它用于在编译时进行类型转换，编译器在进行类型转换时进行类型检查。<code>static_cast</code>可以用于以下几种转换：</p><ol><li>相关类型的转换：<code>static_cast</code>可用于相互关联的类型之间的转换，例如数字类型之间的转换（例如，整数到浮点数，浮点数到整数），以及指针和引用之间的转换。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intValue = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> doubleValue = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(intValue);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> intFromFloat = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(floatValue);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;number;</span><br><span class="line"><span class="type">void</span>* voidPtr = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><ol><li>基类和派生类之间的转换：<code>static_cast</code>可用于基类指针或引用与派生类指针或引用之间的转换。但是，这种转换只有在确保指针或引用指向的对象实际上是派生类对象时才是安全的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr);</span><br></pre></td></tr></table></figure><ol><li>隐式类型转换的显式化：<code>static_cast</code>可以将编译器隐式执行的类型转换显式化。这可以增加代码的可读性和明确性。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>static_cast</code>并不会执行运行时检查，因此在进行转换时要确保转换是安全的。如果存在不安全的转换，应该使用更严格的转换操作符（如<code>dynamic_cast</code>）来进行类型检查。</p><p>另外，<code>static_cast</code>也不能用于将底层const转换为非底层const，或者执行与底层const无关的其他转换。对于这些情况，可以使用<code>const_cast</code>和<code>reinterpret_cast</code>进行转换。</p><p>总结来说，<code>static_cast</code>是一种用于静态类型转换的操作符，适用于相关类型之间的转换、基类和派生类之间的转换，以及显式化隐式类型转换。在使用<code>static_cast</code>时，要确保转换是安全的并遵循C++的类型系统规则。</p><h1 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h1><p><code>goto</code>是C++中的一个关键字，用于实现无条件的跳转语句。它可以将程序的控制流直接跳转到指定的标签处。<code>goto</code>语句的使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label_name:</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到指定的标签处</span></span><br><span class="line"><span class="keyword">goto</span> label_name;</span><br></pre></td></tr></table></figure><p>下面是一些关于<code>goto</code>使用方法和注意事项的说明：</p><ol><li><code>goto</code>的使用方法：首先，在代码中定义一个标签（label），并在标签后面跟着一个冒号（:）。然后，通过使用<code>goto</code>关键字，将程序的控制流无条件地跳转到标签所在的位置。这种跳转可以在同一个函数内部、跨越多个代码块或函数之间进行。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> jump;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部分代码将被跳过</span></span><br><span class="line"></span><br><span class="line">    jump:</span><br><span class="line">    <span class="comment">// 跳转到这里继续执行</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>goto</code>的注意事项：</p><ul><li><p>避免滥用：<code>goto</code>语句的滥用会导致程序的逻辑变得混乱和难以理解。通常情况下，应该优先使用结构化的控制流语句（如<code>if</code>、<code>while</code>、<code>for</code>等）来实现代码逻辑。</p></li><li><p>防止跨过变量初始化：使用<code>goto</code>语句时要小心，以防止跳过局部变量的初始化过程。如果在跳转前需要对某个变量进行初始化，确保变量的初始化操作位于标签之前。</p></li><li><p>避免跨函数跳转：应避免在不同函数之间使用<code>goto</code>语句进行跳转，因为这会增加代码的复杂性和可读性，并可能导致代码难以维护。</p></li><li><p>保持代码清晰和可读性：使用<code>goto</code>语句时，应该注重代码的清晰性和可读性。给标签和跳转语句起具有描述性的名称，以便于他人理解代码的逻辑。</p></li><li><p>尽量避免使用：由于<code>goto</code>语句可能导致代码难以理解和维护，以及潜在的错误和混乱，建议尽量避免使用<code>goto</code>语句。大多数情况下，结构化的控制流语句可以更好地表达代码的逻辑。</p></li></ul></li></ol><p>需要注意的是，尽管<code>goto</code>语句在某些情况下可以提供方便，但它往往被认为是一种不良的编程实践，应该谨慎使用。在大多数情况下，更好的方法是使用结构化的控制流语句来组</p><p>织代码并保持代码的清晰性和可读性。</p><h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>在C++中，<code>auto</code>关键字用于自动推断变量的类型。通过使用<code>auto</code>关键字，编译器可以根据变量的初始化表达式来推断变量的类型，无需显式指定类型。</p><p><code>auto</code>关键字的使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variable = value;</span><br></pre></td></tr></table></figure><p>其中，<code>variable</code>是变量名，<code>value</code>是变量的初始化表达式。</p><p>以下是一些示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;  <span class="comment">// 推断x的类型为int，初始化为10</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>;  <span class="comment">// 推断y的类型为double，初始化为3.14</span></span><br><span class="line"><span class="keyword">auto</span> name = <span class="string">&quot;John&quot;</span>;  <span class="comment">// 推断name的类型为const char*，初始化为指向字符串常量的指针</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">7</span>);  <span class="comment">// 推断result的类型为函数add的返回类型，根据函数定义来推断</span></span><br></pre></td></tr></table></figure><p>通过使用<code>auto</code>关键字，可以简化变量声明的过程，特别是当变量的类型较为复杂或难以确定时。编译器会根据初始化表达式的类型推断出变量的类型，并自动进行类型检查。</p><p>需要注意的是，<code>auto</code>关键字在变量声明时使用，不能用于函数参数、函数返回类型、类的成员变量等场景。此外，由于类型是在编译时推断的，因此在某些情况下可能会导致代码可读性降低，特别是当初始化表达式较为复杂或类型不明显时。</p><p>在C++11之后，引入了更加强大的类型推断功能，例如<code>decltype</code>和<code>auto</code>结合使用，可以更灵活地推断出变量的类型。在C++14中，还引入了<code>decltype(auto)</code>来进行更精确的类型推断。这些功能在一些特定场景下可以提供更灵活和准确的类型推断。</p><h1 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h1><p>在C++中，<code>typeid</code>是一个运算符，用于获取表达式的类型信息。它返回一个<code>type_info</code>对象，该对象包含有关表达式类型的信息。<code>typeid</code>可以用于以下几种情况：</p><ol><li>获取类型信息：使用<code>typeid</code>可以获取表达式的类型信息。它可以用于变量、对象、指针、引用以及类的实例等。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(num);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; objType = <span class="built_in">typeid</span>(obj);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; objType.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol><li>类型比较：可以使用<code>typeid</code>来比较两个表达式的类型是否相同。如果类型相同，比较结果为<code>true</code>；否则为<code>false</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(a) == <span class="built_in">typeid</span>(b)) &#123;</span><br><span class="line">    <span class="comment">// 类型相同</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>需要包含 <code>&lt;typeinfo&gt;</code> 头文件以使用 <code>typeid</code>。</li><li><code>type_info</code> 类型的对象在不同的编译单元中可能具有不同的地址，因此不能将其地址进行比较。</li><li><code>type_info</code> 对象的 <code>name()</code> 方法返回一个 <code>const char*</code> 指针，表示类型的名称。该名称的具体格式可能因编译器而异。</li><li>由于类型名称的具体格式是由编译器决定的，因此不应依赖于 <code>name()</code> 返回的字符串进行逻辑判断。</li></ul><p>需要注意的是，<code>typeid</code>主要用于运行时的类型信息，因此它在某些情况下可能会有一些限制。例如，对于多态类的基类指针或引用，<code>typeid</code>将返回指向实际对象的类型信息，而不是指向基类的类型信息。为了正确使用<code>typeid</code>，请确保在使用前已经了解了相关类型的特性和使用约束。</p><p>总的来说，<code>typeid</code>运算符可用于获取和比较表达式的类型信息，对于调试、类型检查和运行时多态等方面是非常有用的。</p><h1 id="type-info"><a href="#type-info" class="headerlink" title="type_info"></a>type_info</h1><p><code>type_info</code> 是 C++ 标准库 <code>&lt;typeinfo&gt;</code> 中定义的类，它用于提供有关类型的运行时信息。<code>type_info</code> 类主要用于以下几个方面：</p><ol><li>获取类型信息：通过使用 <code>typeid</code> 运算符，可以获得表达式的 <code>type_info</code> 对象，从而获取有关类型的信息。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(num);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol><li>类型比较：<code>type_info</code> 对象可以进行类型比较，以检查两个类型是否相同。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(a) == <span class="built_in">typeid</span>(b)) &#123;</span><br><span class="line">    <span class="comment">// 类型相同</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取类型名称：<code>type_info</code> 对象的 <code>name()</code> 方法返回一个 <code>const char*</code> 指针，表示类型的名称。请注意，返回的名称可能具有平台和编译器特定的格式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(<span class="type">int</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type name: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li><code>type_info</code> 类在头文件 <code>&lt;typeinfo&gt;</code> 中定义，因此需要包含该头文件才能使用它。</li><li><code>type_info</code> 对象的 <code>name()</code> 方法返回的类型名称不一定是人类可读的，因为它可能是编译器特定的标识符。</li><li><code>type_info</code> 的 <code>==</code> 操作符用于比较两个 <code>type_info</code> 对象是否代表相同的类型，而不是比较类型名称。</li></ul><p>由于 <code>type_info</code> 类提供的信息是在运行时获得的，因此它在某些情况下可能具有一些限制。例如，对于多态类的基类指针或引用，<code>type_info</code> 返回的类型信息将是指向实际对象的类型信息，而不是指向基类的类型信息。</p><p>总结来说，<code>type_info</code> 类提供了获取运行时类型信息的功能，并支持类型比较。它对于实现运行时类型检查、多态和其他需要类型信息的场景非常有用。然而，由于类型名称的具体格式是由编译器决定的，因此在使用 <code>type_info</code> 返回的名称时应谨慎对待。</p><h1 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h1><p><code>nullptr</code> 是 C++11 引入的关键字，用于表示空指针常量。它是用来明确表示一个指针不指向任何有效对象或函数的特殊值。在之前的 C++ 标准中，通常使用宏定义 <code>NULL</code> 或整数常量 <code>0</code> 来表示空指针。</p><p>使用 <code>nullptr</code> 的好处包括：</p><ol><li>清晰明确：<code>nullptr</code> 显式地表达了指针为空的含义，避免了与整数零的混淆。</li><li>类型安全：<code>nullptr</code> 是一个特殊的空指针类型，它不能隐式转换为其他类型，从而避免了类型错误。</li><li>减少重载歧义：当存在多个函数重载时，传递 <code>nullptr</code> 可以帮助编译器正确地选择函数重载版本。</li></ol><p>以下是一些使用 <code>nullptr</code> 的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);  <span class="comment">// 调用 foo(char*) 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 指针为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了两个重载的 <code>foo</code> 函数，一个接受 <code>char*</code> 类型的指针，另一个接受 <code>int*</code> 类型的指针。当我们传递 <code>nullptr</code> 给 <code>foo</code> 函数时，编译器会选择接受 <code>char*</code> 类型的版本。此外，我们还使用 <code>==</code> 运算符将指针 <code>ptr</code> 与 <code>nullptr</code> 进行比较，以检查指针是否为空。</p><p>总结而言，<code>nullptr</code> 是 C++11 引入的关键字，用于表示空指针常量。它提供了更明确的语义、类型安全和减少重载歧义的优点，使得代码更加清晰和健壮。在编写新的 C++ 代码时，推荐使用 <code>nullptr</code> 来表示空指针。</p><h1 id="简易学生管理系统模板"><a href="#简易学生管理系统模板" class="headerlink" title="简易学生管理系统模板"></a>简易学生管理系统模板</h1><p>下面是一个简易的学生管理系统的示例代码，它包括了学生类和一个管理系统类，可以添加学生、显示所有学生和查找学生等功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age, <span class="type">const</span> std::string&amp; id)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age), <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getID</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    std::string id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentManagementSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addStudent</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age, <span class="type">const</span> std::string&amp; id)</span> </span>&#123;</span><br><span class="line">        <span class="function">Student <span class="title">student</span><span class="params">(name, age, id)</span></span>;</span><br><span class="line">        students.<span class="built_in">push_back</span>(student);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Student added successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayAllStudents</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (students.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No students found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;All students:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; student : students) &#123;</span><br><span class="line">                student.<span class="built_in">displayInfo</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchStudent</span><span class="params">(<span class="type">const</span> std::string&amp; id)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; student : students) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.<span class="built_in">getID</span>() == id) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Student found:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                student.<span class="built_in">displayInfo</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Student not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Student&gt; students;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StudentManagementSystem system;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加学生</span></span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>, <span class="string">&quot;1001&quot;</span>);</span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">19</span>, <span class="string">&quot;1002&quot;</span>);</span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">21</span>, <span class="string">&quot;1003&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有学生</span></span><br><span class="line">    system.<span class="built_in">displayAllStudents</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找学生</span></span><br><span class="line">    system.<span class="built_in">searchStudent</span>(<span class="string">&quot;1002&quot;</span>);</span><br><span class="line">    system.<span class="built_in">searchStudent</span>(<span class="string">&quot;1004&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>Student</code> 类表示学生，具有姓名、年龄和学号等属性，并提供了获取和显示学生信息的成员函数。</p><p><code>StudentManagementSystem</code> 类表示学生管理系统，它包含一个学生列表（使用 <code>std::vector&lt;Student&gt;</code> 存储学生），提供了添加学生、显示所有学生和查找学生的成员函数。</p><p>在 <code>main()</code> 函数中，我们创建了一个 <code>StudentManagementSystem</code> 对象 <code>system</code>，并使用其成员函数来添加学生、显示所有学生和查找学生。输出结果为添加的学生信息、所有学生信息以及查找到的学生信息（如果存在）。</p><p>请注意，上述代码是一个简易的示例，没有包括错误处理和持久化存储等完整的功能。在实际开发中，可能需要更多的功能和更复杂的设计来满</p>]]></content>
    
    
    <summary type="html">🥧本文汇总C++的数据类型、类、结构体等基础知识</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://momoao.github.io/tags/C/"/>
    
  </entry>
  
</feed>
