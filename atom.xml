<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MoMoAo🍓</title>
  
  <subtitle>MoMoAo&#39;s Blog</subtitle>
  <link href="https://momoao.github.io/atom.xml" rel="self"/>
  
  <link href="https://momoao.github.io/"/>
  <updated>2023-09-13T02:59:41.358Z</updated>
  <id>https://momoao.github.io/</id>
  
  <author>
    <name>MoMoAo🍓</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL面试题</title>
    <link href="https://momoao.github.io/posts/202309131057.html"/>
    <id>https://momoao.github.io/posts/202309131057.html</id>
    <published>2023-09-13T07:27:00.000Z</published>
    <updated>2023-09-13T02:59:41.358Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>参考：内容来自图灵教育</p></div><h1>1.什么是BufferPool？</h1><p><strong>Buffer Pool基本概念</strong></p><p>Buffer Pool：缓冲池，简称BP。其作用是用来缓存表数据与索引数据，减少磁盘IO操作，提升效率。</p><p>Buffer Pool由<strong>缓存数据页(Page)</strong> 和 对缓存数据页进行描述的<strong>控制块</strong> 组成, 控制块中存储着对应缓存页的所属的表空间、数据页的编号、以及对应缓存页在Buffer Pool中的地址等信息.</p><p>Buffer Pool默认大小是128M, 以Page页为单位，Page页默认大小16K，而控制块的大小约为数据页的5%，大概是800字节。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/5b04714e186c412f89efeb7047c34ef2.png" alt="image.png"></p><blockquote><p>注: Buffer Pool大小为128M指的就是缓存页的大小，控制块则一般占5%，所以每次会多申请6M的内存空间用于存放控制块</p></blockquote><p><strong>如何判断一个页是否在BufferPool中缓存 ?</strong></p><p>MySQl中有一个哈希表数据结构，它使用表空间号+数据页号，作为一个key，然后缓冲页对应的控制块作为value。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/79f20665ae0845d08adfbca28d78392c.png" alt="image.png"></p><ul><li><strong>当需要访问某个页的数据时，先从哈希表中根据表空间号+页号看看是否存在对应的缓冲页。</strong></li><li><strong>如果有，则直接使用；如果没有，就从free链表中选出一个空闲的缓冲页，然后把磁盘中对应的页加载到该缓冲页的位置</strong></li></ul><h1>2.InnoDB如何管理Page页？</h1><p><strong>Page页分类</strong></p><p>BP的底层采用链表数据结构管理Page。在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁盘IO操作，提升效率。</p><p>Page根据状态可以分为三种类型：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/b5a63ddee29646edaa90695894203203.png" alt="image.png"></p><ul><li>free page ： 空闲page，未被使用</li><li>clean page：被使用page，数据没有被修改过</li><li>dirty page：脏页，被使用page，数据被修改过，Page页中数据和磁盘的数据产生了不一致</li></ul><p>Page页如何管理</p><p>针对上面所说的三种page类型，InnoDB通过三种链表结构来维护和管理</p><ol><li>free list：表示空闲缓冲区，管理free page</li></ol><ul><li>free链表是把所有空闲的缓冲页对应的控制块作为一个个的节点放到一个链表中，这个链表便称之为free链表</li><li>基节点:  free链表中只有一个基节点是不记录缓存页信息(单独申请空间)，它里面就存放了free链表的头节点的地址，尾节点的地址，还有free链表里当前有多少个节点。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/2cbb45488a444bfea024a5ebba29d6ce.png" alt="image.png"></p><p>2.flush list： 表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间排序。</p><ul><li>InnoDB引擎为了提高处理效率，在每次修改缓冲页后，并不是立刻把修改刷新到磁盘上，而是在未来的某个时间点进行刷新操作. 所以需要使用到flush链表存储脏页，凡是被修改过的缓冲页对应的控制块都会作为节点加入到flush链表.</li><li>flush链表的结构与free链表的结构相似</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/1ba2e62477434290989d159632574704.png" alt="image.png"></p><p><strong>3.lru list</strong>：表示正在使用的缓冲区，管理clean page和dirty page，缓冲区以midpoint为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后面的链表称为old列表区，存放使用较少数据，占37%</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/22d85da8b0ed4c0d9a3f1d88eca9d8d0.png" alt="image.png"></p><h1>3.为什么写缓冲区，仅适用于非唯一普通索引页？</h1><p><strong>change Buffer基本概念</strong></p><p>Change Buffer：写缓冲区,是针对二级索引(辅助索引) 页的更新优化措施。</p><p>作用:  在进行DML操作时，如果请求的辅助索引（二级索引）没有在缓冲池中时，并不会立刻将磁盘页加载到缓冲池，而是在CB记录缓冲变更，等未来数据被读取时，再将数据合并恢复到BP中。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/b45afc7c46344260a20480939a88f144.png" alt="image.png"></p><ol><li>ChangeBuffer用于存储SQL变更操作，比如Insert/Update/Delete等SQL语句</li><li>ChangeBuffer中的每个变更操作都有其对应的数据页，并且该数据页未加载到缓存中；</li><li>当ChangeBuffer中变更操作对应的数据页加载到缓存中后，InnoDB会把变更操作Merge到数据页上；</li><li>InnoDB会定期加载ChangeBuffer中操作对应的数据页到缓存中，并Merge变更操作；</li></ol><p><strong>change buffer更新流程</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/1a9194995ec34d0bbb2700ad07aae00b.png" alt="image.png"></p><p>写缓冲区，仅适用于非唯一普通索引页，为什么？</p><ul><li>如果在索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘，做一次IO操作。会直接将记录查询到BufferPool中，然后在缓冲池修改，不会在ChangeBuffer操作。</li></ul><h1>4.MySQL为什么改进LRU算法？</h1><p><strong>普通LRU算法</strong></p><p>LRU = Least Recently Used（最近最少使用）: 就是末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/c734385cef9949b484e42ee60222a97a.png" alt="image.png"></p><ol><li>当要访问某个页时，如果不在Buffer Pool，需要把该页加载到缓冲池,并且把该缓冲页对应的控制块作为节点添加到LRU链表的头部。</li><li>当要访问某个页时，如果在Buffer Pool中，则直接把该页对应的控制块移动到LRU链表的头部</li><li>当需要释放空间时,从最末尾淘汰</li></ol><p><strong>普通LRU链表的优缺点</strong></p><p>优点</p><ul><li>所有最近使用的数据都在链表表头，最近未使用的数据都在链表表尾,保证热数据能最快被获取到。</li></ul><p>缺点</p><ul><li>如果发生全表扫描（比如：没有建立合适的索引 or 查询时使用select * 等），则有很大可能将真正的热数据淘汰掉.</li><li>由于MySQL中存在预读机制，很多预读的页都会被放到LRU链表的表头。如果这些预读的页都没有用到的话，这样，会导致很多尾部的缓冲页很快就会被淘汰。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/ebdd36bca2634360979f5462a409b998.png" alt="image.png"></p><p><strong>改进型LRU算法</strong></p><p>改进型LRU：将链表分为new和old两个部分，加入元素时并不是从表头插入，而是从中间midpoint位置插入(就是说从磁盘中新读出的数据会放在冷数据区的头部)，如果数据很快被访问，那么page就会向new列表头部移动，如果数据没有被访问，会逐步向old尾部移动，等待淘汰。</p><p>![](file:///Users/congqing/Downloads/%2002_%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98_%E6%9C%80%E7%BB%88%E8%AE%B2%E4%B9%89/02_%E5%9B%BE%E7%89%87/11.jpg?lastModify=1672033423)<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/82e7eef5d5bd4d21844866cdb8655ae5.png" alt="image.png"></p><p>冷数据区的数据页什么时候会被转到到热数据区呢 ?</p><ol><li>如果该数据页在LRU链表中存在时间超过1s，就将其移动到链表头部  ( 链表指的是整个LRU链表)</li><li>如果该数据页在LRU链表中存在的时间短于1s，其位置不变(由于全表扫描有一个特点，就是它对某个页的频繁访问总耗时会很短)</li><li>1s这个时间是由参数 <code>innodb_old_blocks_time</code> 控制的</li></ol><h1>5.使用索引一定可以提升效率吗？</h1><p>索引就是排好序的,帮助我们进行快速查找的数据结构.</p><p>简单来讲，索引就是一种将数据库中的记录按照特殊形式存储的数据结构。通过索引，能够显著地提高数据查询的效率，从而提升服务器的性能.</p><p>索引的优势与劣势</p><ul><li><p>优点</p><ul><li>提高数据检索的效率,降低数据库的IO成本</li><li>通过索引列对数据进行排序,降低数据排序的成本,降低了CPU的消耗</li></ul></li><li><p>缺点</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</li></ul></li><li><p>创建索引的原则</p><ul><li>在经常需要搜索的列上创建索引，可以加快搜索的速度；</li><li>在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ul></li></ul><h1>6.介绍一下Page页的结构？</h1><p>Page是整个InnoDB存储的最基本构件，也是InnoDB磁盘管理的最小单位，与数据库相关的所有内容都存储在这种Page结构里。</p><p>Page分为几种类型，常见的页类型有数据页（B+tree Node）Undo页（Undo Log Page）系统页（System Page） 事务数据页（Transaction System Page）等</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/771179e015044ba19f2f04fe4775048d.png" alt="image.png"></p><p><strong>Page 各部分说明</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>占用大小</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>File Header</strong></td><td><strong>38字节</strong></td><td><strong>文件头, 描述页信息</strong></td></tr><tr><td><strong>Page Header</strong></td><td><strong>56字节</strong></td><td><strong>页头,页的状态</strong></td></tr><tr><td><strong>Infimum + Supremum</strong></td><td><strong>26字节</strong></td><td><strong>最大和最小记录,这是两个虚拟的行记录</strong></td></tr><tr><td><strong>User Records</strong></td><td><strong>不确定</strong></td><td><strong>用户记录,存储数据行记录</strong></td></tr><tr><td><strong>Free Space</strong></td><td><strong>不确定</strong></td><td><strong>空闲空间,页中还没有被使用的空间</strong></td></tr><tr><td><strong>Page Directory</strong></td><td><strong>不确定</strong></td><td><strong>页目录,存储用户记录的相对位置</strong></td></tr><tr><td><strong>File Trailer</strong></td><td><strong>8字节</strong></td><td><strong>文件尾,校验页是否完整</strong></td></tr></tbody></table><ul><li>File Header 字段用于记录 Page 的头信息，其中比较重要的是 FIL_PAGE_PREV 和 FIL_PAGE_NEXT 字段，通过这两个字段，我们可以找到该页的上一页和下一页，实际上所有页通过两个字段可以形成一条双向链表</li><li>Page Header 字段用于记录 Page 的状态信息。</li><li>Infimum 和 Supremum 是两个伪行记录，Infimum（下确界）记录比该页中任何主键值都要小的值，Supremum （上确界）记录比该页中任何主键值都要大的值，这个伪记录分别构成了页中记录的边界。</li><li>User Records 中存放的是实际的数据行记录</li><li>Free Space 中存放的是空闲空间，被删除的行记录会被记录成空闲空间</li><li>Page Directory 记录着与二叉查找相关的信息</li><li>File Trailer 存储用于检测数据完整性的校验和等数据。</li></ul><p><strong>页结构整体上可以分为三大部分，分别为通用部分(文件头、文件尾)、存储记录空间、索引部分。</strong></p><ol><li>通用部分 (File Header&amp;File Trailer )</li></ol><p>通用部分 : 主要指文件头和文件尾，将页的内容进行封装，通过文件头和文件尾校验的CheckSum方式来确保页的传输是完整的。</p><p>其中比较重要的是在文件头中的 <code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code> 字段，通过这两个字段，我们可以找到该页的上一页和下一页，实际上所有页通过两个字段可以形成一条双向链表</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/ec7e6df344d941649bfc5b7d5e6a5bfc.png" alt="image.png"></p><ol start="2"><li>记录部分(User Records&amp;Free Space)</li></ol><p>页的主要作用是存储记录，所以“最小和最大记录”和“用户记录”部分占了页结构的主要空间。另外空闲空间是个灵活的部分，当有新的记录插入时，会从空闲空间中进行分配用于存储新记录</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/72c8a7b34e04410cae9d6daf7477de4d.png" alt="image.png"></p><p><strong>3)数据目录部分 (Page Directory)</strong></p><p>数据页中行记录按照主键值由小到大顺序串联成一个单链表(<strong>页中记录是以单向链表的形式进行存储的</strong>)，且单链表的链表头为最小记录，链表尾为最大记录。并且为了更快速地定位到指定的行记录，通过 <code>Page Directory</code>实现目录的功能，借助 <code>Page Directory</code>使用二分法快速找到需要查找的行记录。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/3b5dc41516bd42abbc84dc0e26b7d0c1.png" alt="image.png"></p><h1>7.说一下聚簇索引与非聚簇索引？</h1><p>聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录</p><ul><li><strong>聚簇索引</strong>: 将数据存储与索引放到了一块,索引结构的叶子节点保存了行数据.</li><li><strong>非聚簇索引</strong>：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置.</li></ul><p>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。</p><p>在InnoDB引擎中，主键索引采用的就是聚簇索引结构存储。</p><p>聚簇索引（聚集索引）</p><ul><li>聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键顺序构建 B+Tree结构。B+Tree 的叶子节点就是行记录，行记录和主键值紧凑地存储在一起。 这也意味着 InnoDB 的主键索引就是数据表本身，它按主键顺序存放了整张表的数据，占用的空间就是整个表数据量的大小。通常说的主键索引就是聚集索引。</li><li>InnoDB的表要求必须要有聚簇索引：<ul><li>如果表定义了主键，则主键索引就是聚簇索引</li><li>如果表没有定义主键，则第一个非空unique列作为聚簇索引</li><li>否则InnoDB会从建一个隐藏的row-id作为聚簇索引</li></ul></li><li>辅助索引<br>InnoDB辅助索引，也叫作二级索引，是根据索引列构建 B+Tree结构。但在 B+Tree 的叶子节点中只存了索引列和主键的信息。二级索引占用的空间会比聚簇索引小很多， 通常创建辅助索引就是为了提升查询效率。一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/e66e956acf0c45e19300c4c6ee9b8028.png" alt="image.png"></p><p><strong>非聚簇索引</strong></p><p>与InnoDB表存储不同，MyISM使用的是非聚簇索引， 非聚簇索引的两棵B+树看上去没什么不同 ，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。</p><p>表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于 索引树是独立的，通过辅助键检索无需访问主键的索引树 。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/3911e2c181a94bb498acad5540ee87cd.png" alt="image.png"></p><p><strong>聚簇索引的优点</strong></p><ol><li>当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。</li><li>当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ol><p><strong>聚簇索引的缺点</strong></p><ol><li>插入速度严重依赖于插入顺序 。</li><li>更新主键的代价很高，因为将会导致被更新的行移动 。</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ol><h1>8.索引有哪几种类型？</h1><p><strong>1）普通索引</strong></p><ul><li><strong>这是最基本的索引类型，基于普通字段建立的索引，没有任何限制。</strong></li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> &lt;索引的名字&gt; <span class="keyword">ON</span> tablename (字段名);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> <span class="keyword">INDEX</span> [索引的名字] (字段名);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename ( [...], <span class="keyword">INDEX</span> [索引的名字] (字段名) );</span><br></pre></td></tr></table></figure><p><strong>2）唯一索引</strong></p><ul><li><strong>与&quot;普通索引&quot;类似，不同的就是：索引字段的值必须唯一，但允许有空值 。</strong></li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> &lt;索引的名字&gt; <span class="keyword">ON</span> tablename (字段名);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> [索引的名字] (字段名);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename ( [...], <span class="keyword">UNIQUE</span> [索引的名字] (字段名) ;</span><br></pre></td></tr></table></figure><p><strong>3）主键索引</strong></p><ul><li><strong>它是一种特殊的唯一索引，不允许有空值。在创建或修改表时追加主键约束即可，每个表只能有一个主键。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename ( [...], <span class="keyword">PRIMARY</span> KEY (字段名) );</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (字段名);</span><br></pre></td></tr></table></figure><p><strong>4）复合索引</strong></p><ul><li><strong>用户可以在多个列上建立索引，这种索引叫做组复合索引（组合索引）。复合索引可以代替多个单一索引，相比多个单一索引复合索引所需的开销更小。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX <span class="operator">&lt;</span>索引的名字<span class="operator">&gt;</span> <span class="keyword">ON</span> tablename (字段名<span class="number">1</span>，字段名<span class="number">2.</span>..);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> INDEX [索引的名字] (字段名<span class="number">1</span>，字段名<span class="number">2.</span>..);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename ( [...], INDEX [索引的名字] (字段名<span class="number">1</span>，字段名<span class="number">2.</span>..) );</span><br></pre></td></tr></table></figure><ul><li><strong>复合索引使用注意事项：</strong><ul><li><strong>何时使用复合索引，要根据where条件建索引，注意不要过多使用索引，过多使用会对更新操作效率有很大影响。</strong></li><li><strong>如果表已经建立了(col1，col2)，就没有必要再单独建立（col1）；如果现在有(col1)索引，如果查询需要col1和col2条件，可以建立(col1,col2)复合索引，对于查询有一定提高。</strong></li></ul></li></ul><p><strong>5) 全文索引</strong></p><p>查询操作在数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果使用全文索引，查询速度会比like快很多倍。</p><p>在MySQL 5.6 以前的版本，只有MyISAM存储引擎支持全文索引，从MySQL 5.6开始MyISAM和InnoDB存储引擎均支持。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT <span class="keyword">INDEX</span> &lt;索引的名字&gt; <span class="keyword">ON</span> tablename (字段名);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> FULLTEXT [索引的名字] (字段名);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename ( [...], FULLTEXT <span class="keyword">KEY</span> [索引的名字] (字段名) ;</span><br></pre></td></tr></table></figure><p>全文索引方式有自然语言检索 <code>IN NATURAL LANGUAGE MODE</code>和布尔检索 <code>IN BOOLEAN MODE</code>两种</p><p>和常用的like模糊查询不同，全文索引有自己的语法格式，使用 match 和 against 关键字，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users3 <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(NAME) AGAINST(<span class="string">&#x27;aabb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- * 表示通配符,只能在词的后面</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users3 <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(NAME) AGAINST(<span class="string">&#x27;aa*&#x27;</span>  <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE);</span><br></pre></td></tr></table></figure><p>全文索引使用注意事项：</p><ul><li>全文索引必须在字符串、文本字段上建立。</li><li>全文索引字段值必须在最小字符和最大字符之间的才会有效。（innodb：3-84；myisam：4-84）</li></ul><h1>9.介绍一下最佳左前缀法则？</h1><p>1)最佳左前缀法则</p><p>最佳左前缀法则:  如果创建的是联合索引,就要遵循该法则. 使用索引时，where后面的条件需要从索引的最左前列开始使用,并且不能跳过索引中的列使用。</p><ul><li><p>场景1:  按照索引字段顺序使用，三个字段都使用了索引,没有问题。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_name = <span class="string">&#x27;tom&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> user_age = <span class="number">17</span> <span class="keyword">AND</span> user_level = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p>![](file:///Users/congqing/Downloads/%2002_%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98_%E6%9C%80%E7%BB%88%E8%AE%B2%E4%B9%89/02_%E5%9B%BE%E7%89%87/96.jpg?lastModify=1672123139)</p></li><li><p>场景2: 直接跳过user_name使用索引字段，索引无效，未使用到索引。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_age = <span class="number">17</span> <span class="keyword">AND</span> user_level = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p>![](file:///Users/congqing/Downloads/%2002_%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98_%E6%9C%80%E7%BB%88%E8%AE%B2%E4%B9%89/02_%E5%9B%BE%E7%89%87/97.jpg?lastModify=1672123139)</p></li><li><p>场景3:  不按照创建联合索引的顺序,使用索引</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> </span><br><span class="line">user_age = <span class="number">17</span> <span class="keyword">AND</span> user_name = <span class="string">&#x27;tom&#x27;</span> <span class="keyword">AND</span> user_level = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p>where后面查询条件顺序是 <code>user_age</code>、<code>user_level</code>、<code>user_name</code>与我们创建的索引顺序 <code>user_name</code>、<code>user_age</code>、<code>user_level</code>不一致，为什么还是使用了索引，原因是因为MySql底层优化器对其进行了优化。</p></li><li><p>最佳左前缀底层原理<br>MySQL创建联合索引的规则是: 首先会对联合索引最左边的字段进行排序( 例子中是 <code>user_name</code> ), 在第一个字段的基础之上 再对第二个字段进行排序 ( 例子中是 <code>user_age</code> ) .</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/c88122c037b649a5ac198164bc520ab9.png" alt="image.png"></p></li><li><p>最佳左前缀原则其实是和B+树的结构有关系, 最左字段肯定是有序的, 第二个字段则是无序的(联合索引的排序方式是: 先按照第一个字段进行排序,如果第一个字段相等再根据第二个字段排序). 所以如果直接使用第二个字段 <code>user_age</code> 通常是使用不到索引的.</p></li></ul><h1>10.什么是索引下推？</h1><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</p><p>需求: 查询users表中 “名字第一个字是张，年龄为10岁的所有记录”。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">AND</span> user_age = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>根据最左前缀法则，该语句在搜索索引树的时候，只能匹配到名字第一个字是‘张’的记录，接下来是怎么处理的呢？当然就是从该记录开始，逐个回表，到主键索引上找出相应的记录，再比对 <code>age</code> 这个字段的值是否符合。</p><p>图1: 在 (name,age) 索引里面特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/fd7f4f815cf24cde9b35c723eaba71ff.png" alt="image.png"></p><p>MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><p>图2: InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过,减少回表次数.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/8832dd9ba9b44f96a92f721fbf3179fc.png" alt="image.png"></p><p>总结</p><p>如果没有索引下推优化（或称ICP优化），当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录；</p><p>在支持ICP优化后，MySQL会在取出索引的同时，判断是否可以进行where条件过滤再进行索引查询，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。</p><h1>11.什么是自适应哈希索引？</h1><p>自适应Hash索引（Adatptive Hash Index，内部简称AHI）是InnoDB的三大特性之一，还有两个是 Buffer Pool简称BP、双写缓冲区（Doublewrite Buffer）。</p><p>1、自适应即我们不需要自己处理，当InnoDB引擎根据查询统计发现某一查询满足hash索引的数据结构特点，就会给其建立一个hash索引；</p><p>2、hash索引底层的数据结构是散列表（Hash表），其数据特点就是比较适合在内存中使用，自适应Hash索引存在于InnoDB架构中的缓存中（不存在于磁盘架构中），见下面的InnoDB架构图。</p><p>3、自适应hash索引只适合搜索等值的查询，如select * from table where index_col=‘xxx’，而对于其他查找类型，如范围查找，是不能使用的；</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/3435b04b2ae34166851e0c3a3aea92c8.png" alt="image.png"></p><p>Adaptive Hash Index是针对B+树Search Path的优化，因此所有会涉及到Search Path的操作，均可使用此Hash索引进行优化.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/60fe814818db44d6a4eae582348080ab.png" alt="image.png"></p><p>根据索引键值(前缀)快速定位到叶子节点满足条件记录的Offset，减少了B+树Search Path的代价，将B+树从Root节点至Leaf节点的路径定位，优化为Hash Index的快速查询。</p><p>InnoDB的自适应Hash索引是默认开启的，可以通过配置下面的参数设置进行关闭。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">innodb_adaptive_hash_index</span> = <span class="literal">off</span></span><br></pre></td></tr></table></figure><p>自适应Hash索引使用分片进行实现的，分片数可以使用配置参数设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">innodb_adaptive_hash_index_parts</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure><h1>12.为什么LIKE以%开头索引会失效？</h1><p>like查询为范围查询，%出现在左边，则索引失效。%出现在右边索引未失效.</p><p>场景1: 两边都有% 或者 字段左边有%,索引都会失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;%tom%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;%tom&#x27;</span>;</span><br></pre></td></tr></table></figure><p>场景2: 字段右边有%,索引生效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;tom%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>解决%出现在左边索引失效的方法，使用覆盖索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;%jack%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> user_name,user_age,user_level <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;%jack%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>对比场景1可以知道, 通过使用覆盖索引 <code>type = index</code>,并且 <code>extra = Using index</code>,从全表扫描变成了全索引扫描.</p><p><strong>like 失效的原因</strong></p><ol><li><strong>%号在右:</strong> 由于B+树的索引顺序，是按照首字母的大小进行排序，%号在右的匹配又是匹配首字母。所以可以在B+树上进行有序的查找，查找首字母符合要求的数据。所以有些时候可以用到索引.</li><li><strong>%号在左:</strong>  是匹配字符串尾部的数据，我们上面说了排序规则，尾部的字母是没有顺序的，所以不能按照索引顺序查询，就用不到索引.</li><li><strong>两个%%号:</strong>  这个是查询任意位置的字母满足条件即可，只有首字母是进行索引排序的，其他位置的字母都是相对无序的，所以查找任意位置的字母是用不上索引的.</li></ol><h1>13.自增还是UUID？数据库主键的类型该如何选择？</h1><p>auto_increment的优点：</p><ol><li>字段长度较uuid小很多，可以是bigint甚至是int类型，这对检索的性能会有所影响。</li><li>在写的方面，因为是自增的，所以主键是趋势自增的，也就是说新增的数据永远在后面，这点对于性能有很大的提升。</li><li>数据库自动编号，速度快，而且是增量增长，按顺序存放，对于检索非常有利。</li><li>数字型，占用空间小，易排序，在程序中传递也方便。</li></ol><p>auto_increment的缺点：</p><ol><li>由于是自增，很容易通过网络爬虫知晓当前系统的业务量。</li><li>高并发的情况下，竞争自增锁会降低数据库的吞吐能力。</li><li>数据迁移或分库分表场景下，自增方式不再适用。</li></ol><p>UUID的优点：</p><ol><li>不会冲突。进行数据拆分、合并存储的时候，能保证主键全局的唯一性</li><li>可以在应用层生成，提高数据库吞吐能力</li></ol><p>UUID的缺点：</p><ol><li>影响插入速度， 并且造成硬盘使用率低。与自增相比，最大的缺陷就是随机io，下面我们会去具体解释</li><li>字符串类型相比整数类型肯定更消耗空间，而且会比整数类型操作慢。</li></ol><p><strong>uuid 和自增 id 的索引结构对比</strong></p><p>1、<strong>使用自增 id 的内部结构</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/965a1eaee74545ce898051078f21eb43.png" alt="image.png"></p><p>自增的主键的值是顺序的，所以 InnoDB 把每一条记录都存储在一条记录的后面。</p><ul><li>当达到页面的最大填充因子时候（InnoDB 默认的最大填充因子是页大小的 15/16，会留出 1/16 的空间留作以后的修改）。</li><li>下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费。</li><li>新插入的行一定会在原有的最大数据行下一行，MySQL 定位和寻址很快，不会为计算新行的位置而做出额外的消耗。减少了页分裂和碎片的产生。</li></ul><p>2、<strong>使用 uuid 的索引内部结构</strong></p><p>插入UUID： 新的记录可能会插入之前记录的中间，因此需要移动之前的记录</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/e55ddabf65f148de983fe7ef1ae2aa16.png" alt="image.png"></p><p>被写满已经刷新到磁盘上的页可能会被重新读取</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/da8ea192750e47d280de25e91af24dcf.png" alt="image.png"></p><p>因为 uuid 相对顺序的自增 id 来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以 innodb 无法做到总是把新行插入到索引的最后，而是需要为新行寻找新的合适的位置从而来分配新的空间。</p><p>这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：</p><ol><li>写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb 在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机 IO。</li><li>因为写入是乱序的，innodb 不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，一次插入最少需要修改三个页以上。</li><li>由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片。</li><li>在把随机值（uuid 和雪花 id）载入到聚簇索引（InnoDB 默认的索引类型）以后，有时候会需要做一次 OPTIMEIZE TABLE 来重建表并优化页的填充，这将又需要一定的时间消耗。</li></ol><p>结论：使用 InnoDB 应该尽可能的按主键的自增顺序插入，并且尽可能使用单调的增加的聚簇键的值来插入新行。如果是分库分表场景下，分布式主键ID的生成方案 优先选择雪花算法生成全局唯一主键（雪花算法生成的主键在一定程度上是有序的）。</p><h1>14.InnoDB与MyISAM的区别？</h1><p>InnoDB和MyISAM是使用MySQL时最常用的两种引擎类型，我们重点来看下两者区别。</p><ul><li><p>事务和外键<br>InnoDB支持事务和外键，具有安全性和完整性，适合大量insert或update操作<br>MyISAM不支持事务和外键，它提供高速存储和检索，适合大量的select查询操作</p></li><li><p>锁机制<br>InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现。<br>MyISAM支持表级锁，锁定整张表。</p></li><li><p>索引结构<br>InnoDB使用聚集索引（聚簇索引），索引和记录在一起存储，既缓存索引，也缓存记录。<br>MyISAM使用非聚集索引（非聚簇索引），索引和记录分开。</p></li><li><p>并发处理能力<br>MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞。<br>InnoDB读写阻塞可以与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发</p></li><li><p>存储文件<br>InnoDB表对应两个文件，一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；<br>MyISAM表对应三个文件，一个.frm表结构文件，一个MYD表数据文件，一个.MYI索引文件。从MySQL5.0开始默认限制是256TB。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/789d8c3ad02743b69ce4123954791b03.png" alt="image.png"></p></li></ul><p>MyISAM 适用场景</p><ul><li>不需要事务支持（不支持）</li><li>并发相对较低（锁定机制问题）</li><li>数据修改相对较少，以读为主</li><li>数据一致性要求不高</li></ul><p>InnoDB 适用场景</p><ul><li>需要事务支持（具有较好的事务特性）</li><li>行级锁定对高并发有很好的适应能力</li><li>数据更新较为频繁的场景</li><li>数据一致性要求较高</li><li>硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO</li></ul><p>两种引擎该如何选择？</p><ul><li>是否需要事务？有，InnoDB</li><li>是否存在并发修改？有，InnoDB</li><li>是否追求快速查询，且数据修改少？是，MyISAM</li><li>在绝大多数情况下，推荐使用InnoDB</li></ul><p>扩展资料：各个存储引擎特性对比</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/2abdf9facc0a46af8b62223bcce85639.png" alt="image.png"></p><h1>15.B树和B+树的区别是什么？</h1><p><strong>1）B-Tree介绍</strong></p><p>B-Tree是一种平衡的多路查找树,B树允许一个节点存放多个数据. 这样可以在尽可能减少树的深度的同时,存放更多的数据(把瘦高的树变的矮胖).</p><p>B-Tree中所有节点的子树个数的最大值称为B-Tree的阶,用m表示.一颗m阶的B树,如果不为空,就必须满足以下条件.</p><p>m阶的B-Tree满足以下条件:</p><ol><li>每个节点最多拥有m-1个关键字(根节点除外),也就是m个子树</li><li>根节点至少有两个子树(可以没有子树,有就必须是两个)</li><li>分支节点至少有(m/2)颗子树 (除去根节点和叶子节点其他都是分支节点)</li><li>所有叶子节点都在同一层,并且以升序排序</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/56ce03b9a0ca4eb4bb704c6341fedb28.png" alt="image.png"></p><p><strong>什么是B-Tree的阶 ?</strong><br>所有节点中，节点【60,70,90】拥有的子节点数目最多，四个子节点（灰色节点），所以上面的B-Tree为4阶B树。</p><p><strong>B-Tree结构存储索引的特点</strong></p><p>为了描述B-Tree首先定义一条记录为一个键值对[key, data] ，key为记录的键值，对应表中的主键值(聚簇索引)，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同</p><ul><li>索引值和data数据分布在整棵树结构中</li><li>白色块部分是指针,存储着子节点的地址信息。</li><li>每个节点可以存放多个索引值及对应的data数据</li><li>树节点中的多个索引值从左到右升序排列</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/f4502da0577d4dc2af9cf8def7c18edd.png" alt="image.png"></p><p><strong>B-Tree的查找操作</strong></p><p>B-Tree的每个节点的元素可以视为一次I/O读取，树的高度表示最多的I/O次数，在相同数量的总元素个数下，每个节点的元素个数越多，高度越低，查询所需的I/O次数越少.</p><p><strong>B-Tree总结</strong></p><ul><li>优点: B树可以在内部节点存储键值和相关记录数据，因此把频繁访问的数据放在靠近根节点的位置将大大提高热点数据的查询效率。</li><li>缺点: B树中每个节点不仅包含数据的key值,还有data数据. 所以当data数据较大时,会导致每个节点存储的key值减少,并且导致B树的层数变高.增加查询时的IO次数.</li><li>使用场景: B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现</li></ul><p><strong>2）B+Tree</strong></p><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p><strong>B+Tree的特征</strong></p><ul><li>非叶子节点只存储键值信息.</li><li>所有叶子节点之间都有一个链指针.</li><li>数据记录都存放在叶子节点中.</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/844e6a92336a4549aa44d237fa1ca447.png" alt="image.png"></p><p><strong>B+Tree的优势</strong></p><ol><li>B+Tree是B Tree的变种，B Tree能解决的问题，B+Tree也能够解决（降低树的高度，增大节点存储数据量）</li><li>B+Tree扫库和扫表能力更强，如果我们要根据索引去进行数据表的扫描，对B Tree进行扫描，需要把整棵树遍历一遍，而B+Tree只需要遍历他的所有叶子节点即可（叶子节点之间有引用）。</li><li>B+Tree磁盘读写能力更强，他的根节点和支节点不保存数据区，所有根节点和支节点同样大小的情况下，保存的关键字要比B Tree要多。而叶子节点不保存子节点引用。所以，B+Tree读写一次磁盘加载的关键字比B Tree更多。</li><li>B+Tree排序能力更强，如上面的图中可以看出，B+Tree天然具有排序功能。</li><li>B+Tree查询效率更加稳定，每次查询数据，查询IO次数一定是稳定的。当然这个每个人的理解都不同，因为在B Tree如果根节点命中直接返回，确实效率更高。</li></ol><h1>16.一个B+树中大概能存放多少条索引记录？</h1><p>MySQL设计者将一个B+Tree的节点的大小设置为等于一个页. (这样做的目的是每个节点只需要一次I/O就可以完全载入), InnoDB的一个页的大小是16KB,所以每个节点的大小也是16KB, 并且B+Tree的根节点是保存在内存中的,子节点才是存储在磁盘上.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/ed746f7baf004f1e92a18649e3000bd0.png" alt="image.png"></p><p><strong>假设一个B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：</strong></p><p><strong>根节点指针数*单个叶子节点记录行数.</strong></p><ul><li><strong>计算根节点指针数</strong>: 假设表的主键为INT类型,占用的就是4个字节,或者是BIGINT占用8个字节, 指针大小为6个字节,那么一个页(就是B+Tree中的一个节点) ,大概可以存储: 16384B / (4B+6B) = 1638 ,一个节点最多可以存储1638个索引指针.</li><li><strong>计算每个叶子节点的记录数</strong>:我们假设一行记录的数据大小为1k,那么一页就可以存储16行数据,16KB / 1KB = 16.</li><li><strong>一颗高度为2的B+Tree可以存放的记录数为</strong>: 1638 * 16=26208 条数据记录, 同样的原理可以推算出一个高度3的B+Tree可以存放: 1638 * 1638 * 16 = 42928704条这样的记录.</li></ul><p><strong>所以InnoDB中的B+Tree高度一般为1-3层,就可以满足千万级别的数据存储</strong>,在查找数据时一次页的查找代表一次 IO，所以通过主键索引查询通常只需要 1-3 次 IO 操作即可查找到数据。</p><h1>17.explain 用过吗，有哪些主要字段？</h1><p>使用 <code>EXPLAIN</code> 关键字可以模拟优化器来执行SQL查询语句，从而知道MySQL是如何处理我们的SQL语句的。分析出查询语句或是表结构的性能瓶颈。</p><p><strong>MySQL查询过程</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/0ffbda5da5ae491bbf13b13bf75fdbdc.png" alt="image.png"></p><p><strong>通过explain我们可以获得以下信息：</strong></p><ul><li><strong>表的读取顺序</strong></li><li><strong>数据读取操作的操作类型</strong></li><li><strong>哪些索引可以被使用</strong></li><li><strong>哪些索引真正被使用</strong></li><li><strong>表的直接引用</strong></li><li><strong>每张表的有多少行被优化器查询了</strong></li></ul><p>Explain使用方式: <strong>explain+sql语句</strong>, 通过执行explain可以获得sql语句执行的相关信息</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><h1>18.type字段中有哪些常见的值？</h1><p><strong>type字段在 MySQL 官网文档描述如下：</strong></p><blockquote><p><strong>The join type. For descriptions of the different types.</strong></p></blockquote><p><strong>type字段显示的是连接类型 ( join type表示的是用什么样的方式来获取数据)，它描述了找到所需数据所使用的扫描方式, 是较为重要的一个指标。</strong></p><p><strong>下面给出各种连接类型,按照从最佳类型到最坏类型进行排序:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 完整的连接类型比较多</span></span><br><span class="line"><span class="keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="keyword">index</span> &gt; <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 简化之后,我们可以只关注一下几种</span></span><br><span class="line"><span class="keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="keyword">ref</span> &gt; range &gt; <span class="keyword">index</span> &gt; <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>一般来说,需要保证查询至少达到 range级别,最好能到ref,否则就要就行SQL的优化调整</strong></p></blockquote><p>下面介绍type字段不同值表示的含义:</p><table><thead><tr><th><strong>type类型</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>system</strong></td><td><strong>不进行磁盘IO,查询系统表,仅仅返回一条数据</strong></td></tr><tr><td><strong>const</strong></td><td><strong>查找主键索引,最多返回1条或0条数据. 属于精确查找</strong></td></tr><tr><td><strong>eq_ref</strong></td><td><strong>查找唯一性索引,返回数据最多一条, 属于精确查找</strong></td></tr><tr><td><strong>ref</strong></td><td><strong>查找非唯一性索引,返回匹配某一条件的多条数据,属于精确查找,数据返回可能是多条.</strong></td></tr><tr><td><strong>range</strong></td><td><strong>查找某个索引的部分索引,只检索给定范围的行,属于范围查找. 比如: &gt; 、 &lt; 、in 、between</strong></td></tr><tr><td><strong>index</strong></td><td><strong>查找所有索引树,比ALL快一些,因为索引文件要比数据文件小.</strong></td></tr><tr><td><strong>ALL</strong></td><td><strong>不使用任何索引,直接进行全表扫描</strong></td></tr><tr><td></td><td></td></tr></tbody></table><h1>19.Extra有哪些主要指标，各自的含义是什么？</h1><p>Extra 是 EXPLAIN 输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息</p><table><thead><tr><th><strong>extra类型</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>Using filesort</strong></td><td><strong>MySQL中无法利用索引完成的排序操作称为  “文件排序”</strong></td></tr><tr><td><strong>Using index</strong></td><td><strong>表示直接访问索引就能够获取到所需要的数据（覆盖索引），不需要通过索引回表</strong></td></tr><tr><td><strong>Using index condition</strong></td><td><strong>搜索条件中虽然出现了索引列，但是有部分条件无法使用索引，</strong> <strong>会根据能用索引的条件先搜索一遍再匹配无法使用索引的条件。</strong></td></tr><tr><td><strong>Using join buffer</strong></td><td><strong>使用了连接缓存, 会显示join连接查询时,MySQL选择的查询算法</strong></td></tr><tr><td><strong>Using temporary</strong></td><td><strong>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询</strong></td></tr><tr><td><strong>Using where</strong></td><td><strong>意味着全表扫描或者在查找使用索引的情况下，但是还有查询条件不在索引字段当中</strong></td></tr></tbody></table><h1>20.如何进行分页查询优化？</h1><ul><li><p>一般性分页</p><p>一般的分页查询使用简单的 limit 子句就可以实现。limit格式如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">LIMIT</span> [<span class="keyword">offset</span>,] <span class="keyword">rows</span></span><br></pre></td></tr></table></figure><ul><li>第一个参数指定第一个返回记录行的偏移量，注意从0开始；</li><li>第二个参数指定返回记录行的最大数目；</li><li>如果只给定一个参数，它表示返回最大的记录行数目；</li></ul><p><strong>思考1：如果偏移量固定，返回记录量对执行时间有什么影响？</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">100</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p>结果：在查询记录时，返回记录量低于100条，查询时间基本没有变化，差距不大。随着查询记录量越大，所花费的时间也会越来越多。</p><p><strong>思考2：如果查询偏移量变化，返回记录数固定对执行时间有什么影响？</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">100</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">10</span>,<span class="number">100</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">100</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">1000</span>,<span class="number">100</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">10000</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>结果：在查询记录时，如果查询记录量相同，偏移量超过100后就开始随着偏移量增大，查询时间急剧的增加。（这种分页查询机制，每次都会从数据库第一条记录开始扫描，越往后查询越慢，而且查询的数据越多，也会拖慢总查询速度。）</p></li><li><p>分页优化方案</p><p><strong>优化1: 通过索引进行分页</strong></p><p>直接进行limit操作 会产生全表扫描,速度很慢. Limit限制的是从结果集的M位置处取出N条输出,其余抛弃.</p><p>假设ID是连续递增的,我们根据查询的页数和查询的记录数可以算出查询的id的范围，然后配合 limit使用</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id  &gt;= <span class="number">100001</span> <span class="keyword">LIMIT</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>优化2：利用子查询优化</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先定位偏移位置的id</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> user_contacts <span class="keyword">LIMIT</span> <span class="number">100000</span>,<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据获取到的id值向后查询.</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_contacts <span class="keyword">WHERE</span> id &gt;=</span><br><span class="line">(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> user_contacts <span class="keyword">LIMIT</span> <span class="number">100000</span>,<span class="number">1</span>) <span class="keyword">LIMIT</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>原因：使用了id做主键比较(id&gt;=)，并且子查询使用了覆盖索引进行优化。</p></li></ul><h1>21.如何做慢查询优化？</h1><p><strong>MySQL 慢查询的相关参数解释：</strong></p><ul><li><strong>slow_query_log</strong>：是否开启慢查询日志，<code>ON(1)</code>表示开启,<br><code>OFF(0)</code> 表示关闭。</li><li><strong>slow-query-log-file</strong>：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。</li><li><strong>long_query_time</strong>： 慢查询<strong>阈值</strong>，当查询时间多于设定的阈值时，记录日志。</li></ul><p><strong>慢查询配置方式</strong></p><ol><li><strong>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的</strong></li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;</span></span><br><span class="line"><span class="section">+---------------------+------------------------------+</span></span><br><span class="line"><span class="section">| Variable_name       | Value                        |</span></span><br><span class="line"><span class="section">+---------------------+------------------------------+</span></span><br><span class="line">| slow<span class="emphasis">_query_log      | ON                           |</span></span><br><span class="line"><span class="emphasis">| slow_query_log_</span>file | /var/lib/mysql/test-slow.log |</span><br><span class="line"><span class="code">+---------------------+</span>------------------------------+</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>可以通过设置slow_query_log的值来开启</strong></li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global <span class="attribute">slow_query_log</span>=1;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用</strong> <code>set global slow_query_log=1</code>  开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）</li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-- </span>编辑配置</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line"><span class="bullet">-- </span>添加如下内容</span><br><span class="line">slow<span class="emphasis">_query_log =1</span></span><br><span class="line"><span class="emphasis">slow_query_log_</span>file=/var/lib/mysql/ruyuan-slow.log</span><br><span class="line"></span><br><span class="line"><span class="bullet">-- </span>重启MySQL</span><br><span class="line">service mysqld restart</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; show variables like &#x27;%slow_query%&#x27;;</span></span><br><span class="line"><span class="section">+---------------------+--------------------------------+</span></span><br><span class="line"><span class="section">| Variable_name       | Value                          |</span></span><br><span class="line"><span class="section">+---------------------+--------------------------------+</span></span><br><span class="line">| slow<span class="emphasis">_query_log      | ON                             |</span></span><br><span class="line"><span class="emphasis">| slow_query_log_</span>file | /var/lib/mysql/ruyuan-slow.log |</span><br><span class="line"><span class="code">+---------------------+</span>--------------------------------+</span><br></pre></td></tr></table></figure><ol start="4"><li>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？ 这个是由参数 <code>long_query_time</code>控制，默认情况下long_query_time的值为10秒.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>修改了变量long_query_time，但是查询变量long_query_time的值还是10，难道没有修改到呢？注意：使用命令 set global long_query_time=1 修改后，需要重新连接或新开一个会话才能看到修改值。</strong></li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;long_query_time&#x27;;</span></span><br><span class="line"><span class="section">+-----------------+----------+</span></span><br><span class="line"><span class="section">| Variable_name   | Value    |</span></span><br><span class="line"><span class="section">+-----------------+----------+</span></span><br><span class="line"><span class="section">| long_query_time | 1.000000 |</span></span><br><span class="line"><span class="section">+-----------------+----------+</span></span><br></pre></td></tr></table></figure><ol start="6"><li><code>log_output</code> 参数是指定日志的存储方式。<code>log_output='FILE'</code>  表示将日志存入文件，默认值是’FILE’。<code>log_output='TABLE'</code> 表示将日志存入数据库，这样日志信息就会被写入到 mysql.slow_log 表中。</li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; SHOW VARIABLES LIKE &#x27;%log_output%&#x27;;</span></span><br><span class="line"><span class="section">+---------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name | Value |</span></span><br><span class="line"><span class="section">+---------------+-------+</span></span><br><span class="line"><span class="section">| log_output    | FILE  |</span></span><br><span class="line"><span class="section">+---------------+-------+</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=‘FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件.</strong></p></blockquote><ol start="7"><li>系统变量 <code>log-queries-not-using-indexes</code>：未使用索引的查询也被记录到慢查询日志中（可选项）。如果调优的话，建议开启这个选项。</li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;log_queries_not_using_indexes&#x27;;</span></span><br><span class="line"><span class="section">+-------------------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name                 | Value |</span></span><br><span class="line"><span class="section">+-------------------------------+-------+</span></span><br><span class="line"><span class="section">| log_queries_not_using_indexes | OFF   |</span></span><br><span class="line"><span class="section">+-------------------------------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; set global log_queries_not_using_indexes=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; show variables like &#x27;log_queries_not_using_indexes&#x27;;</span></span><br><span class="line"><span class="section">+-------------------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name                 | Value |</span></span><br><span class="line"><span class="section">+-------------------------------+-------+</span></span><br><span class="line"><span class="section">| log_queries_not_using_indexes | ON    |</span></span><br><span class="line"><span class="section">+-------------------------------+-------+</span></span><br></pre></td></tr></table></figure><p><strong>3) 慢查询测试</strong></p><ol><li><strong>执行 test_index.sql 脚本,监控慢查询日志内容</strong></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# tail -f <span class="regexp">/var/</span>lib<span class="regexp">/mysql/</span>ruyuan-slow.log </span><br><span class="line"><span class="regexp">/usr/</span>sbin/mysqld, Version: <span class="number">5.7</span>.<span class="number">30</span>-log (MySQL Community Server (GPL)). started with:</span><br><span class="line">Tcp port: <span class="number">0</span>  Unix socket: <span class="regexp">/var/</span>lib<span class="regexp">/mysql/my</span>sql.sock</span><br><span class="line">Time                 Id Command    Argument</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>执行下面的SQL,执行超时 (超过1秒) 我们去查看慢查询日志</strong></li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test_index WHERE  </span><br><span class="line">hobby = &#x27;<span class="number">20009951</span>&#x27; OR hobby = &#x27;<span class="number">10009931</span>&#x27; OR hobby = &#x27;<span class="number">30009931</span>&#x27; </span><br><span class="line">OR dname = &#x27;name<span class="number">4000</span>&#x27; OR dname = &#x27;name<span class="number">6600</span>&#x27; ;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>日志内容</strong></li></ol><p><strong>我们得到慢查询日志后，最重要的一步就是去分析这个日志。我们先来看下慢日志里到底记录了哪些内容。</strong></p><p><strong>如下图是慢日志里其中一条SQL的记录内容，可以看到有时间戳，用户，查询时长及具体的SQL等信息.</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Time: 2022-02-23T13:50:45.005959Z</span></span><br><span class="line"><span class="meta"># User@Host: root[root] @ localhost []  Id:     3</span></span><br><span class="line"><span class="meta"># Query_time: 3.724273  Lock_time: 0.000371 Rows_sent: 5  Rows_examined: 5000000</span></span><br><span class="line">SET timestamp=<span class="number">1645624245</span>;</span><br><span class="line">select * from test_index where hobby = &#x27;<span class="number">20009951</span>&#x27; or hobby = &#x27;<span class="number">10009931</span>&#x27; or hobby = &#x27;<span class="number">30009931</span>&#x27; or dname = &#x27;name<span class="number">4000</span>&#x27; or dname = &#x27;name<span class="number">6600</span>&#x27;;</span><br></pre></td></tr></table></figure><ul><li><strong>Time: 执行时间</strong></li><li><strong>User: 用户信息 ,Id信息</strong></li><li><strong>Query_time: 查询时长</strong></li><li><strong>Lock_time: 等待锁的时长</strong></li><li><strong>Rows_sent:查询结果的行数</strong></li><li><strong>Rows_examined: 查询扫描的行数</strong></li><li><strong>SET timestamp: 时间戳</strong></li><li><strong>SQL的具体信息</strong></li></ul><p><strong>慢查询SQL优化思路</strong></p><p><strong>1) SQL性能下降的原因</strong></p><p>在日常的运维过程中，经常会遇到DBA将一些执行效率较低的SQL发过来找开发人员分析，当我们拿到这个SQL语句之后，在对这些SQL进行分析之前，需要明确可能导致SQL执行性能下降的原因进行分析，执行性能下降可以体现在以下两个方面：</p><ul><li><p><strong>等待时间长</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">锁表导致查询一直处于等待状态，后续我们从MySQL锁的机制去分析<span class="keyword">SQL</span>执行的原理</span><br></pre></td></tr></table></figure></li><li><p><strong>执行时间长</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查询语句写的烂</span><br><span class="line"><span class="number">2.</span>索引失效 </span><br><span class="line"><span class="number">3.</span>关联查询太多<span class="keyword">join</span> </span><br><span class="line"><span class="number">4.</span>服务器调优及各个参数的设置</span><br></pre></td></tr></table></figure></li></ul><p><strong>2) 慢查询优化思路</strong></p><ol><li><p>优先选择优化高并发执行的SQL,因为高并发的SQL发生问题带来后果更严重.</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">比如下面两种情况</span><span class="punctuation">:</span></span><br><span class="line">   <span class="attribute">SQL1</span><span class="punctuation">:</span> <span class="string">每小时执行10000次, 每次20个IO 优化后每次18个IO,每小时节省2万次IO</span></span><br><span class="line">   <span class="attribute">SQL2</span><span class="punctuation">:</span> <span class="string">每小时10次,每次20000个IO,每次优化减少2000个IO,每小时节省2万次IO</span></span><br><span class="line">   SQL2更难优化,SQL1更好优化.但是第一种属于高并发SQL,更急需优化 成本更低</span><br></pre></td></tr></table></figure></li><li><p>定位优化对象的性能瓶颈(在优化之前了解性能瓶颈在哪)</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在去优化SQL时,选择优化分方向有三个: </span><br><span class="line">  <span class="number">1.</span>IO<span class="comment">(数据访问消耗的了太多的时间,查看是否正确使用了索引)</span> , </span><br><span class="line">  <span class="number">2.</span>CPU<span class="comment">(数据运算花费了太多时间, 数据的运算分组 排序是不是有问题)</span> </span><br><span class="line">  <span class="number">3.</span>网络带宽<span class="comment">(加大网络带宽)</span></span><br></pre></td></tr></table></figure></li><li><p>明确优化目标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要根据数据库当前的状态</span><br><span class="line">数据库中与该条<span class="keyword">SQL</span>的关系</span><br><span class="line">当前<span class="keyword">SQL</span>的具体功能</span><br><span class="line">最好的情况消耗的资源,最差情况下消耗的资源,优化的结果只有一个给用户一个好的体验</span><br></pre></td></tr></table></figure></li><li><p>从explain执行计划入手</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只有<span class="keyword">explain</span>能告诉你当前<span class="keyword">SQL</span>的执行状态</span><br></pre></td></tr></table></figure></li><li><p>永远用小的结果集驱动大的结果集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">小的数据集驱动大的数据集,减少内层表读取的次数</span><br><span class="line"></span><br><span class="line">类似于嵌套循环</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">如果小的循环在外层,对于数据库连接来说就只连接<span class="number">5</span>次,进行<span class="number">5000</span>次操作,如果<span class="number">1000</span>在外,则需要进行<span class="number">1000</span>次数据库连接,从而浪费资源，增加消耗.这就是为什么要小表驱动大表。</span><br></pre></td></tr></table></figure></li><li><p>尽可能在索引中完成排序</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序操作用的比较多,<span class="keyword">order</span> <span class="title">by</span> 后面的字段如果在索引中,索引本来就是排好序的,所以速度很快,没有索引的话,就需要从表中拿数据,在内存中进行排序,如果内存空间不够还会发生落盘操作</span><br></pre></td></tr></table></figure></li><li><p>只获取自己需要的列</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要使用<span class="keyword">select</span>  * ,<span class="keyword">select</span> * 很可能不走索引,而且数据量过大</span><br></pre></td></tr></table></figure></li><li><p>只使用最有效的过滤条件</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">误区 <span class="keyword">where</span>后面的条件越多越好,但实际上是应该用最短的路径访问到数据</span><br></pre></td></tr></table></figure></li><li><p>尽可能避免复杂的join和子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每条<span class="keyword">SQL</span>的<span class="keyword">JOIN</span>操作 建议不要超过三张表</span><br><span class="line">将复杂的<span class="keyword">SQL</span>, 拆分成多个小的<span class="keyword">SQL</span> 单个表执行,获取的结果 在程序中进行封装</span><br><span class="line">如果<span class="keyword">join</span>占用的资源比较多,会导致其他进程等待时间变长</span><br></pre></td></tr></table></figure></li><li><p>合理设计并利用索引</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如何判定是否需要创建索引?</span><br><span class="line"> <span class="number">1</span>.较为频繁的作为查询条件的字段应该创建索引.</span><br><span class="line"> <span class="number">2</span>.唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件.（唯一性太差的字段主要是指哪些呢？如状态字段，类型字段等等这些字段中的数据可能总共就是那么几个几十个数值重复使用）（当一条Query所返回的数据超过了全表的<span class="number">15</span><span class="comment">%的时候，就不应该再使用索引扫描来完成这个Query了）.</span></span><br><span class="line"> <span class="number">3</span>.更新非常频繁的字段不适合创建索引.（因为索引中的字段被更新的时候，不仅仅需要更新表中的数据，同时还要更新索引数据，以确保索引信息是准确的）.</span><br><span class="line"> <span class="number">4</span>.不会出现在WHERE子句中的字段不该创建索引.</span><br><span class="line"></span><br><span class="line">如何选择合适索引?</span><br><span class="line"> <span class="number">1</span>.对于单键索引，尽量选择针对当前Query过滤性更好的索引.</span><br><span class="line"> <span class="number">2</span>.选择联合索引时,当前Query中过滤性最好的字段在索引字段顺序中排列要靠前.</span><br><span class="line"> <span class="number">3</span>.选择联合索引时,尽量索引字段出现在w中比较多的索引.</span><br></pre></td></tr></table></figure></li></ol><h1>22.Hash索引有哪些优缺点？</h1><p>MySQL中索引的常用数据结构有两种: 一种是B+Tree,另一种则是Hash.</p><p>Hash底层实现是由Hash表来实现的，是根据键值 &lt;key,value&gt; 存储数据的结构。非常适合根据key查找value值，也就是单个key查询，或者说等值查询。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/07494f5bfaff4208a65c0d7426708b47.png" alt="image.png"></p><p>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值,如果出现哈希码值相同的情况会拉出一条链表.</p><p>Hsah索引的优点</p><ul><li>因为索引自身只需要存储对应的Hash值,所以索引结构非常紧凑, 只需要做等值比较查询，而不包含排序或范围查询的需求，都适合使用哈希索引 .</li><li>没有哈希冲突的情况下,等值查询访问哈希索引的数据非常快.(如果发生Hash冲突,存储引擎必须遍历链表中的所有行指针,逐行进行比较,直到找到所有符合条件的行).</li></ul><p>Hash索引的缺点</p><ul><li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</li><li>哈希索引只支持等值比较查询。不支持任何范围查询和部分索引列匹配查找。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li></ul><h1>23.说一下InnoDB内存相关的参数优化？</h1><p>Buffer Pool参数优化</p><p>1.1 缓冲池内存大小配置</p><p>一个大的日志缓冲区允许大量的事务在提交之前不写日志到磁盘。因此，如果你有很多事务的更新，插入或删除操作，通过设置这个参数会大量的减少磁盘I/O的次数数。<br>建议: 在专用数据库服务器上，可以将缓冲池大小设置为服务器物理内存的60% - 80%.</p><ul><li><p><strong>查看缓冲池大小</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;%innodb_buffer_pool_size%&#x27;;</span></span><br><span class="line"><span class="section">+-------------------------+-----------+</span></span><br><span class="line"><span class="section">| Variable_name           | Value     |</span></span><br><span class="line"><span class="section">+-------------------------+-----------+</span></span><br><span class="line"><span class="section">| innodb_buffer_pool_size | 134217728 |</span></span><br><span class="line"><span class="section">+-------------------------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; select 134217728 / 1024 / 1024;</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br><span class="line"><span class="section">| 134217728 / 1024 / 1024 |</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br><span class="line"><span class="section">|            128.00000000 |</span></span><br><span class="line"><span class="section">+-------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在线调整InnoDB缓冲池大小</strong><br><strong>innodb_buffer_pool_size可以动态设置，允许在不重新启动服务器的情况下调整缓冲池的大小.</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL innodb_buffer_pool_size = 268435456; -- 512</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; show variables like &#x27;%innodb_buffer_pool_size%&#x27;;</span></span><br><span class="line"><span class="section">+-------------------------+-----------+</span></span><br><span class="line"><span class="section">| Variable_name           | Value     |</span></span><br><span class="line"><span class="section">+-------------------------+-----------+</span></span><br><span class="line"><span class="section">| innodb_buffer_pool_size | 268435456 |</span></span><br><span class="line"><span class="section">+-------------------------+-----------+</span></span><br></pre></td></tr></table></figure><p><strong>监控在线调整缓冲池的进度</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; SHOW STATUS WHERE Variable_name=&#x27;InnoDB_buffer_pool_resize_status&#x27;;</span></span><br><span class="line"><span class="section">+----------------------------------+----------------------------------------------------------------------+</span></span><br><span class="line"><span class="section">| Variable_name                    | Value                                                        |</span></span><br><span class="line"><span class="section">+----------------------------------+----------------------------------------------------------------------+</span></span><br><span class="line"><span class="section">| Innodb_buffer_pool_resize_status | Size did not change (old size = new size = 268435456. Nothing to do. |</span></span><br><span class="line"><span class="section">+----------------------------------+----------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>1.3 InnoDB 缓存性能评估</strong></p><p>当前配置的innodb_buffer_pool_size是否合适，可以通过分析InnoDB缓冲池的缓存命中率来验证。</p><ul><li><p>以下公式计算InnoDB buffer pool 命中率:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命中率 = innodb_buffer_pool_read_requests / (innodb_buffer_pool_read_requests+innodb_buffer_pool_reads)* 100</span><br><span class="line"></span><br><span class="line"><span class="section">参数1: innodb_buffer_pool_reads：表示InnoDB缓冲池无法满足的请求数。需要从磁盘中读取。</span></span><br><span class="line"><span class="section">参数2: innodb_buffer_pool_read_requests：表示从内存中读取页的请求数。</span></span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show status like &#x27;innodb_buffer_pool_read%&#x27;;</span></span><br><span class="line"><span class="section">+---------------------------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name                         | Value |</span></span><br><span class="line"><span class="section">+---------------------------------------+-------+</span></span><br><span class="line">| Innodb<span class="emphasis">_buffer_pool_read_ahead_rnd     | 0     |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_read_ahead         | 0     |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_read_ahead_evicted | 0     |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_read_requests      | 12701 |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_</span>reads              | 455   |</span><br><span class="line"><span class="code">+---------------------------------------+</span>-------+</span><br><span class="line"></span><br><span class="line"><span class="bullet">-- </span>此值低于90%，则可以考虑增加innodb_buffer_pool_size。</span><br><span class="line"><span class="section">mysql&gt; select 12701 / (455 + 12701) * 100 ;</span></span><br><span class="line"><span class="section">+-----------------------------+</span></span><br><span class="line"><span class="section">| 12701 / (455 + 12701) * 100 |</span></span><br><span class="line"><span class="section">+-----------------------------+</span></span><br><span class="line"><span class="section">|                     96.5415 |</span></span><br><span class="line"><span class="section">+-----------------------------+</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>1.4 Page管理相关参数</strong></p><p><strong>查看Page页的大小(默认16KB),</strong><code>innodb_page_size</code>只能在初始化MySQL实例之前配置，不能在之后修改。如果没有指定值，则使用默认页面大小初始化实例。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;%innodb_page_size%&#x27;; </span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name    | Value |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| innodb_page_size | 16384 |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br></pre></td></tr></table></figure><p><strong>Page页管理状态相关参数</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show global status like &#x27;%innodb_buffer_pool_pages%&#x27;;</span></span><br><span class="line"><span class="section">+----------------------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name                    | Value |</span></span><br><span class="line"><span class="section">+----------------------------------+-------+</span></span><br><span class="line">| Innodb<span class="emphasis">_buffer_pool_pages_data    | 515   |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_pages_dirty   | 0     |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_pages_flushed | 334   |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_pages_free    | 15868 |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_pages_misc    | 0     |</span></span><br><span class="line"><span class="emphasis">| Innodb_buffer_pool_pages_</span>total   | 16383 |</span><br><span class="line"><span class="code">+----------------------------------+</span>-------+</span><br></pre></td></tr></table></figure><p><strong>pages_data</strong>: InnoDB缓冲池中包含数据的页数。 该数字包括脏页面和干净页面。</p><p><strong>pages_dirty</strong>: 显示在内存中修改但尚未写入数据文件的InnoDB缓冲池数据页的数量（脏页刷新）。</p><p><strong>pages_flushed</strong>: 表示从InnoDB缓冲池中刷新脏页的请求数。</p><p><strong>pages_free</strong>: 显示InnoDB缓冲池中的空闲页面</p><p><strong>pages_misc</strong>: 缓存池中当前已经被用作管理用途或hash index而不能用作为普通数据页的数目</p><p><strong>pages_total</strong>: 缓存池的页总数目。单位是page。</p><h1>24.InnoDB日志相关的参数优化了解过吗？</h1><p><strong>1.日志缓冲区相关参数配置</strong></p><p><strong>日志缓冲区的大小。一般默认值16MB是够用的，但如果事务之中含有blog/text等大字段，这个缓冲区会被很快填满会引起额外的IO负载。配置更大的日志缓冲区,可以有效的提高MySQL的效率.</strong></p><ul><li><p><strong>innodb_log_buffer_size 缓冲区大小</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;innodb_log_buffer_size&#x27;;</span></span><br><span class="line"><span class="section">+------------------------+----------+</span></span><br><span class="line"><span class="section">| Variable_name          | Value    |</span></span><br><span class="line"><span class="section">+------------------------+----------+</span></span><br><span class="line"><span class="section">| innodb_log_buffer_size | 16777216 |</span></span><br><span class="line"><span class="section">+------------------------+----------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>innodb_log_files_in_group 日志组文件个数</strong><br><strong>日志组根据需要来创建。而日志组的成员则需要至少2个，实现循环写入并作为冗余策略。</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;innodb_log_files_in_group&#x27;;</span></span><br><span class="line"><span class="section">+---------------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name             | Value |</span></span><br><span class="line"><span class="section">+---------------------------+-------+</span></span><br><span class="line"><span class="section">| innodb_log_files_in_group | 2     |</span></span><br><span class="line"><span class="section">+---------------------------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>innodb_log_file_size 日志文件大小</strong><br><strong>参数innodb_log_file_size用于设定MySQL日志组中每个日志文件的大小(默认48M)。此参数是一个全局的静态参数，不能动态修改。</strong><br><strong>参数innodb_log_file_size的最大值，二进制日志文件大小（innodb_log_file_size * innodb_log_files_in_group）不能超过512GB.所以单个日志文件的大小不能超过256G.</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;innodb_log_file_size&#x27;;</span></span><br><span class="line"><span class="section">+----------------------+----------+</span></span><br><span class="line"><span class="section">| Variable_name        | Value    |</span></span><br><span class="line"><span class="section">+----------------------+----------+</span></span><br><span class="line"><span class="section">| innodb_log_file_size | 50331648 |</span></span><br><span class="line"><span class="section">+----------------------+----------+</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>2.日志文件参数优化</strong></p><p>首先我们先来看一下日志文件大小设置对性能的影响</p><ul><li>设置过小<ol><li>参数 <code>innodb_log_file_size</code>设置太小，就会导致MySQL的日志文件( redo log）频繁切换，频繁的触发数据库的检查点（Checkpoint），导致刷新脏页到磁盘的次数增加。从而影响IO性能。</li><li>处理大事务时，将所有的日志文件写满了，事务内容还没有写完，这样就会导致日志不能切换.</li></ol></li><li>设置过大<br>参数 <code>innodb_log_file_size</code>如果设置太大，虽然可以提升IO性能，但是当MySQL由于意外宕机时，二进制日志很大，那么恢复的时间必然很长。而且这个恢复时间往往不可控，受多方面因素影响。</li></ul><p><strong>优化建议:</strong></p><p>如何设置合适的日志文件大小 ?</p><ul><li>根据实际生产场景的优化经验,一般是计算一段时间内生成的事务日志（redo log）的大小， 而MySQL的日志文件的大小最少应该承载一个小时的业务日志量(官网文档中有说明)。</li></ul><p>想要估计一下InnoDB redo log的大小，需要抓取一段时间内Log SequenceNumber（日志顺序号）的数据,来计算一小时内产生的日志大小.</p><blockquote><p><strong>Log sequence number</strong></p><p><strong>自系统修改开始，就不断的生成redo日志。为了记录一共生成了多少日志，于是mysql设计了全局变量log sequence number，简称lsn，但不是从0开始，是从8704字节开始。</strong></p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- pager分页工具, 只获取 sequence的信息</span></span><br><span class="line">mysql&gt; pager grep <span class="keyword">sequence</span>;</span><br><span class="line">PAGER <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">&#x27;grep sequence&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询状态,并倒计时一分钟</span></span><br><span class="line">mysql&gt; <span class="keyword">show</span> engine innodb status\G <span class="keyword">select</span> sleep(<span class="number">60</span>);</span><br><span class="line"><span class="keyword">Log</span> <span class="keyword">sequence</span> number <span class="number">5399154</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1</span> min <span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一分时间内所生成的数据量 5406150</span></span><br><span class="line">mysql&gt; <span class="keyword">show</span> engine innodb status\G;</span><br><span class="line"><span class="keyword">Log</span> <span class="keyword">sequence</span> number <span class="number">5406150</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭pager</span></span><br><span class="line">mysql&gt; nopager;</span><br><span class="line">PAGER <span class="keyword">set</span> <span class="keyword">to stdout</span></span><br></pre></td></tr></table></figure><p>有了一分钟的日志量,据此推算一小时内的日志量</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; select (5406150 - 5399154) / 1024 as kb_per_min;</span></span><br><span class="line"><span class="section">+------------+</span></span><br><span class="line"><span class="section">| kb_per_min |</span></span><br><span class="line"><span class="section">+------------+</span></span><br><span class="line"><span class="section">|     6.8320 |</span></span><br><span class="line"><span class="section">+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="section">mysql&gt; select (5406150 - 5399154) / 1024 * 60 as kb_per_min;</span></span><br><span class="line"><span class="section">+------------+</span></span><br><span class="line"><span class="section">| kb_per_min |</span></span><br><span class="line"><span class="section">+------------+</span></span><br><span class="line"><span class="section">|   409.9219 |</span></span><br><span class="line"><span class="section">+------------+</span></span><br></pre></td></tr></table></figure><p>太大的缓冲池或非常不正常的业务负载可能会计算出非常大(或非常小)的日志大小。这也是公式不足之处，需要根据判断和经验。但这个计算方法是一个很好的参考标准。</p><h1>25.InnoDB IO线程相关参数优化了解过吗？</h1><p>数据库属于 IO 密集型的应用程序，其主要职责就是数据的管理及存储工作。从内存中读取一个数据库数据的时间是微秒级别，而从一块普通硬盘上读取一个IO是在毫秒级别。要优化数据库，IO操作是必须要优化的，尽可能将磁盘IO转化为内存IO。</p><p><strong>1) 参数: query_cache_size&amp;have_query_cache</strong><br>MySQL查询缓存会保存查询返回的完整结果。当查询命中该缓存，会立刻返回结果，跳过了解析，优化和执行阶段。<br>查询缓存会跟踪查询中涉及的每个表，如果这些表发生变化，那么和这个表相关的所有缓存都将失效。</p><ol><li>查看查询缓存是否开启</li></ol><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-- </span>查询是否支持查询缓存</span><br><span class="line"><span class="section">mysql&gt; show variables like &#x27;have_query_cache&#x27;;</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name    | Value |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| have_query_cache | YES   |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-- </span>查询是否开启查询缓存 默认关闭</span><br><span class="line"><span class="section">mysql&gt; show variables like &#x27;%query_cache_type%&#x27;;</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name    | Value |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br><span class="line"><span class="section">| query_cache_type | OFF   |</span></span><br><span class="line"><span class="section">+------------------+-------+</span></span><br></pre></td></tr></table></figure><ol start="2"><li>开启缓存,在my.ini中添加下面一行参数</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">query_cache_size</span>=128M</span><br><span class="line"><span class="attribute">query_cache_type</span>=1</span><br><span class="line"></span><br><span class="line">query_cache_type:</span><br><span class="line">设置为0，OFF,缓存禁用</span><br><span class="line">设置为1，ON,缓存所有的结果</span><br><span class="line">设置为2，DENAND,只缓存在select语句中通过SQL_CACHE指定需要缓存的查询</span><br></pre></td></tr></table></figure><ol start="3"><li>测试能否缓存查询</li></ol><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;%Qcache%&#x27;;</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">|<span class="string"> Variable_name           </span>|<span class="string"> Value   </span>|</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">|<span class="string"> Qcache_free_blocks      </span>|<span class="string"> 1       </span>|</span><br><span class="line">|<span class="string"> Qcache_free_memory      </span>|<span class="string"> 1031832 </span>|</span><br><span class="line">|<span class="string"> Qcache_hits             </span>|<span class="string"> 0       </span>|</span><br><span class="line">|<span class="string"> Qcache_inserts          </span>|<span class="string"> 0       </span>|</span><br><span class="line">|<span class="string"> Qcache_lowmem_prunes    </span>|<span class="string"> 0       </span>|</span><br><span class="line">|<span class="string"> Qcache_not_cached       </span>|<span class="string"> 1       </span>|</span><br><span class="line">|<span class="string"> Qcache_queries_in_cache </span>|<span class="string"> 0       </span>|</span><br><span class="line">|<span class="string"> Qcache_total_blocks     </span>|<span class="string"> 1       </span>|</span><br><span class="line">+-------------------------+---------+</span><br></pre></td></tr></table></figure><ul><li><strong>Qcache_free_blocks</strong>:缓存中目前剩余的blocks数量（如果值较大，则查询缓存中的内存碎片过多）</li><li><strong>Qcache_free_memory</strong>:空闲缓存的内存大小</li><li><strong>Qcache_hits</strong>:命中缓存次数</li><li><strong>Qcache_inserts</strong>: 未命中然后进行正常查询</li><li><strong>Qcache_lowmem_prunes</strong>:查询因为内存不足而被移除出查询缓存记录</li><li><strong>Qcache_not_cached</strong>: 没有被缓存的查询数量</li><li><strong>Qcache_queries_in_cache</strong>:当前缓存中缓存的查询数量</li><li><strong>Qcache_total_blocks</strong>:当前缓存的block数量</li></ul><p><strong>优化建议</strong>: Query Cache的使用需要多个参数配合，其中最为关键的是 query_cache_size 和 query_cache_type ，前者设置用于缓存 ResultSet 的内存大小，后者设置在何场景下使用 Query Cache。</p><p>MySQL数据库数据变化相对不多，query_cache_size 一般设置为256MB比较合适 ,也可以通过计算Query Cache的命中率来进行调整</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">( Qcache_hits / ( Qcache_hits + Qcache_inserts )</span> * <span class="number">100</span>) )</span><br></pre></td></tr></table></figure><ol start="2"><li>参数: innodb_max_dirty_pages_pct 该参数是InnoDB 存储引擎用来控制buffer pool中脏页的百分比，当脏页数量占比超过这个参数设置的值时，InnoDB会启动刷脏页的操作。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- innodb_max_dirty_pages_pct 参数可以动态调整，最小值为0， 最大值为99.99，默认值为 75。</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_max_dirty_pages_pct&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name              <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_max_dirty_pages_pct <span class="operator">|</span> <span class="number">75.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br></pre></td></tr></table></figure><p><strong>优化建议</strong>: 该参数比例值越大，从内存到磁盘的写入操作就会相对减少，所以能够一定程度下减少写入操作的磁盘IO。但是，如果这个比例值过大，当数据库 Crash 之后重启的时间可能就会很长，因为会有大量的事务数据需要从日志文件恢复出来写入数据文件中.最大不建议超过90,一般重启恢复的数据在超过1GB的话,启动速度就会变慢.</p><p><strong>3) 参数: innodb_old_blocks_pct&amp;innodb_old_blocks_time</strong><br><code>innodb_old_blocks_pct</code> 用来确定LRU链表中old sublist所占比例,默认占用37%</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;%innodb_old_blocks_pct%&#x27;;</span></span><br><span class="line"><span class="section">+-----------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name         | Value |</span></span><br><span class="line"><span class="section">+-----------------------+-------+</span></span><br><span class="line"><span class="section">| innodb_old_blocks_pct | 37    |</span></span><br><span class="line"><span class="section">+-----------------------+-------+</span></span><br></pre></td></tr></table></figure><p><code>innodb_old_blocks_time</code>  用来控制old sublist中page的转移策略，新的page页在进入LRU链表中时，会先插入到old sublist的头部，然后page需要在old sublist中停留innodb_old_blocks_time这么久后，下一次对该page的访问才会使其移动到new sublist的头部，默认值1秒.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;%innodb_old_blocks_time%&#x27;;</span></span><br><span class="line"><span class="section">+------------------------+-------+</span></span><br><span class="line"><span class="section">| Variable_name          | Value |</span></span><br><span class="line"><span class="section">+------------------------+-------+</span></span><br><span class="line"><span class="section">| innodb_old_blocks_time | 1000  |</span></span><br><span class="line"><span class="section">+------------------------+-------+</span></span><br></pre></td></tr></table></figure><p><strong>优化建议</strong>: 在没有大表扫描的情况下，并且数据多为频繁使用的数据时，我们可以增加innodb_old_blocks_pct的值，并且减小innodb_old_blocks_time的值。让数据页能够更快和更多的进入的热点数据区。</p><h1>26.什么是写失效？</h1><p>InnoDB的页和操作系统的页大小不一致，InnoDB页大小一般为16K，操作系统页大小为4K，InnoDB的页写入到磁盘时，一个页需要分4次写。</p><p>如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/186aaf40085542d5a790025d9577b34d.png" alt="image.png"></p><p><strong>双写缓冲区 Doublewrite Buffer</strong></p><p>为了解决写失效问题，InnoDB实现了double write buffer Files, 它位于系统表空间，是一个存储区域。</p><p>在BufferPool的page页刷新到磁盘真正的位置前，会先将数据存在Doublewrite 缓冲区。这样在宕机重启时，如果出现数据页损坏，那么在应用redo log之前，需要通过该页的副本来还原该页，然后再进行redo log重做，double write实现了InnoDB引擎数据页的可靠性.</p><p>默认情况下启用双写缓冲区，如果要禁用Doublewrite 缓冲区，可以将 <code>innodb_doublewrite</code>设置为0。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_doublewrite%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name      <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_doublewrite <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>数据双写流程</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/a31680a18f104e0da3f3cb6c1aa71866.png" alt="image.png"></p><ul><li><strong>step1</strong>：当进行缓冲池中的脏页刷新到磁盘的操作时,并不会直接写磁盘,每次脏页刷新必须要先写double write .</li><li><strong>step2</strong>：通过memcpy函数将脏页复制到内存中的double write buffer .</li><li><strong>step3</strong>:  double write buffer再分两次、每次1MB, 顺序写入共享表空间的物理磁盘上, <strong>第一次写</strong>.</li><li><strong>step4</strong>:  在完成double write页的写入后，再将double wirite buffer中的页写入各个表的<strong>独立表空间</strong>文件中(数据文件 .ibd), <strong>第二次写</strong>。</li></ul><p><strong>为什么写两次 ?</strong></p><p>可能有的同学会有疑问，为啥写两次，刷一次数据文件保存数据不就可以了，为什么还要写共享表空间 ?其实是因为共享表空间是在ibdbata文件中划出2M连续的空间，专门给double write刷脏页用的, 由于在这个过程中，<strong>double write页的存储是连续的，因此写入磁盘为顺序写，性能很高</strong>；完成double write后，再将脏页写入实际的各个表空间文件，这时写入就是离散的了.</p><h1>27.什么是行溢出？</h1><p><strong>行记录格式</strong></p><p><strong>1) 行格式分类</strong></p><p>表的行格式决定了它的行是如何物理存储的，这反过来又会影响查询和DML操作的性能。如果在单个page页中容纳更多行，查询和索引查找可以更快地工作，缓冲池中所需的内存更少，写入更新时所需的I/O更少。</p><p>InnoDB存储引擎支持四种行格式：Redundant、Compact、Dynamic 和 Compressed .</p><p>查询MySQL使用的行格式,默认为: dynamic</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_default_row_format&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> innodb_default_row_format <span class="operator">|</span> <span class="keyword">dynamic</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+---------+</span></span><br></pre></td></tr></table></figure><p>指定行格式语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>table_name(column_name)<span class="operator">&gt;</span> ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span> ROW_FORMAT<span class="operator">=</span>行格式名称</span><br></pre></td></tr></table></figure><p><strong>2) COMPACT 行记录格式</strong></p><p>Compact 设计目标是高效地存储数据，一个页中存放的行数据越多，其性能就越高。</p><p>Compact行记录由两部分组成: 记录放入额外信息 和  记录的真实数据.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/55418f9593df402995e37c1b1a0bb05e.png" alt="image.png"></p><p><strong>记录额外信息部分</strong></p><p>服务器为了描述一条记录而添加了一些额外信息(元数据信息)，这些额外信息分为3类，分别是: 变长字段长度列表、NULL值列表和记录头信息.</p><ul><li><p><strong>变长字段长度列表</strong></p><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型，这些变长的数据类型占用的存储空间分为两部分：</p><ol><li>真正的数据内容</li><li>占用的字节数</li></ol><p>变长字段的长度是不固定的，所以在存储数据的时候要把这些数据占用的字节数也存起来，读取数据的时候才能根据这个长度列表去读取对应长度的数据。</p><p>在 <code>Compact</code>行格式中，把所有变长类型的列的长度都存放在记录的开头部位形成一个列表，按照列的顺序逆序存放,这个列表就是 <strong>变长字段长度列表</strong>。</p></li><li><p><strong>NULL值列表</strong></p><p>表中的某些列可能会存储NULL值，如果把这些NULL值都放到记录的真实数据中会比较浪费空间，所以Compact行格式把这些值为NULL的列存储到NULL值列表中。( 如果表中所有列都不允许为 NULL，就不存在NULL值列表 )</p></li><li><p><strong>记录头信息</strong></p><p>记录头信息是由固定的5个字节组成，5个字节也就是40个二进制位，不同的位代表不同的意思，这些头信息会在后面的一些功能中看到。</p><table><thead><tr><th>名称</th><th>大小(单位:bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>标记该记录是否是本层B+树的非叶子节点中的最小记录</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前分组中管理的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆中的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型:<br />0 表示普通记录,<br />1 表示B+树非叶子节点记录,<br />2 表示最小记录,3表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><ol><li><p>delete_mask</p><p>这个属性标记着当前记录是否被删除，占用1个二进制位，值为0 的时候代表记录并没有被删除，为1 的时候代表记录被删除掉了</p></li><li><p>min_rec_mask</p><p>B+树的每层非叶子节点中的最小记录都会添加该标记。</p></li><li><p>n_owned</p><p>代表每个分组里，所拥有的记录的数量，一般是分组里主键最大值才有的。</p></li><li><p>heap_no</p><p>在数据页的User Records中插入的记录是一条一条紧凑的排列的，这种紧凑排列的结构又被称为堆。为了便于管理这个堆，把记录在堆中的相对位置给定一个编号——heap_no。所以heap_no这个属性表示当前记录在本页中的位置。</p></li><li><p>record_type</p><p>这个属性表示当前记录的类型，一共有4种类型的记录， 0 表示普通用户记录， 1 表示B+树非叶节点记录， 2 表示最小记录， 3 表示最大记录。</p></li><li><p>next_record</p><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量，可以理解为指向下一条记录地址的指针。值为正数说明下一条记录在当前记录后面，为负数说明下一条记录在当前记录的前面。</p></li></ol></li><li><p><strong>记录真实数据部分</strong></p><p>记录的真实数据除了插入的那些列的数据，MySQL会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1607287731925286912/4b5476f2251b45939db29cfb4a7198cc.png" alt="image.png"></p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID,唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>生成隐藏主键列的方式有:</p><ol><li>服务器会在内存中维护一个全局变量，每当向某个包含隐藏的row_id列的表中插入一条记录时，就会把该变量的值当作新记录的row_id列的值，并且把该变量自增1。</li><li>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为7的页面中一个Max Row ID的属性处。</li><li>当系统启动时，会将页中的Max Row ID属性加载到内存中，并将该值加上256之后赋值给全局变量，因为在上次关机时该全局变量的值可能大于页中Max Row ID属性值。<br>4.</li></ol><p><strong>3) Compact中的行溢出机制</strong></p><p><strong>什么是行溢出 ?</strong></p><p>MySQL中是以页为基本单位,进行磁盘与内存之间的数据交互的,我们知道一个页的大小是16KB,16KB = 16384字节.而一个varchar(m) 类型列最多可以存储65532个字节,一些大的数据类型比如TEXT可以存储更多.</p><p>如果一个表中存在这样的大字段,那么一个页就无法存储一条完整的记录.这时就会发生行溢出,多出的数据就会存储在另外的溢出页中.</p><p>总结: 如果某些字段信息过长，无法存储在B树节点中，这时候会被单独分配空间，此时被称为溢出页，该字段被称为页外列。</p><p><strong>Compact中的行溢出机制</strong></p><p>InnoDB 规定一页至少存储两条记录(B+树特点)，如果页中只能存放下一条记录，InnoDB存储引擎会自动将行数据存放到溢出页中.<br>当发生行溢出时，数据页只保存了前768字节的前缀数据，接着是20个字节的偏移量，指向行溢出页.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/0dcc99e8c9ac4b4e92d2fc2cefef9398.png" alt="image.png"></p></li></ul><h1>28.如何进行JOIN优化？</h1><p>JOIN 是 MySQL 用来进行联表操作的，用来匹配两个表的数据，筛选并合并出符合我们要求的结果集。</p><p>JOIN 操作有多种方式，取决于最终数据的合并效果。常用连接方式的有以下几种:</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/55df110a70d9450283a9a2bf0269e2b1.png" alt="image.png"></p><p>什么是驱动表 ?</p><ul><li>多表关联查询时,第一个被处理的表就是驱动表,使用驱动表去关联其他表.</li><li>驱动表的确定非常的关键,会直接影响多表关联的顺序,也决定后续关联查询的性能</li></ul><p>驱动表的选择要遵循一个规则:</p><ul><li>在对最终的结果集没有影响的前提下,优先选择结果集最小的那张表作为驱动表</li></ul><p><strong>3) 三种JOIN算法</strong></p><p>1.Simple Nested-Loop Join（ 简单的嵌套循环连接 )</p><ul><li><p><strong>简单来说嵌套循环连接算法就是一个双层for 循环 ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果.</strong></p></li><li><p><strong>这种算法是最简单的方案，性能也一般。对内循环没优化。</strong></p></li><li><p><strong>例如有这样一条SQL:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接用户表与订单表 连接条件是 u.id = o.user_id</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">order</span> t2 <span class="keyword">on</span> t1.id <span class="operator">=</span> t2.user_id;</span><br><span class="line"><span class="comment">-- user表为驱动表,order表为被驱动表</span></span><br></pre></td></tr></table></figure></li><li><p>转换成代码执行时的思路是这样的:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">for</span>(user表行 uRow : user表)&#123;</span><br><span class="line">    <span class="built_in">for</span>(Order表的行 oRow : order表)&#123;</span><br><span class="line">        <span class="built_in">if</span>(uRow.id = oRow.user_id)&#123;</span><br><span class="line">            return uRow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>匹配过程如下图</strong><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/b471d0b4f2da457892be9bce33827285.png" alt="image.png"></p></li><li><p><strong>SNL 的特点</strong></p><ul><li><strong>简单粗暴容易理解，就是通过双层循环比较数据来获得结果</strong></li><li><strong>查询效率会非常慢,假设 A 表有 N 行，B 表有 M 行。SNL 的开销如下：</strong><ul><li><strong>A 表扫描 1 次。</strong></li><li><strong>B 表扫描 M 次。</strong></li><li><strong>一共有 N 个内循环，每个内循环要 M 次，一共有内循环 N * M 次</strong></li></ul></li></ul></li></ul><p><strong>2) Index Nested-Loop Join（ 索引嵌套循环连接 ）</strong></p><ul><li>Index Nested-Loop Join 其优化的思路:  <strong>主要是为了减少内层表数据的匹配次数</strong> , 最大的区别在于，用来进行 join 的字段已经在被驱动表中建立了索引。</li><li>从原来的  <code>匹配次数 = 外层表行数 * 内层表行数</code> , 变成了  <code>匹配次数 = 外层表的行数 * 内层表索引的高度</code>  ，极大的提升了 join的性能。</li><li>当 <code>order</code>  表的   <code>user_id</code>  为索引的时候执行过程会如下图：</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/524e38edbd0d46b5a3642a0cc2af786c.png" alt="image.png"></p><p><strong>注意：使用Index Nested-Loop Join 算法的前提是匹配的字段必须建立了索引。</strong></p><p><strong>3) Block Nested-Loop Join( 块嵌套循环连接 )</strong></p><p>如果 join 的字段有索引，MySQL 会使用 INL 算法。如果没有的话，MySQL 会如何处理？</p><p>因为不存在索引了，所以被驱动表需要进行扫描。这里 MySQL 并不会简单粗暴的应用 SNL 算法，而是加入了 buffer 缓冲区，降低了内循环的个数，也就是被驱动表的扫描次数。<br><img src="" alt=""><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/df7920c57eb449a68ae9fb902a976729.png" alt="image.png"></p><ul><li><p>在外层循环扫描 user表中的所有记录。扫描的时候，会把需要进行 join 用到的列都缓存到 buffer 中。buffer 中的数据有一个特点，里面的记录不需要一条一条地取出来和 order 表进行比较，而是整个 buffer 和 order表进行批量比较。</p></li><li><p>如果我们把 buffer 的空间开得很大，可以容纳下 user 表的所有记录，那么 order 表也只需要访问一次。</p></li><li><p>MySQL 默认 buffer 大小 256K，如果有 n 个 join 操作，会生成 n-1 个 join buffer。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mysql&gt; show variables like &#x27;%join_buffer%&#x27;;</span></span><br><span class="line"><span class="section">+------------------+--------+</span></span><br><span class="line"><span class="section">| Variable_name    | Value  |</span></span><br><span class="line"><span class="section">+------------------+--------+</span></span><br><span class="line"><span class="section">| join_buffer_size | 262144 |</span></span><br><span class="line"><span class="section">+------------------+--------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; set session join_buffer_size=262144;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><p><strong>4) JOIN优化总结</strong></p><ol><li>永远用小结果集驱动大结果集(其本质就是减少外层循环的数据数量)</li><li>为匹配的条件增加索引(减少内层表的循环匹配次数)</li><li>增大join buffer size的大小（一次缓存的数据越多，那么内层包的扫表次数就越少）</li><li>减少不必要的字段查询（字段越少，join buffer 所缓存的数据就越多</li></ol><h1>29.索引哪些情况下会失效？</h1><ol><li>查询条件包含 or，会导致索引失效。</li><li>隐式类型转换，会导致索引失效，例如 age 字段类型是 int，我们 where age = “1”，这样就会触发隐式类型转换</li><li>like 通配符会导致索引失效，注意:”ABC%” 不会失效，会走 range 索引，”% ABC” 索引会失效</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>对索引字段进行函数运算。</li><li>对索引列运算（如，+、-、*、/），索引失效。</li><li>索引字段上使用（!= 或者 &lt; &gt;，not in）时，会导致索引失效。</li><li>索引字段上使用 is null， is not null，可能导致索引失效。</li><li>相 join 的两个表的字符编码不同，不能命中索引，会导致笛卡尔积的循环计算</li><li>mysql 估计使用全表扫描要比使用索引快，则不使用索引。</li></ol><h1>30.什么是覆盖索引？</h1><p><strong>覆盖索引是一种避免回表查询的优化策略:  只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</strong></p><p>具体的实现方式:</p><ul><li><em>将被查询的字段建立普通索引或者联合索引</em>，这样的话就可以直接返回索引中的的数据，不需要再通过聚集索引去定位行记录，避免了回表的情况发生。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> user_name,user_age,user_level <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> user_name = <span class="string">&#x27;tom&#x27;</span> <span class="keyword">AND</span> user_age = <span class="number">17</span>;</span><br></pre></td></tr></table></figure><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672133064003/9fc6c9a655214e6dbec1e82f51e745e1.png" alt="image.png"></p><p>覆盖索引的定义与注意事项:</p><ul><li>如果一个索引包含了 所有需要查询的字段的值 (不需要回表)，这个索引就是覆盖索引。</li><li>MySQL只能使用B+Tree索引做覆盖索引 (因为只有B+树能存储索引列值)</li><li>在explain的Extra列, 如果出现 **<code>Using index</code>  表示 使用到了覆盖索引 , 所取的数据完全在索引中就能拿到</li></ul><h1>31.介绍一下MySQL中事务的特性？</h1><p>在关系型数据库管理系统中，一个逻辑工作单元要成为事务，必须满足这 4 个特性，即所谓的 ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p><p>1）原子性</p><p>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p><p>InnoDB存储引擎提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1670389670045/c33c69e81e80404a96f4cf49b90a16ab.png" alt="image.png"></p><p>每写一个事务,都会修改Buffer Pool,从而产生相应的Redo/Undo日志:</p><ul><li>如果要回滚事务，那么就基于undo log来回滚就可以了，把之前对缓存页做的修改都给回滚了就可以了。</li><li>如果事务提交之后，redo log刷入磁盘，结果MySQL宕机了，是可以根据redo log恢复事务修改过的缓存数据的。</li></ul><p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。</p><p>InnoDB 实现回滚，靠的是undo log ：当事务对数据库进行修改时，InnoDB 会生成对应的undo log  ；如果事务执行失败或调用了rollback ，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/8133afe062ba49389226210a1bd9a30c.png" alt="image.png"></p><p>2）一致性</p><p>一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。<em>一致状态</em>的含义是数据库中的数据应满足完整性约束。</p><ul><li>约束一致性：创建表结构时所指定的外键、唯一索引等约束。</li><li>数据一致性：是一个综合性的规定，因为它是由原子性、持久性、隔离性共同保证的结果，而不是单单依赖于某一种技术。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1670389670045/a885bb90c360436aab888b60e95ab5ab.png" alt="image.png"></p><p>3）隔离性</p><p>隔离性：指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。</p><p>不考虑隔离性会引发的问题:</p><ul><li><strong>脏读</strong> : 一个事务读取到了另一个事务修改但未提交的数据。</li><li><strong>不可重复读</strong>: 一个事务中多次读取同一行记录的结果不一致，后面读取的跟前面读取的结果不一致。</li><li><strong>幻读</strong> : 一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了几行记录。</li></ul><p>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。</p><p>4）持久性</p><p>持久性：指的是一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，后续的操作或故障不应该对其有任何影响，不会丢失。</p><p>MySQL 事务的持久性保证依赖的日志文件: <code>redo log</code></p><ul><li>redo log 也包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。redo log是物理日志，记录的是数据库中物理页的情况 。</li><li>当数据发生修改时，InnoDB不仅会修改Buffer Pool中的数据，也会在redo log buffer记录这次操作；当事务提交时，会对redo log buffer进行刷盘，记录到redo log file中。如果MySQL宕机，重启时可以读取redo log file中的数据，对数据库进行恢复。这样就不需要每次提交事务都实时进行刷脏了。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/d397f7b8274c418e8e582d7e689a0fbf.png" alt="image.png"></p><p>5）ACID总结</p><ul><li>事务的持久化是为了应对系统崩溃造成的数据丢失.</li><li>只有保证了事务的一致性，才能保证执行结果的正确性</li><li>在非并发状态下，事务间天然保证隔离性，因此只需要保证事务的原子性即可保证一致性.</li><li>在并发状态下，需要严格保证事务的原子性、隔离性。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1670389670045/0e07dadfa29943898a6aaeb3ccb5253b.png" alt="image.png"></p><h1>32.MySQL 的可重复读怎么实现的？</h1><p>可重复读（repeatable read）定义： 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</p><p>MVCC</p><ul><li>MVCC，多版本并发控制, 用于实现<strong>读已提交</strong>和<strong>可重复读</strong>隔离级别。</li><li>MVCC的核心就是 Undo log多版本链 + Read view，“MV”就是通过 Undo log来保存数据的历史版本，实现多版本的管理，“CC”是通过 Read-view来实现管理，通过 Read-view原则来决定数据是否显示。同时针对不同的隔离级别， Read view的生成策略不同，也就实现了不同的隔离级别。</li></ul><p><strong>Undo log 多版本链</strong></p><p>每条数据都有两个隐藏字段:</p><ul><li>trx_id: 事务id,记录最近一次更新这条数据的事务id.</li><li>roll_pointer: 回滚指针,指向之前生成的undo log</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/3914ba59208c40a1816d7aa616bdb00c.png" alt="image.png"></p><p>每一条数据都有多个版本,版本之间通过undo log链条进行连接通过这样的设计方式,可以保证每个事务提交的时候,一旦需要回滚操作,可以保证同一个事务只能读取到比当前版本更早提交的值,不能看到更晚提交的值。</p><p><strong>ReadView</strong></p><p>Read View是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现.</p><p>Read View简单理解就是对数据在某个时刻的状态拍成照片记录下来。那么之后获取某时刻的数据时就还是原来的照片上的数据，是不会变的.</p><p>Read View中比较重要的字段有4个:</p><ul><li><code>m_ids</code> : 用来表示MySQL中哪些事务正在执行,但是没有提交.</li><li><code>min_trx_id</code>: 就是m_ids里最小的值.</li><li><code>max_trx_id</code> : 下一个要生成的事务id值,也就是最大事务id</li><li><code>creator_trx_id</code>: 就是你这个事务的id</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/10f8a6842fd14b5fa3c510f54bcfac20.png" alt="image.png"></p><p>当一个事务第一次执行查询sql时，会生成一致性视图 read-view（快照），查询时从 undo log 中最新的一条记录开始跟 read-view 做对比，如果不符合比较规则，就根据回滚指针回滚到上一条记录继续比较，直到得到符合比较条件的查询结果。</p><p><strong>Read View判断记录某个版本是否可见的规则如下</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/29c8f326cf8a484dad8da5e9c157c217.png" alt="image.png"></p><p>1.如果当前记录的事务id落在绿色部分（trx_id &lt; min_id），表示这个版本是已提交的事务生成的，可读。<br>2.如果当前记录的事务id落在红色部分（trx_id &gt; max_id），表示这个版本是由将来启动的事务生成的，不可读。</p><ol start="3"><li><p>如果当前记录的事务id落在黄色部分（min_id &lt;= trx_id &lt;= max_id），则分为两种情况：</p></li><li><p>若当前记录的事务id在未提交事务的数组中，则此条记录不可读；</p></li><li><p>若当前记录的事务id不在未提交事务的数组中，则此条记录可读。</p></li></ol><p>RC 和 RR 隔离级别都是由 MVCC 实现，区别在于：</p><ul><li>RC 隔离级别时，read-view 是每次执行 select 语句时都生成一个；</li><li>RR 隔离级别时，read-view 是在第一次执行 select 语句时生成一个，同一事务中后面的所有 select 语句都复用这个 read-view 。</li></ul><h1>33.Repeatable Read 解决了幻读问题吗？</h1><p>可重复读（repeatable read）定义： 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</p><p>不过理论上会出现幻读，简单的说幻读指的的当用户读取某一范围的数据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。</p><p><strong>注意在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此， 幻读在“当前读”下才会出现（查询语句添加for update，表示当前读）；</strong></p><p>在 MVCC 并发控制中，读操作可以分为两类: 快照读（<code>Snapshot Read</code>）与当前读 （<code>Current Read</code>）。</p><ul><li>快照读<br>快照读是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本) ，快照读可以使普通的SELECT 读取数据时不用对表数据进行加锁，从而解决了因为对数据库表的加锁而导致的两个如下问题<ol><li>解决了因加锁导致的修改数据时无法对数据读取问题.</li><li>解决了因加锁导致读取数据时无法对数据进行修改的问题.</li></ol></li><li>当前读<br>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的（<code>插入/更新/删除操作，属于当前读，需要加锁</code>   , <code>select for update</code> 为当前读）</li></ul><p>表结构</p><table><thead><tr><th>id</th><th>key</th><th>value</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>假设 select * from where value=1 for update，只在这一行加锁（注意这只是假设），其它行不加锁，那么就会出现如下场景：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/8b7a527b9b804c649088d8f19f0d298a.png" alt="image.png"></p><p>Session A的三次查询Q1-Q3都是select * from where value=1 for update，查询的value=1的所有row。</p><ul><li>T1：Q1只返回一行(1,1,1)；</li><li>T2：session B更新id=0的value为1，此时表t中value=1的数据有两行</li><li>T3：Q2返回两行(0,0,1),(1,1,1)</li><li>T4：session C插入一行(6,6,1)，此时表t中value=1的数据有三行</li><li>T5：Q3返回三行(0,0,1),(1,1,1),(6,6,1)</li><li>T6：session A事物commit。</li></ul><p>其中Q3读到value=1这一样的现象，就称之为幻读，<strong>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行</strong>。</p><p>先对“幻读”做出如下解释：</p><ul><li>要讨论「可重复读」隔离级别的幻读现象，是要建立在「当前读」的情况下，而不是快照读,因为在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。</li></ul><p><strong>Next-key Lock 锁</strong></p><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了 next-key 锁，就是记录锁和间隙锁的组合。</p><ul><li>RecordLock锁：锁定单个行记录的锁。（记录锁，RC、RR隔离级别都支持）</li><li>GapLock锁：间隙锁，锁定索引记录间隙(不包括记录本身)，确保索引记录的间隙不变。（范围锁，RR隔离级别支持）</li><li>Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范围锁，RR隔离级别支持）</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/45e0e29471574cf4b2d271caa8344369.png" alt="image.png"></p><p><strong>总结</strong></p><ul><li>RR隔离级别下间隙锁才有效，RC隔离级别下没有间隙锁；</li><li>RR隔离级别下为了解决“幻读”问题：“快照读”依靠MVCC控制，“当前读”通过间隙锁解决；</li><li>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间；</li><li>间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度。</li></ul><h1>34.请说一下数据库锁的种类？</h1><p><strong>MySQL数据库由于其自身架构的特点,存在多种数据存储引擎, MySQL中不同的存储引擎支持不同的锁机制。</strong></p><ul><li><strong>MyISAM</strong>和<strong>MEMORY</strong>存储引擎采用的表级锁，</li><li><strong>InnoDB</strong>存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。</li><li><strong>BDB</strong>采用的是页面锁，也支持表级锁</li></ul><p><strong>按照数据操作的类型分</strong></p><ul><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ul><p><strong>按照数据操作的粒度分</strong></p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>行级锁： 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><p><strong>按照操作性能可分为乐观锁和悲观锁</strong></p><ul><li>乐观锁：一般的实现方式是对记录数据版本进行比对，在数据更新提交的时候才会进行冲突检测，如果发现冲突了，则提示错误信息。</li><li>悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。</li></ul><h1>35.请说一下共享锁和排他锁？</h1><p><strong>行级锁分为共享锁和排他锁两种。</strong></p><p>行锁的是mysql锁中粒度最小的一种锁，因为锁的粒度很小，所以发生资源争抢的概率也最小，并发性能最大，但是也会造成死锁，每次加锁和释放锁的开销也会变大。</p><p><strong>使用MySQL行级锁的两个前提</strong></p><ul><li>使用 innoDB 引擎</li><li>开启事务 (隔离级别为 <code>Repeatable Read</code>)</li></ul><p><strong>InnoDB行锁的类型</strong></p><ul><li><strong>共享锁</strong>（S）：当事务对数据加上共享锁后, 其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</li><li><strong>排他锁</strong>（X）：如果事务T对数据A加上排他锁后，则其他事务不能再对数据A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</li></ul><p><strong>加锁的方式</strong></p><ul><li>InnoDB引擎默认更新语句，<strong>update,delete,insert 都会自动给涉及到的数据加上排他锁</strong>，select语句默认不会加任何锁类型，如果要加可以使用下面的方式:</li><li>加共享锁（S）：select * from table_name where … <strong>lock in share mode</strong>;</li><li>加排他锁（x）：select * from table_name where … <strong>for update</strong>;</li></ul><p><strong>锁兼容</strong></p><ul><li>共享锁只能兼容共享锁, 不兼容排它锁</li><li>排它锁互斥共享锁和其它排它锁</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/8c5348a34dad4631a3113a75b7b6fcf5.png" alt="image.png"></p><h1>36.InnoDB 的行锁是怎么实现的？</h1><p>I<strong>nnoDB行锁是通过对索引数据页上的记录加锁实现的</strong>，主要实现算法有 3 种：Record Lock、Gap Lock 和 Next-key Lock。</p><ul><li><strong>RecordLock锁：锁定单个行记录的锁。（记录锁，RC、RR隔离级别都支持）</strong></li><li><strong>GapLock锁：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支持）</strong></li><li><strong>Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范围锁，RR隔离级别支持）</strong></li></ul><blockquote><p>注意： InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</p></blockquote><p><strong>在RR隔离级别，InnoDB对于记录加锁行为都是先采用Next-Key Lock，但是当SQL操作含有唯一索引时，Innodb会对Next-Key Lock进行优化，降级为RecordLock，仅锁住索引本身而非范围。</strong></p><p>各种操作加锁的特点</p><p>1）select … from 语句：InnoDB引擎采用MVCC机制实现非阻塞读，所以对于普通的select语句，InnoDB不加锁</p><p>2）select … from lock in share mode语句：追加了共享锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降级为RecordLock锁。</p><p>3）select … from for update语句：追加了排他锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降级为RecordLock锁。</p><p>4）update … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降级为RecordLock锁。</p><p>5）delete … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降级为RecordLock锁。</p><p>6）insert语句：InnoDB会在将要插入的那一行设置一个排他的RecordLock锁。</p><p><strong>下面以“update t1 set name=‘lisi’ where id=10”操作为例，举例子分析下 InnoDB 对不同索引的加锁行为，以RR隔离级别为例。</strong></p><ol><li><p>主键加锁</p><p>加锁行为：仅在id=10的主键索引记录上加X锁。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/beb8ed434aa349e789b59c553a9030bc.png" alt="image.png"></p></li><li><p>唯一键加锁</p><p>加锁行为：现在唯一索引id上加X锁，然后在id=10的主键索引记录上加X锁。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/f0787ff46f15443f9e7d14b8a50ee784.png" alt="image.png"></p></li><li><p>非唯一键加锁</p><p>加锁行为：对满足id=10条件的记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)-(11,f)范围分别加Gap Lock。</p></li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/ea4aeac3a77a45488d8f1227e9f83d05.png" alt="image.png"></p><ol start="4"><li><p>无索引加锁</p><p>加锁行为：表里所有行和间隙都会加X锁。（当没有索引时，会导致全表锁定，因为InnoDB引擎锁机制是基于索引实现的记录锁定）。</p></li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/8b90b13b82a44cd9a013596c04f5e3f9.png" alt="image.png"></p><h1>37.并发事务会产生哪些问题</h1><p>事务并发处理可能会带来一些问题，如下：</p><ul><li>更新丢失<br>当两个或多个事务更新同一行记录，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。<ul><li>回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。</li><li>提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。</li></ul></li><li>脏读<br>一个事务读取到了另一个事务修改但未提交的数据。</li><li>不可重复读<br>一个事务中多次读取同一行记录不一致，后面读取的跟前面读取的不一致。</li><li>幻读<br>一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了几行记录。</li></ul><p>“更新丢失”、”脏读”、“不可重复读”和“幻读”等并发事务问题，其实都是数据库一致性问题，为了解决这些问题，MySQL数据库是通过事务隔离级别来解决的，数据库系统提供了以下 4 种事务隔离级别供用户选择。</p><p>![](file:///Users/congqing/Downloads/%2002_%E6%8E%88%E8%AF%BE%E8%B5%84%E6%96%99/MySQL/MySQL%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/images/mysql-2-2.png?lastModify=1673086096)<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/6950c072d1a743a5934510ccbe06e3ec.png" alt="image.png"></p><ul><li><strong>读未提交</strong><br>Read Uncommitted 读未提交：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象，也就是可能读取到其他会话中未提交事务修改的数据。</li><li><strong>已提交读</strong><br>Read Committed 读已提交：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生不可重复读现象，也就是可能在一个事务中两次查询结果不一致。</li><li><strong>可重复度</strong><br>Repeatable Read 可重复读：解决了不可重复读，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上会出现幻读，简单的说幻读指的的当用户读取某一范围的数据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。</li><li><strong>可串行化</strong><br>所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下。</li></ul><p>数据库的事务隔离级别越高，并发问题就越小，但是并发处理能力越差（代价）。读未提交隔离级别最低，并发问题多，但是并发处理能力好。以后使用时，可以根据系统特点来选择一个合适的隔离级别，比如对不可重复读和幻读并不敏感，更多关心数据库并发处理能力，此时可以使用Read Commited隔离级别。</p><p>事务隔离级别，针对Innodb引擎，支持事务的功能。像MyISAM引擎没有关系。</p><p><strong>事务隔离级别和锁的关系</strong></p><p>1）事务隔离级别是SQL92定制的标准，相当于事务并发控制的整体解决方案，本质上是对锁和MVCC使用的封装，隐藏了底层细节。</p><p>2）锁是数据库实现并发控制的基础，事务隔离性是采用锁来实现，对相应操作加不同的锁，就可以防止其他事务同时对数据进行读写操作。</p><p>3）对用户来讲，首先选择使用隔离级别，当选用的隔离级别不能解决并发问题或需求时，才有必要在开发中手动的设置锁。</p><p>MySQL默认隔离级别：可重复读</p><p>Oracle、SQLServer默认隔离级别：读已提交</p><p>一般使用时，建议采用默认隔离级别，然后存在的一些并发问题，可以通过悲观锁、乐观锁等实现处理。</p><h1>38.说一下MVCC内部细节</h1><p><strong>MVCC概念</strong></p><p>MVCC（Multi Version Concurrency Control）被称为多版本并发控制，是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。</p><blockquote><p>MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极大的提升系统的并发性能，这也是为什么现阶段几乎所有的关系型数据库都支持 MVCC 的原因，不过目前MVCC只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。</p></blockquote><p>回答这个面试题时，主要介绍以下的几个关键内容：</p><p><strong>1）行记录的三个隐藏字段</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/0f0c75f07cf5455c9f406e5b5ea6489c.png" alt="image.png"></p><ul><li><code>DB_ROW_ID</code> : 如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键。</li><li><code>DB_TRX_ID</code> : 事务中对某条记录做增删改时,就会将这个事务的事务ID写入到trx_id中.</li><li><code>DB_ROLL_PTR</code>: 回滚指针,指向undo log的指针</li></ul><p><strong>2）Undo log 多版本链</strong></p><p>举例：事务 T-100 和 T-120 对表中 id = 1 的数据行做 update 操作，事务 T-130 进行 select 操作，即使 T-100 已经提交修改，三次 select 语句的结果都是“lisi”。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/d5dd8418f3a64bef8aa93bc815176584.png" alt="image.png"></p><ul><li>每一条数据都有多个版本,版本之间通过undo log链条进行连接</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/776f222b82b142e2a219e8dccc828bd3.png" alt="image.png"></p><p><strong>3）ReadView</strong></p><p>Read View是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现.</p><p>Read View简单理解就是对数据在每个时刻的状态拍成照片记录下来。那么之后获取某时刻的数据时就还是原来的照片上的数据，是不会变的.</p><p>Read View中比较重要的字段有4个:</p><ul><li><code>m_ids</code> : 用来表示MySQL中哪些事务正在执行,但是没有提交.</li><li><code>min_trx_id</code>: 就是m_ids里最小的值.</li><li><code>max_trx_id</code> : 下一个要生成的事务id值,也就是最大事务id</li><li><code>creator_trx_id</code>: 就是你这个事务的id</li></ul><p><strong>通过Read View判断记录的某个版本是否可见的方式总结:</strong></p><ul><li>trx_id = creator_trx_id<br>如果被访问版本的trx_id,与readview中的creator_trx_id值相同,表明当前事务在访问自己修改过的记录,该版本可以被当前事务访问.</li><li>trx_id &lt; min_trx_id<br>如果被访问版本的trx_id,小于readview中的min_trx_id值,表明生成该版本的事务在当前事务生成readview前已经提交,该版本可以被当前事务访问.</li><li>trx_id &gt;= max_trx_id<br>如果被访问版本的trx_id,大于或等于readview中的max_trx_id值,表明生成该版本的事务在当前事务生成readview后才开启,该版本不可以被当前事务访问.</li><li>trx_id &gt; min_trx_id &amp;&amp; trx_id &lt; max_trx_id<br>如果被访问版本的trx_id,值在readview的min_trx_id和max_trx_id之间，就需要判断trx_id属性值是不是在m_ids列表中？<ul><li>在：说明创建readview时生成该版本的事务还是活跃的,该版本不可以被访问</li><li>不在：说明创建readview时生成该版本的事务已经被提交,该版本可以被访问</li></ul></li></ul><p><strong>何时生成ReadView快照</strong></p><ul><li>在 <strong>读已提交（Read Committed， 简称RC）</strong> 隔离级别下，<strong>每一次</strong>读取数据前都生成一个ReadVIew。</li><li>在 <strong>可重复读</strong> （Repeatable Read，简称RR）隔离级别下，在一个事务中，只在 <strong>第一次</strong>读取数据前生成一个ReadVIew。</li></ul><p><strong>4）快照读（<code>Snapshot Read</code>）与当前读 （<code>Current Read</code>）</strong></p><p>在 MVCC 并发控制中，读操作可以分为两类: 快照读（<code>Snapshot Read</code>）与当前读 （<code>Current Read</code>）。</p><ul><li>快照读<br>快照读是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本) ，快照读可以使普通的SELECT 读取数据时不用对表数据进行加锁，从而解决了因为对数据库表的加锁而导致的两个如下问题<ol><li>解决了因加锁导致的修改数据时无法对数据读取问题.</li><li>解决了因加锁导致读取数据时无法对数据进行修改的问题.</li></ol></li><li>当前读<br>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的（<code>Update delete insert select ....lock in share mode</code>   , <code>select for update</code> 为当前读）</li></ul><p><strong>总结一下</strong></p><ul><li>并发环境下，写-写操作有加锁解决方案，但为了提高性能，InnoDB存储引擎提供MVCC，目的是为了解决读-写，写-读操作下不加锁仍能安全进行。</li><li>MVCC的过程，本质就是访问版本链，并判断哪个版本可见的过程。该判断算法是通过版本上的trx_id与快照ReadView的若干个信息进行对比。</li><li>快照生成的时机因隔离级别不同，读已提交隔离级别下，每一次读取前都会生成一个快照ReadView；而可重复读则仅在一个事务中，第一次读取前生成一个快照。</li></ul><h1>39.说一下MySQL死锁的原因和处理方法</h1><p><strong>1) 表的死锁</strong></p><p><strong>产生原因:</strong></p><p>用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。</p><p>用户A–》A表（表锁）–》B表（表锁）</p><p>用户B–》B表（表锁）–》A表（表锁）</p><p><strong>解决方案：</strong></p><p>这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。</p><p>仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。</p><p><strong>2) 行级锁死锁</strong></p><p><strong>产生原因1：</strong></p><p>如果在事务中执行了一条没有索引条件的查询，引发全表扫描，把行级锁上升为全表记录锁定（等价于表级锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发生阻塞或死锁。</p><p><strong>解决方案1：</strong></p><p>SQL语句中不要使用太复杂的关联多表的查询；使用explain“执行计划&quot;对SQL语句进行分析，对于有全表扫描和全表锁定的SQL语句，建立相应的索引进行优化。</p><p><strong>产生原因2：</strong></p><ul><li><p>两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/44213d7bf7b34ccbb340fcf6adb1fb98.png" alt="image.png"></p></li></ul><p><strong>产生原因3</strong>：每个事务只有一个SQL,但是有些情况还是会发生死锁.</p><ol><li>事务1,从name索引出发 , 读到的[hdc, 1],  [hdc, 6]均满足条件, 不仅会加name索引上的记录X锁, 而且会加聚簇索引上的记录X锁, 加锁顺序为先[1,hdc,100], 后[6,hdc,10]</li><li>事务2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。</li><li>但是加锁时发现跟事务1的加锁顺序正好相反，两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/02a98ff1858547d79bb11523a6abd225.png" alt="image.png"></p><p><strong>解决方案:</strong> 如上面的原因2和原因3,  对索引加锁顺序的不一致很可能会导致死锁，所以如果可以，尽量以相同的顺序来访问索引记录和表。在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能；</p><h1>40.介绍一下MySQL的体系架构？</h1><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/bfe09e96eb434e98a1f5870ba779d576.png" alt="image.png"></p><p><strong>MySQL Server架构自顶向下大致可以分网络连接层、服务层、存储引擎层和系统文件层。</strong></p><p><strong>一、网络连接层</strong></p><ul><li><strong>客户端连接器（Client Connectors）：提供与MySQL服务器建立的支持。目前几乎支持所有主流的服务端编程技术，例如常见的 Java、C、Python、.NET等，它们通过各自API技术与MySQL建立连接。</strong></li></ul><p><strong>二、服务层（MySQL Server）</strong></p><p><strong>服务层是MySQL Server的核心，主要包含系统管理和控制工具、连接池、SQL接口、解析器、查询优化器和缓存六个部分。</strong></p><ul><li><p><strong>连接池（Connection Pool）</strong>：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接。</p></li><li><p><strong>系统管理和控制工具（Management Services &amp; Utilities）</strong>：例如备份恢复、安全管理、集群管理等</p></li><li><p><strong>SQL接口（SQL Interface）</strong>：用于接受客户端发送的各种SQL命令，并且返回用户需要查询的结果。比如DML、DDL、存储过程、视图、触发器等。</p></li><li><p><strong>解析器（Parser）</strong>：负责将请求的SQL解析生成一个&quot;解析树&quot;。然后根据一些MySQL规则进一步检查解析树是否合法。</p></li><li><p><strong>查询优化器（Optimizer）</strong>：当“解析树”通过解析器语法检查后，将交由优化器将其转化成执行计划，然后与存储引擎交互。</p><blockquote><p><strong>select uid,name from user where gender=1;</strong></p><p><strong>选取–》投影–》联接 策略</strong></p><p><strong>1）select先根据where语句进行选取，并不是查询出全部数据再过滤</strong></p><p><strong>2）select查询根据uid和name进行属性投影，并不是取出所有字段</strong></p><p><strong>3）将前面选取和投影联接起来最终生成查询结果</strong></p></blockquote></li><li><p><strong>缓存（Cache&amp;Buffer）</strong>： 缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，权限缓存，引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</p></li></ul><p><strong>三、存储引擎层（Pluggable Storage Engines）</strong></p><p><strong>存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。MySQL存储引擎是插件式的，服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异 。现在有很多种存储引擎，各有各的特点，最常见的是MyISAM和InnoDB。</strong></p><p><strong>四、系统文件层（File System）</strong></p><p><strong>该层负责将数据库的数据和日志存储在文件系统之上，并完成与存储引擎的交互，是文件的物理存储层。主要包含日志文件，数据文件，配置文件，pid 文件，socket 文件等。</strong></p><ul><li><strong>日志文件</strong><ul><li><strong>错误日志（Error log）</strong><br><strong>默认开启，show variables like ‘%log_error%’</strong></li><li><strong>通用查询日志（General query log）</strong><br><strong>记录一般查询语句，show variables like ‘%general%’;</strong></li><li><strong>二进制日志（binary log）</strong><br><strong>记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长；但是它不记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。</strong><br><strong>show variables like ‘%log_bin%’; //是否开启</strong><br><strong>show variables like ‘%binlog%’; //参数查看</strong><br><strong>show binary logs;//查看日志文件</strong></li><li><strong>慢查询日志（Slow query log）</strong><br><strong>记录所有执行时间超时的查询SQL，默认是10秒。</strong><br><strong>show variables like ‘%slow_query%’; //是否开启</strong><br><strong>show variables like ‘%long_query_time%’; //时长</strong></li></ul></li><li><strong>配置文件</strong><br><strong>用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等。</strong></li><li><strong>数据文件</strong><ul><li><strong>db.opt 文件：记录这个库的默认使用的字符集和校验规则。</strong></li><li><strong>frm 文件：存储与表相关的元数据（meta）信息，包括表结构的定义信息等，每一张表都会有一个frm 文件。</strong></li><li><strong>MYD 文件：MyISAM 存储引擎专用，存放 MyISAM 表的数据（data)，每一张表都会有一个 .MYD 文件。</strong></li><li><strong>MYI 文件：MyISAM 存储引擎专用，存放 MyISAM 表的索引相关信息，每一张 MyISAM 表对应一个 .MYI 文件。</strong></li><li><strong>ibd文件和 IBDATA 文件：存放 InnoDB 的数据文件（包括索引）。InnoDB 存储引擎有两种表空间方式：独享表空间和共享表空间。独享表空间使用 .ibd 文件来存放数据，且每一张 InnoDB 表对应一个 .ibd 文件。共享表空间使用 .ibdata 文件，所有表共同使用一个（或多个，自行配置）.ibdata 文件。</strong></li><li><strong>ibdata1 文件：系统表空间数据文件，存储表元数据、Undo日志等 。</strong></li><li><strong>ib_logfile0、ib_logfile1 文件：Redo log 日志文件。</strong></li></ul></li><li><strong>pid 文件</strong><br><strong>pid 文件是 mysqld 应用程序在 Unix/Linux 环境下的一个进程文件，和许多其他 Unix/Linux 服务端程序一样，它存放着自己的进程 id。</strong></li><li><strong>socket 文件</strong><br><strong>socket 文件也是在 Unix/Linux 环境下才有的，用户在 Unix/Linux 环境下客户端连接可以不通过 TCP/IP 网络而直接使用 Unix Socket 来连接 MySQL。</strong></li></ul><h1>41.undo log、redo log、 bin log的作用是什么？</h1><p><strong>undo log 基本概念</strong></p><ul><li>undo log是一种用于撤销回退的日志，在数据库事务开始之前，MySQL会先记录更新前的数据到 undo log日志文件里面，当事务回滚时或者数据库崩溃时，可以利用 undo log来进行回退。</li><li>Undo Log产生和销毁：Undo Log在事务开始前产生；事务在提交时，并不会立刻删除undo log，innodb会将该事务对应的undo log放入到删除列表中，后面会通过后台线程purge thread进行回收处理。</li></ul><p><strong>注意: undo log也会产生redo log，因为undo log也要实现持久性保护。</strong></p><p><strong>undo log的作用</strong></p><ol><li><strong>提供回滚操作【undo log实现事务的原子性】</strong><br>在数据修改的时候，不仅记录了redo log，还记录了相对应的undo log，如果因为某些原因导致事务执行失败了，可以借助undo log进行回滚。<br><em>undo log 和 redo log 记录物理日志不一样，它是</em>逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</li><li><strong>提供多版本控制(MVCC)【<em>undo log实现多版本并发控制（MVCC）</em>】</strong><br>MVCC，即多版本控制。在MySQL数据库InnoDB存储引擎中，用undo Log来实现多版本并发控制(MVCC)。当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据版本是怎样的，从而让用户能够读取到当前事务操作之前的数据【快照读】。</li></ol><p><strong>redo log 基本概念</strong></p><ul><li>InnoDB引擎对数据的更新，是先将更新记录写入redo log日志，然后会在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的预写式技术（Write Ahead logging）。这种技术可以大大减少IO操作的频率，提升数据刷新的效率。</li><li>redo log：被称作重做日志, 包括两部分：一个是内存中的日志缓冲： <code>redo log buffer</code>，另一个是磁盘上的日志文件： <code>redo log file</code> 。</li></ul><p><strong>redo log的作用</strong></p><ul><li>mysql 每执行一条 DML 语句，先将记录写入 redo log buffer 。后续某个时间点再一次性将多个操作记录写到 redo log file 。当故障发生致使内存数据丢失后，InnoDB会在重启时，经过重放 redo，将Page恢复到崩溃之前的状态 <strong>通过Redo log可以实现事务的持久性 。</strong></li></ul><p><strong>bin log基本概念</strong></p><ul><li>binlog是一个二进制格式的文件，用于记录用户对数据库更新的SQL语句信息，例如更改数据库表和更改内容的SQL语句都会记录到binlog里，但是不会记录SELECT和SHOW这类操作。</li><li>binlog在MySQL的Server层实现(引擎共用)</li><li>binlog为逻辑日志,记录的是一条SQL语句的原始逻辑<ul><li>binlog不限制大小,追加写入,不会覆盖以前的日志.</li><li>默认情况下，binlog日志是二进制格式的，不能使用查看文本工具的命令（比如，cat，vi等）查看，而使用mysqlbinlog解析查看。</li></ul></li></ul><p><strong>bin log的作用</strong></p><ol><li>主从复制：在主库中开启Binlog功能，这样主库就可以把Binlog传递给从库，从库拿到Binlog后实现数据恢复达到主从数据一致性。</li><li>数据恢复：通过mysqlbinlog工具来恢复数据。</li></ol><h1>42.redo log与undo log的持久化策略？</h1><p><strong>redo log持久化</strong></p><p>缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统缓冲区( OS Buffer )。因此， redo log buffer 写入 redo logfile 实际上是先写入 OS Buffer，然后再通过系统调用 fsync() 将其刷到 redo log file.</p><p>Redo Buffer 持久化到 redo log 的策略，可通过 <code>Innodb_flush_log_at_trx_commit</code> 设置：</p><table><thead><tr><th><strong>参数值</strong></th><th>含义</th></tr></thead><tbody><tr><td>0 (延迟写)</td><td>事务提交时不会将 <code>redo log buffer</code>中日志写入到 <code>os buffer</code>， 而是每秒写入 <code>os buffer</code>并调用 <code>fsync()</code>写入到 <code>redo log file</code>中。 也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</td></tr><tr><td>1  (实时写,实时刷)</td><td>事务每次提交都会将 <code>redo log buffer</code>中的日志写入 <code>os buffer</code>并 调用 <code>fsync()</code>刷到 <code>redo log file</code>中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</td></tr><tr><td>2 (实时写, 延时刷)</td><td>每次提交都仅写入到 <code>os buffer</code>，然后是每秒调用 <code>fsync()</code>将 <code>os buffer</code>中的日志写入到 <code>redo log file</code>。</td></tr></tbody></table><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/b6fcf484cec943ba99ef0780844c79d2.png" alt="image.png"></p><p>一般建议选择取值2，因为 MySQL 挂了数据没有损失，整个服务器挂了才会损失1秒的事务提交数据</p><p><strong>undo log持久化</strong></p><p>MySQL中的Undo Log严格的讲不是Log，而是数据，因此他的管理和落盘都跟数据是一样的：</p><ul><li>Undo的磁盘结构并不是顺序的，而是像数据一样按Page管理</li><li>Undo写入时，也像数据一样产生对应的Redo Log (因为undo也是对页面的修改，记录undo这个操作本身也会有对应的redo)。</li><li>Undo的Page也像数据一样缓存在Buffer Pool中，跟数据Page一起做LRU换入换出，以及刷脏。Undo Page的刷脏也像数据一样要等到对应的Redo Log 落盘之后</li></ul><p>当事务提交的时候，innodb不会立即删除undo log，因为后续还可能会用到undo log，如隔离级别为repeatable read时，事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除，即undo log不能删除。</p><p>但是在事务提交的时候，会将该事务对应的undo log放入到删除列表中，未来通过purge来删除。并且提交事务时，还会判断undo log分配的页是否可以重用，如果可以重用，则会分配给后面来的事务，避免为每个独立的事务分配独立的undo log页而浪费存储空间和性能。</p><h1>43.bin log与undo log的区别？</h1><p><strong>1）redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</strong></p><p><strong>2）redo log是物理日志，记录的是“在XXX数据页上做了XXX修改”；binlog是逻辑日志，记录的是原始逻辑，其记录是对应的SQL语句。</strong></p><ul><li>物理日志: 记录的是每一个page页中具体存储的值是多少，在这个数据页上做了什么修改.  比如: 某个事物将系统表空间中的第100个页面中偏移量为1000处的那个字节的值1改为2.</li><li>逻辑日志: 记录的是每一个page页面中具体数据是怎么变动的，它会记录一个变动的过程或SQL语句的逻辑, 比如: 把一个page页中的一个数据从1改为2，再从2改为3,逻辑日志就会记录1-&gt;2,2-&gt;3这个数据变化的过程.</li></ul><p><strong>3）redo log是循环写的，空间一定会用完，需要write pos和check point搭配；binlog是追加写，写到一定大小会切换到下一个，并不会覆盖以前的日志</strong></p><ul><li>Redo Log 文件内容是以顺序循环的方式写入文件，写满时则回溯到第一个文件，进行覆盖写。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/70fa5785c2044d038e1e6d04b553028d.png" alt="image.png"></p><ul><li><strong>write pos</strong>: 表示日志当前记录的位置，当ib_logfile_4写满后，会从ib_logfile_1从头开始记录；</li><li><strong>check point</strong>: 表示将日志记录的修改写进磁盘，完成数据落盘，数据落盘后checkpoint会将日志上的相关记录擦除掉，即 <code>write pos -&gt; checkpoint</code>  之间的部分是redo log空着的部分，用于记录新的记录，<code>checkpoint -&gt; write pos</code> 之间是redo log 待落盘的数据修改记录</li><li>如果 write pos 追上 checkpoint，表示写满，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</li></ul><p><strong>3）Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力</strong></p><p>CrashSafe指MySQL服务器宕机重启后，能够保证：</p><ul><li>所有已经提交的事务的数据仍然存在。</li><li>所有没有提交的事务的数据自动回滚。</li></ul><h1>44.MySQL的binlog有几种日志格式？分别有什么区别？</h1><p>binlog日志有三种模式</p><p>1）ROW（row-based replication, RBR）：日志中会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。</p><ul><li>优点：能清楚记录每一个行数据的修改细节，能完全实现主从数据同步和数据的恢复。而且不会出现某些特定情况下存储过程或function无法被正确复制的问题。</li><li>缺点：批量操作，会产生大量的日志，尤其是alter table会让日志量暴涨。</li></ul><p>2）STATMENT（statement-based replication, SBR）：记录每一条修改数据的SQL语句（批量修改时，记录的不是单条SQL语句，而是批量修改的SQL语句事件）, slave在复制的时候SQL进程会解析成和原来master端执行过的相同的SQL再次执行。简称SQL语句复制。</p><ul><li>优点：日志量小，减少磁盘IO，提升存储和恢复速度</li><li>缺点：在某些情况下会导致主从数据不一致，比如last_insert_id()、now()等函数。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/b8e6f4dcef054331b143f57c748d9c58.png" alt="image.png"></p><p>3）MIXED（mixed-based replication, MBR）：以上两种模式的混合使用，一般会使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择写入模式。</p><p>企业场景如何选择binlog的模式</p><ol><li>如果生产中使用MySQL的特殊功能相对少（存储过程、触发器、函数）。选择默认的语句模式，Statement。</li><li>如果生产中使用MySQL的特殊功能较多的，可以选择Mixed模式。</li><li>如果生产中使用MySQL的特殊功能较多，又希望数据最大化一致，此时最好Row 模式；但是要注意，该模式的binlog日志量增长非常快.</li></ol><h1>45.mysql 线上修改大表结构有哪些风险？</h1><p>在线修改大表的可能影响</p><ul><li>在线修改大表的表结构执行时间往往不可预估，一般时间较长。</li><li>由于修改表结构是表级锁，因此在修改表结构时，影响表写入操作。</li><li>如果长时间的修改表结构，中途修改失败，由于修改表结构是一个事务，因此失败后会还原表结构，在这个过程中表都是锁着不可写入。</li><li>修改大表结构容易导致数据库CPU、IO等性能消耗，使MySQL服务器性能降低。</li><li>在线修改大表结构容易导致主从延时，从而影响业务读取。</li></ul><p>修改方式：</p><ol><li>对表加锁(表此时只读)</li><li>复制原表物理结构</li><li>修改表的物理结构</li><li>把原表数据导入中间表中 ，数据同步完后，**锁定中间表，并删除原表</li><li>rename中间表为原表</li><li>刷新数据字典，并释放锁</li></ol><p>使用工具： <strong>online-schema-change</strong> ，是percona推出的一个针对mysql在线ddl的工具。percona是一个mysql分支维护公司，专门提供mysql技术服务的。</p><h1>46.count(列名)、count(1)和 count(*)有什么区别?</h1><p><strong>进行统计操作时,count中的统计条件可以三种选择:</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(*) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(列名) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>执行效果上：</p><ul><li>count(*) 包括了所有的列,在统计时 不会忽略列值为null的数据。</li><li>count(1) 用1表示代码行,在统计时,不会忽略列值为null的数据。</li><li>count(列名)在统计时,会忽略列值为空的数据,就是说某个字段的值为null时不统计。</li></ul><p>执行效率上：</p><ul><li>InnoDB引擎：count（字段) &lt; count(1) = count(*)<ul><li>InnoDB通过遍历最小的可用二级索引来处理select count(*) 语句，除非索引或优化器提示指示优化器使用不同的索引。如果二级索引不存在，则通过扫描聚集索引来处理。</li><li>InnoDB已同样的方式处理count(1)和count(*)</li></ul></li><li>MyISAM引擎：count（字段) &lt; count(1) &lt;= count(*)<ul><li>MyISAM存储了数据的准确行数，使用 <code>count(*)</code>会直接读取该行数， 只有当第一列定义为NOT NULL时，count（1），才会执行该操作，所以优先选择 <code>count(*)</code></li></ul></li><li>count(列名) 会遍历整个表，但不同的是，它会先获取列，然后判断是否为空，然后累加，因此count(列名)性能不如前两者。</li></ul><p>注意：count(*)，这是SQL92 定义的标准统计行数的语法，跟数据库无关，与NULL也无关。而count(列名) 是统计列值数量，不计NULL，相同列值算一个。</p><h1>47.什么是分库分表？什么时候进行分库分表？</h1><p><strong>什么是分库分表</strong></p><p>简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1597204636882698240/351672652c6a4a1bb6e648f75651d730.png" alt="image.png"></p><ul><li><p>分库分表解决的问题</p><p><strong>分库分表的目的是为了解决由于数据量过大而导致数据库性能降低的问题，将原来单体服务的数据库进行拆分.将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</strong></p></li><li><p>什么情况下需要分库分表</p><ul><li><strong>单机存储容量遇到瓶颈.</strong></li><li><strong>连接数,处理能力达到上限.</strong></li></ul></li></ul><blockquote><p>注意:</p><p>分库分表之前,要根据项目的实际情况 确定我们的数据量是不是够大,并发量是不是够大,来决定是否分库分表.</p><p>数据量不够就不要分表,单表数据量超过1000万或100G的时候, 速度就会变慢(官方测试),</p></blockquote><p>分库分表包括： 垂直分库、垂直分表、水平分库、水平分表 四种方式。</p><p><strong>垂直分库</strong></p><ul><li><p>数据库中不同的表对应着不同的业务，垂直切分是指按照业务的不同将表进行分类,分布到不同的数据库上面</p><ul><li>将数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1597204636882698240/dcbbe3674442421c967fe8541f28b6b0.png" alt="image.png"></p></li></ul><p><strong>垂直分表</strong></p><p>表中字段太多且包含大字段的时候，在查询时对数据库的IO、内存会受到影响，同时更新数据时，产生的binlog文件会很大，MySQL在主从同步时也会有延迟的风险</p><ul><li>将一个表按照字段分成多表，每个表存储其中一部分字段。</li><li>对职位表进行垂直拆分, 将职位基本信息放在一张表, 将职位描述信息存放在另一张表</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1597204636882698240/d401ca741da24ac782d6356a38e20311.png" alt="image.png"></p><ul><li>垂直拆分带来的一些提升<ul><li>解决业务层面的耦合，业务清晰</li><li>能对不同业务的数据进行分级管理、维护、监控、扩展等</li><li>高并发场景下，垂直分库一定程度的提高访问性能</li></ul></li><li>垂直拆分没有彻底解决单表数据量过大的问题</li></ul><p><strong>水平分库</strong></p><ul><li><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈.</p></li><li><p>简单讲就是根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面, 例如将订单表 按照id是奇数还是偶数, 分别存储在不同的库中。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1597204636882698240/ce46a9c5ae894a6da70a4ee5b72df1f2.png" alt="image.png"></p></li></ul><p><strong>水平分表</strong></p><ul><li><p>针对数据量巨大的单张表（比如订单表），按照规则把一张表的数据切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1597204636882698240/307c531d662c484f9d68d249eb48620d.png" alt="image.png"></p></li><li><p>总结</p><ul><li><strong>垂直分表</strong>: 将一个表按照字段分成多表，每个表存储其中一部分字段。</li><li><strong>垂直分库</strong>: 根据表的业务不同,分别存放在不同的库中,这些库分别部署在不同的服务器.</li><li><strong>水平分库</strong>: 把一张表的数据按照一定规则,分配到<strong>不同的数据库</strong>,每一个库只有这张表的部分数据.</li><li><strong>水平分表</strong>: 把一张表的数据按照一定规则,分配到<strong>同一个数据库的多张表中</strong>,每个表只有这个表的部分数据.</li></ul></li></ul><h1>48.说说 MySQL 的主从复制？</h1><p><strong>主从复制的用途</strong></p><ul><li>实时灾备，用于故障切换</li><li>读写分离，提供查询服务</li><li>备份，避免影响业务</li></ul><p><strong>主从部署必要条件</strong></p><ul><li>主库开启binlog日志（设置log-bin参数）</li><li>主从server-id不同</li><li>从库服务器能连通主库</li></ul><p><strong>主从复制的原理</strong></p><ul><li>Mysql 中有一种日志叫做 bin 日志（二进制日志）。这个日志会记录下所有修改了数据库的SQL 语句（insert,update,delete,create/alter/drop table, grant 等等）。</li><li>主从复制的原理其实就是把主服务器上的 bin 日志复制到从服务器上执行一遍，这样从服务器上的数据就和主服务器上的数据相同了。</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1597204636882698240/c0327525e85b4d098b0369093290b898.png" alt="image.png"></p><ol><li>主库db的更新事件(update、insert、delete)被写到binlog</li><li>主库创建一个binlog dump thread，把binlog的内容发送到从库</li><li>从库启动并发起连接，连接到主库</li><li>从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</li><li>从库启动之后，创建一个SQL线程，从relay log里面读取内容，执行读取到的更新事件，将更新内容写入到slave的db</li></ol><h1>49. 说一下 MySQL 执行一条查询语句的内部执行过程？</h1><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672984425088/a2d06073396b4f5b8e0ed33531e8706e.png" alt="image.png"></p><ul><li><p>①建立连接（Connectors&amp;Connection Pool），通过客户端/服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么。<br>通讯机制：</p><ul><li>全双工：能同时发送和接收数据，例如平时打电话。</li><li>半双工：指的某一时刻，要么发送数据，要么接收数据，不能同时。例如早期对讲机</li><li>单工：只能发送数据或只能接收数据。例如单行道</li></ul><p>线程状态：<br>show processlist; //查看用户正在运行的线程信息，root用户能查看所有线程，其他用户只能看自己的</p><ul><li>id：线程ID，可以使用kill xx；</li><li>user：启动这个线程的用户</li><li>Host：发送请求的客户端的IP和端口号</li><li>db：当前命令在哪个库执行</li><li>Command：该线程正在执行的操作命令<ul><li>Create DB：正在创建库操作</li><li>Drop DB：正在删除库操作</li><li>Execute：正在执行一个PreparedStatement</li><li>Close Stmt：正在关闭一个PreparedStatement</li><li>Query：正在执行一个语句</li><li>Sleep：正在等待客户端发送语句</li><li>Quit：正在退出</li><li>Shutdown：正在关闭服务器</li></ul></li><li>Time：表示该线程处于当前状态的时间，单位是秒</li><li>State：线程状态<ul><li>Updating：正在搜索匹配记录，进行修改</li><li>Sleeping：正在等待客户端发送新请求</li><li>Starting：正在执行请求处理</li><li>Checking table：正在检查数据表</li><li>Closing table : 正在将表中数据刷新到磁盘中</li><li>Locked：被其他查询锁住了记录</li><li>Sending Data：正在处理Select查询，同时将结果发送给客户端</li></ul></li><li>Info：一般记录线程执行的语句，默认显示前100个字符。想查看完整的使用show full processlist;</li></ul></li><li><p>②查询缓存（Cache&amp;Buffer），这是MySQL的一个可优化查询的地方，如果开启了查询缓存且在查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；如果没有开启查询缓存或者没有查询到完全相同的 SQL 语句则会由解析器进行语法语义解析，并生成“解析树”。</p><ul><li>缓存Select查询的结果和SQL语句</li><li>执行Select查询时，先查询缓存，判断是否存在可用的记录集，要求是否完全相同（包括参数值），这样才会匹配缓存数据命中。</li><li>即使开启查询缓存，以下SQL也不能缓存<ul><li>查询语句使用SQL_NO_CACHE</li><li>查询的结果大于query_cache_limit设置</li><li>查询中有一些不确定的参数，比如now()</li></ul></li><li>show variables like ‘%query_cache%’; //查看查询缓存是否启用，空间大小，限制等</li><li>show status like ‘Qcache%’; //查看更详细的缓存参数，可用缓存空间，缓存块，缓存多少等</li></ul></li><li><p>③解析器（Parser）将客户端发送的SQL进行语法解析，生成&quot;解析树&quot;。预处理器根据一些MySQL规则进一步检查“解析树”是否合法，例如这里将检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义，最后生成新的“解析树”。</p></li><li><p>④查询优化器（Optimizer）根据“解析树”生成最优的执行计划。MySQL使用很多优化策略生成最优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）。</p><ul><li>等价变换策略<ul><li>5=5 and a&gt;5 改成 a &gt; 5</li><li>a &lt; b and a=5 改成b&gt;5 and a=5</li><li>基于联合索引，调整条件位置等</li></ul></li><li>优化count、min、max等函数<ul><li>InnoDB引擎min函数只需要找索引最左边</li><li>InnoDB引擎max函数只需要找索引最右边</li><li>MyISAM引擎count(*)，不需要计算，直接返回</li></ul></li><li>提前终止查询<ul><li>使用了limit查询，获取limit所需的数据，就不在继续遍历后面数据</li></ul></li><li>in的优化<ul><li>MySQL对in查询，会先进行排序，再采用二分法查找数据。比如where id in (2,1,3)，变成 in (1,2,3)</li></ul></li></ul></li><li><p>⑤查询执行引擎负责执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以及对应的API接口与底层存储引擎缓存或者物理文件的交互，得到查询结果并返回给客户端。若开启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存（Cache&amp;Buffer）中，以后若有相同的 SQL 语句执行则直接返回结果。</p><ul><li>如果开启了查询缓存，先将查询结果做缓存操作</li><li>返回结果过多，采用增量模式返回</li></ul></li></ul><h1>50.Mysql内部支持缓存查询吗？</h1><p>使用缓存的好处：当MySQL接收到客户端的查询SQL之后，仅仅只需要对其进行相应的权限验证之后，就会通过Query Cache来查找结果，甚至都不需要经过Optimizer模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互.</p><p>mysql5.7支持内部缓存，8.0之后已废弃</p><p>mysql缓存的限制</p><ol><li>mysql基本没有手段灵活的管理缓存失效和生效，尤其对于频繁更新的表</li><li>SQL必须完全一致才会导致cache命中</li><li>为了节省内存空间，太大的result set不会被cache (&lt; query_cache_limit)；</li><li>MySQL缓存在分库分表环境下是不起作用的；</li><li>执行SQL里有触发器,自定义函数时，MySQL缓存也是不起作用的；</li><li>在表的结构或数据发生改变时，基于该表相关cache立即全部失效。</li></ol><p>替代方案</p><ul><li>应用层组织缓存，最简单的是使用redis，ehcached等</li></ul>]]></content>
    
    
    <summary type="html">🍔本文汇总MySQL常问面试题</summary>
    
    
    
    <category term="面试" scheme="https://momoao.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="MySQL" scheme="https://momoao.github.io/tags/MySQL/"/>
    
    <category term="面试题" scheme="https://momoao.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式面试题</title>
    <link href="https://momoao.github.io/posts/202309131058.html"/>
    <id>https://momoao.github.io/posts/202309131058.html</id>
    <published>2023-09-13T07:27:00.000Z</published>
    <updated>2023-09-13T02:59:23.949Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>参考：内容来自图灵教育</p></div><h1>1.说一下开发中需要遵守的设计原则？</h1><p><strong>设计模式中主要有六大设计原则，简称为SOLID ，是由于各个原则的首字母简称合并的来(两个L算一个,solid 稳定的)，六大设计原则分别如下：</strong></p><p><strong>1、单一职责原则</strong></p><p>单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也就是说在类的设计中 我们不要设计大而全的类,而是要设计粒度小、功能单一的类。</p><blockquote><p>比如 我们设计一个类里面既包含了用户的一些操作,又包含了支付的一些操作,那这个类的职责就不够单一,应该将该类进行拆分,拆分成多个功能更加单一的,粒度更细的类.</p></blockquote><p><strong>2、开放封闭原则</strong></p><p>定义：对扩展开放，对修改关闭</p><p>对扩展开放和对修改关闭表示当一个类或一个方法有新需求或者需求发生改变时应该采用扩展的方式而不应该采用修改原有逻辑的方式来实现。因为扩展了新的逻辑如果有问题只会影响新的业务，不会影响老业务；而如果采用修改的方式，很有可能就会影响到老业务受影响。</p><p>优点：</p><ol><li>新老逻辑解耦，需求发生改变不会影响老业务的逻辑</li><li>改动成本最小，只需要追加新逻辑，不需要改的老逻辑</li><li>提供代码的稳定性和可扩展性</li></ol><p><strong>3、里氏替换原则</strong></p><p>要理解里氏替换原则，其实就是要理解两个问题：</p><ul><li>什么是替换？</li><li>什么是与期望行为一致的替换（Robert Martin所说的“必须能够替换”）？</li></ul><p>1 ) 什么是替换 ?</p><p>替换的前提是面向对象语言所支持的多态特性，同一个行为具有多个不同表现形式或形态的能力。</p><blockquote><p><strong>以JDK的集合框架为例，</strong><code>List</code>接口的定义为有序集合，<code>List</code>接口有多个派生类，比如大家耳熟能详的 <code>ArrayList</code>, <code>LinkedList</code>。那当某个方法参数或变量是 <code>List</code>接口类型时，既可以是 <code>ArrayList</code>的实现, 也可以是 <code>LinkedList</code>的实现，这就是替换。</p></blockquote><p>2 ) 什么是与期望行为一致的替换？</p><p>在不了解派生类的情况下，仅通过接口或基类的方法，即可清楚的知道方法的行为，而不管哪种派生类的实现，都与接口或基类方法的期望行为一致。</p><blockquote><p><strong>不需要关心是哪个类对接口进行了实现,因为不管底层如何实现,最终的结果都会符合接口中关于方法的描述(也就是与接口中方法的期望行为一致).</strong></p><p><strong>或者说接口或基类的方法是一种契约，使用方按照这个契约来使用，派生类也按照这个契约来实现。这就是与期望行为一致的替换。</strong></p></blockquote><p><strong>4、接口隔离原则</strong></p><p>定义：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则与单一职责原则的区别</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><p><strong>5、依赖倒置原则</strong></p><p>定义：依赖倒置原则（Dependence Inversion Principle，DIP）是指在设计代码架构时，高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><p>依赖倒置原则的好处:</p><ul><li>减少类间的耦合性，提高系统的稳定性 . (根据类与类之间的耦合度从弱到强排列：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系 )</li><li>降低并行开发引起的风险 (两个类之间有依赖关系，只要制定出两者之间的接口（或抽象类）就可以独立开发了)</li><li>提高代码的可读性和可维护性</li></ul><p><strong>6、迪米特法则</strong></p><p>简单来说迪米特法则想要表达的思想就是:  <strong>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</strong></p><blockquote><p><strong>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</strong></p></blockquote><p><strong>软件开发中我们要基于这六个原则,设计建立稳定、灵活、健壮的程序.</strong></p><h1>2.<strong>什么是设计模式？使用过设计模式吗？</strong></h1><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</p><p>在GOF编写的设计模式(可复用面向对象软件的基础)一书中说道:  本书涉及的设计模式并不描述新的或未经证实的设计，我们只收录那些在不同系统中多次使用过的成功设计。</p><p><strong>大部分设计模式要解决的都是代码的可重用性、可扩展性问题</strong></p><blockquote><p><strong>如果说数据结构和算法是教你如何写出高效代码，那设计模式讲的是如何写出可扩展、可读、可维护的高质量代码，所以，它们跟平时的编码会有直接的关系，也会直接影响到你的开发能力。</strong></p></blockquote><p><strong>设计模式的好处</strong></p><ul><li>不再编写 bullshit-code</li><li>提高复杂代码的设计和开发能力</li><li>有助于我们读懂源码,学习框架更加事半功倍</li></ul><p><strong>GoF设计模式只有23个，但是它们各具特色 ，每个模式都为某一个可重复的设计问题提供了一套解决方案。</strong></p><p><strong>根据它们的用途，设计模式可分为 创建型(Creational) ，结构型(Structural)  和行为型(Behavioral)</strong></p><p>创建型模式(5种)：提供创建对象的机制，提升已有代码的灵活性和可复用性</p><ul><li>常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。</li><li>不常用的有：原型模式。</li></ul><p>结构型模式(7种)：介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效</p><ul><li>常用的有：代理模式、桥接模式、装饰者模式、适配器模式。</li><li>不常用的有：门面模式、组合模式、享元模式。</li></ul><p>行为模式(11种)：负责对象间的高效沟通和职责传递委派</p><ul><li>常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。</li><li>不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</li></ul><h1>3.说一下单例模式，及其应用场景？</h1><p>定义</p><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，此模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为单例类。</p><blockquote><p><strong>单例模式也比较好理解，比如一个人一生当中只能有一个真实的身份证号，一个国家只有一个政府，类似的场景都是属于单例模式。</strong></p></blockquote><p>使用单例模式要做的两件事</p><ol><li>保证一个类只有一个实例</li><li>为该实例提供一个全局访问节点</li></ol><p>单例模式结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672997686010/4cd8bc431f3049e38f0923c0490fb479.png" alt="image.png"></p><p><strong>单例的实现</strong></p><ul><li>饿汉式</li><li>懒汉式</li><li>双重检测</li><li>静态内部类</li><li>枚举方式</li></ul><p><strong>应用场景</strong></p><ul><li>资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。</li><li>控制资源的情况下，方便资源之间的互相通信。如线程池等。</li></ul><h1>4.介绍一下代理模式的种类和它们之间区别？</h1><p><strong>1）静态代理</strong></p><p>这种代理方式需要代理对象和目标对象实现一样的接口。</p><ul><li>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</li><li>缺点：<ol><li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li><li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li></ol></li></ul><p><strong>2）JDK动态代理</strong></p><p>动态代理利用了JDK API,动态地在内存中构建代理对象,从而实现对目标对象的代理功能.动态代理又被称为JDK代理或接口代理.</p><p>静态代理与动态代理的区别:</p><ol><li>静态代理在编译时就已经实现了,编译完成后代理类是一个实际的class文件</li><li>动态代理是在运行时动态生成的,即编译完成后没有实际的class文件,而是在运行时动态生成类字节码,并加载到JVM中.</li></ol><p><strong>3）CGLIB 动态代理</strong></p><p>cglib (Code Generation Library ) 是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。cglib 为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672997686010/c3ca7d140b6c4661a38256b4721324c9.png" alt="image.png"></p><ul><li>最底层是字节码</li><li>ASM是操作字节码的工具</li><li>cglib基于ASM字节码工具操作字节码（即动态生成代理，对方法进行增强）</li><li>SpringAOP基于cglib进行封装，实现cglib方式的动态代理</li></ul><p><strong>4）三种代理模式实现方式的对比</strong></p><ul><li><p>jdk代理和CGLIB代理</p><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p><p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p></li><li><p>动态代理和静态代理</p><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p><p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p></li></ul><h1>5.工厂模式有哪几种，之间有什么区别？</h1><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>《设计模式》一书中，工厂模式被分为了三种：简单工厂、工厂方法和抽象工厂。（不过，在书中作者将简单工厂模式看作是工厂方法模式的一种特例。</p><p><strong>1）简单工厂模式</strong></p><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。简单工厂模式又叫做静态工厂方法模式（static Factory Method pattern）,它是通过使用静态方法接收不同的参数来返回不同的实例对象.</p><p>实现方式: 定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672997686010/040d2d85f6e144bfb383a90f781c10c9.png" alt="image.png"></p><p>适用场景：<br>　　（1）需要创建的对象较少。<br>　　（2）客户端不关心对象的创建过程。</p><p>优点：</p><ul><li>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</li></ul><p>缺点：</p><ul><li>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</li></ul><p><strong>2）工厂方法模式</strong></p><p>工厂方法模式 <code>Factory Method pattern</code>,属于创建型模式.</p><p>概念: 定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672997686010/36732a94d5524e29856dda02f216a0b7.png" alt="image.png"></p><p>工厂方法模优缺点</p><p>优点：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p>缺点：</p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><p><strong>3）抽象工厂模式</strong></p><p>抽象工厂模式（Abstract Factory Pattern）属于创建型模式，它实际上是对工厂方法模式的扩展，相当于一个超级工厂，用于创建其他工厂的模式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，而且每个工厂都能按照工厂模式提供对象。其实抽象工厂也是为了减少工厂方法中的子类和工厂类数量，基于此提出的设计模式。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672997686010/7887608beff043a099de1a8b981c43a8.png" alt="image.png"></p><p>在抽象工厂模式中,每一个具体工厂都提供了多个工厂方法,用于产生多种不同类型的产品</p><p>抽象工厂模式优点</p><ol><li>对于不同产品系列有比较多共性特征时，可以使用抽象工厂模式，有助于提升组件的复用性.</li><li>当需要提升代码的扩展性并降低维护成本时，把对象的创建和使用过程分开，能有效地将代码统一到一个级别上</li><li>解决跨平台带来的兼容性问题</li></ol><p>抽象工厂模式缺点</p><ul><li>增加新的产品等级结构麻烦,需要对原有结构进行较大的修改,甚至需要修改抽象层代码,这显然会带来较大不变,违背了开闭原则.</li></ul><h1>6.介绍一下观察者设计模式？</h1><p><strong>观察者模式(observer pattern)的原始定义是：定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖项都会自动得到通知和更新。</strong></p><p>解释一下上面的定义: 观察者模式它是用于建立一种对象与对象之间的依赖关系,一个对象发生改变时将自动通知其他对象,其他对象将相应的作出反应.</p><blockquote><p>在观察者模式中发生改变的对象称为观察目标,而被通知的对象称为观察者,一个观察目标可以应对多个观察者,而且这些观察者之间可以没有任何相互联系,可以根据需要增加和删除观察者,使得系统更易于扩展.</p><p>观察者模式的别名有发布-订阅(Publish/Subscribe)模式,模型-视图(Model-View)模式、源-监听(Source-Listener) 模式等</p></blockquote><p><strong>观察者模式结构中通常包括: 观察目标和观察者两个继承层次结构.</strong></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672997686010/dbf3897db4b8443fa6efae8f7e3b3f1d.png" alt="image.png"></p><p><strong>在观察者模式中有如下角色：</strong></p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。在具体观察者中维护一个指向具体目标对象的引用,它存储具体观察者的有关状态,这些状态需要与具体目标保持一致.</li></ul><p><strong>观察者模式的优点</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>观察者模式的缺点</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时比较多</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><p><strong>观察者模式常见的使用场景</strong></p><ul><li>当一个对象状态的改变需要改变其他对象时。比如，商品库存数量发生变化时，需要通知商品详情页、购物车等系统改变数量。</li><li>一个对象发生改变时只想要发送通知，而不需要知道接收者是谁。比如，订阅微信公众号的文章，发送者通过公众号发送，订阅者并不知道哪些用户订阅了公众号。</li><li>需要创建一种链式触发机制时。比如，在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……这样通过观察者模式能够很好地实现。</li><li>微博或微信朋友圈发送的场景。这是观察者模式的典型应用场景，一个人发微博或朋友圈，只要是关联的朋友都会收到通知；一旦取消关注，此人以后将不会收到相关通知。</li></ul><h1>7.装饰器模式与代理模式的区别？</h1><p>1）<strong>代理模式(Proxy Design Pattern )</strong> 原始定义是：让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许将请求提交给对象前后进行一些处理。</p><p><strong>代理模式的适用场景</strong></p><ul><li>功能增强<br>当需要对一个对象的访问提供一些额外操作时,可以使用代理模式</li><li>远程（Remote）代理<br>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</li><li>防火墙（Firewall）代理<br>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</li><li>保护（Protect or Access）代理<br>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</li></ul><p>2）<strong>装饰器模式(decorator pattern)</strong> 的原始定义是：动态的给一个对象添加一些额外的职责. 就扩展功能而言,装饰器模式提供了一种比使用子类更加灵活的替代方案.</p><p><strong>装饰器模式的适用场景</strong></p><ul><li>快速动态扩展和撤销一个类的功能场景。 比如，有的场景下对 API 接口的安全性要求较高，那么就可以使用装饰模式对传输的字符串数据进行压缩或加密。如果安全性要求不高，则可以不使用。</li><li>不支持继承扩展类的场景。 比如，使用 final 关键字的类，或者系统中存在大量通过继承产生的子类。</li></ul><p><strong>装饰器模式与代理模式的区别</strong></p><p>对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。</p><p>对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。</p><p>他们之间的边界确实比较模糊，两者都是对类的方法进行扩展，具体区别如下：</p><ol><li>装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。</li><li>装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；</li><li>装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；</li></ol><h1>8.JDK 类库常用的设计模式有哪些？</h1><p>1）抽象工厂</p><ul><li>javax.xml.parsers.DocumentBuilderFactory抽象类</li><li>public static DocumentBuilderFactory newInstance()方法</li><li>类功能：使得应用程序可以通过XML文件，获得一个能生成DOM对象的解析器。</li><li>方法功能：获取一个DocumentBuilderFactory的新实例。这一静态方法会创建一个新的工厂实例。</li></ul><p>2）建造者模式</p><ul><li>java.lang.StringBuilder，这是一个final类。</li><li>public StringBuilder append(String str)方法，这一方法是对父类的覆写。</li><li>类功能：用于一个不可更改的字符序列。</li><li>方法功能：根据现有字符序列和追加字符，通过系统拷贝方法System.arraycopy生成一个新的字符序列。</li></ul><p>3）工厂模式</p><ul><li>java.text.NumberFormat抽象类。</li><li>public final static NumberFormat getInstance()方法。</li><li>类功能：用于数字格式的抽象基类。</li><li>方法功能：返回一个“对当前默认场景下的一个通用数字格式”的NumberFormat。显然属于工厂模式的使用。</li></ul><p>4）原型模式</p><ul><li>java.lang.Object</li><li>protected native Object clone() 方法</li><li>类功能：所有类的父类</li><li>方法功能：根据现有实例，返回一个浅拷贝对象。</li></ul><p>5）单例模式</p><ul><li>java.lang.RunTime类</li><li>public static Runtime getRuntime()</li><li>类功能：每一个运行的java应用都会有一个唯一的RunTime类的实例，这个实例使得应用程序在运行期间能够受到运行环境的影响。</li><li>方法功能：返回一个和当前java应用关联的RunTime对象。</li></ul><p>6）适配器模式</p><ul><li>java.util.Arrays。</li><li>public static List asList(T… a)方法。</li><li>类功能：此类包含了大量对数组操作的方法。</li><li>方法功能：将一个引用类型的数组转为一个List。从而可以使用List类的操作来操作数组对象，但是有一点要注意：就是不能使用add(),remove()操作，因为返回的list底层是基于数组的，数组结构是不能更改的。 list类就是这里的适配器，通过这个适配器，对数组的直接操作变为间接操作。</li></ul><h1>9.Mybatis框架中使用的设计模式有哪些？</h1><p>Builder模式</p><ul><li><strong>在Mybatis环境的初始化过程中，</strong><code>SqlSessionFactoryBuilder</code>会调用 <code>XMLConfigBuilder</code>读取所有的 <code>MybatisMapConfig.xml</code>和所有的 <code>*Mapper.xml</code>文件，构建Mybatis运行的核心对象 <code>Configuration</code>对象，然后将该 <code>Configuration</code>对象作为参数构建一个 <code>SqlSessionFactory</code>对象。</li></ul><p>工厂模式</p><ul><li><p><strong>在Mybatis中比如</strong> <code>SqlSessionFactory</code>使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672997686010/322ecc57e6094884bb48b54e607ea0a4.png" alt="image.png"></p></li><li><p><code>SqlSession</code>可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的 <code>Connection</code>对象。</p></li></ul><p>单例模式</p><p><strong>在Mybatis中有两个地方用到单例模式，</strong><code>ErrorContext</code>和 <code>LogFactory</code>，其中 <code>ErrorContext</code>是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而 <code>LogFactory</code>则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ErrorContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorContext</span>()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span>()</span> &#123;</span><br><span class="line">        ErrorContext context = LOCAL.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> ErrorContext();</span><br><span class="line">            LOCAL.<span class="keyword">set</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。</p><p>只是这里有个有趣的地方是，LOCAL的静态实例变量使用了 <code>ThreadLocal</code>修饰，也就是说它属于每个线程各自的数据，而在 <code>instance()</code>方法中，先获取本线程的该实例，如果没有就创建该线程独有的 <code>ErrorContext</code>。</p><p>代理模式</p><p><strong>代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写</strong> <code>Mapper.java</code>接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。</p><p>适配器模式</p><p>在Mybatsi的logging包中，有一个Log接口：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16657/1672997686010/4d1484b110fa43eb9fd51ebdd446af66.png" alt="image.png"></p><p>该接口定义了Mybatis直接使用的日志方法，而Log接口具体由谁来实现呢？Mybatis提供了多种日志框架的实现，这些实现都匹配这个Log接口所定义的接口方法，最终实现了所有外部日志框架到Mybatis日志包的适配。</p><h1>10.Spring框架中使用的设计模式有哪些？</h1><p>1）简单工厂</p><p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p><p>2）工厂方法</p><p>FactoryBean接口</p><p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p><p>3）单例模式</p><p>Spring依赖注入Bean实例默认是单例的。</p><p>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p><p>4）适配器模式</p><p>SpringMVC中的适配器HandlerAdatper。</p><p>HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。</p><p>因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</p><p>5）装饰器模式</p><p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p><p>动态地给一个对象添加一些额外的职责。</p><p>就增加功能来说，Decorator模式相比生成子类更为灵活。</p><p>6）代理模式</p><p>AOP底层，就是动态代理模式的实现。</p><p>7）观察者模式</p><p>Spring 基于观察者模式，实现了自身的事件机制也就是事件驱动模型，事件驱动模型通常也被理解成观察者或者发布/订阅模型。</p><p>8）策略模式</p><p>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</p><p>Rsource 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。</p><p>Resource 接口本身没有提供访问任何底层资源的实现逻辑，<strong>针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑。</strong></p>]]></content>
    
    
    <summary type="html">🍔本文汇总使用Mybatis开发的基本步骤，简易提交看Spring的相关笔记</summary>
    
    
    
    <category term="面试" scheme="https://momoao.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试题" scheme="https://momoao.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="设计模式" scheme="https://momoao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java-JVM</title>
    <link href="https://momoao.github.io/posts/202309121537.html"/>
    <id>https://momoao.github.io/posts/202309121537.html</id>
    <published>2023-09-12T10:19:03.000Z</published>
    <updated>2023-09-12T07:43:55.429Z</updated>
    
    <content type="html"><![CDATA[<h1>JVM</h1>]]></content>
    
    
    <summary type="html">🥧本文汇总Java虚拟机JVM的基础知识点</summary>
    
    
    
    <category term="底层解析" scheme="https://momoao.github.io/categories/%E5%BA%95%E5%B1%82%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://momoao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>三级网络技术</title>
    <link href="https://momoao.github.io/posts/202309121527.html"/>
    <id>https://momoao.github.io/posts/202309121527.html</id>
    <published>2023-09-11T07:30:03.000Z</published>
    <updated>2023-09-12T08:30:50.751Z</updated>
    
    <content type="html"><![CDATA[<h1>计算机三级网络技术</h1><h1>得分结构</h1><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230908154557976.png" alt="image-20230908154557976"></p><h1>知识点记录</h1><h2 id="第一章">第一章</h2><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230908162909118.png" alt="image-20230908162909118"></p><h3 id="RPR">RPR</h3><ul><li>可以为不同的业务数据分配不同的优先级</li><li>能在50ms的时间内隔离出现故障的结点和光纤段</li><li>内环和外环都可以用于传输数据分组和控制分组</li><li>是一种用于直接在光纤上高效传输IP分组的传输技术</li><li>数据帧由目的结点回收</li><li>在每一个节点都执行SRP公平算法</li><li>两个RPR节点之间的裸光纤最大长度为100公里</li><li>将沿<strong>顺时针</strong>传输的光纤叫做<strong>外环</strong>，将沿<strong>逆时针</strong>传输的光纤叫做<strong>内环</strong>。内环和外环可以用<strong>统计复用</strong>的方式传输IP分组<ul><li>内环和外环都可以传输数据分组和控制分组</li></ul></li></ul><h3 id="ITU">ITU</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911165341499.png" alt="image-20230911165341499"></p><p>OC-3：155.52Mbps</p><p>OC-12：622.08Mbps</p><p>OC-24：1.244Gbps</p><p>OC-48：2.488Gbps</p><p>OC-192：9.954Gbps</p><h3 id="HFC">HFC</h3><ul><li>==光纤同轴电缆混合网</li><li>是一个双向传输系统</li><li>光纤结点通过同轴电缆下引线为用户提供服务</li><li>为有线电视用户提供一种Internet接入方式</li></ul><h3 id="IPV6">IPV6</h3><p>双冒号压缩：不能省略非全0段的0</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911170901677.png" alt="image-20230911170901677"></p><h3 id="IEEE802-11">IEEE802.11</h3><ul><li>各种协议传输最大速率<ul><li>802.11b：11Mbps</li><li>802.11a：54Mbps（工作频段5GHz，采用了多载波调制技术）<ul><li>802.11j：是802.11a的补充，在4.9GHz~5.0GHz这个无线频率范围内增加信道</li></ul></li><li>802.11g：54Mbps（工作频段2.4 GHz ）</li><li>802.11n：300Mbps</li></ul></li></ul><h3 id="IEEE802-16">IEEE802.16</h3><p>提供宽带城域网用户访问Internet所需要的路由服务</p><p>传输速率：32~134Mbps</p><p>使用无线频段10~66GHz</p><p>与之对应的论坛组织WiMAX</p><h3 id="以太网技术">以太网技术</h3><p>光以太网用光信号来传输数据，以信元为单位传输数据的是ATM网</p><ul><li>能够根据用户的需求分配带宽</li><li>具有保护用户和网络资源安全的认证和授权功能</li><li>提供分级的QoS服务</li><li>支持MPLS（多协议标记交换）协议</li></ul><h3 id="无线接入技术">无线接入技术</h3><ul><li>分类<ul><li>无线局域网接入（IEEE  802.11标准）<ul><li>WLAN</li></ul></li><li>无线城域网接入（IEEE  802.16标准）<ul><li>WiMAX<ul><li>可以在50km内提供70Mbit/s的速度</li></ul></li></ul></li><li>Ad hoc接入</li></ul></li></ul><p>WLAN 、WiMAX、Wi Fi 、WMAN、Ad hoc</p><h3 id="宽带接入技术">宽带接入技术</h3><ul><li>分类<ul><li>数字用户线xDSL技术</li><li>光纤同轴电缆混合网HFC技术</li><li>光纤接入技术</li><li>无线接入技术<ul><li>无线局域网接入</li><li>无线城域网接入</li><li>无线Ad hoc接入</li></ul></li><li>局域网接入技术</li></ul></li></ul><h3 id="QoS">QoS</h3><p>QoS（Quality of Service）是一种网络技术，用于管理和控制网络上的数据流，以确保不同类型的数据流能够在网络中得到适当的带宽、延迟、丢包率等服务质量参数。QoS技术的主要目标是满足网络上不同应用和服务的性能需求，并确保关键应用的良好运行。</p><p>属于QoS技术的有</p><ul><li>Diffserv（区分服务）</li><li>RSVP（资源预留）</li><li>MPLS（多协议标记交换）</li></ul><h3 id="APON">APON</h3><p>光纤接入技术</p><h3 id="HFC-2">HFC</h3><p>接入方式采用共享式的传输方式，所有电缆调制解调器信号的发送、接收使用同一个上行和下行通道。因此HFC网上的用户越多，每个用户实际可用的带宽就越窄</p><p><strong>组成</strong>：有线电视头端、长距离干线、放大器、馈线、下引线</p><p><strong>传输速率</strong>:10~36Mbps</p><p>HFC通过电缆调制解调器将用户计算机与同轴电缆连接起来</p><h3 id="光纤传输系统">光纤传输系统</h3><p>中继距离可达100公里以上</p><h3 id="Cable-Modem">Cable Modem</h3><p>利用频分复用(FDM)的方法，将信道分为上行信道和下行信道</p><p>把用户计算机和有线电视同轴电缆连接起来</p><p>传输速率可达10~36Mbps</p><h3 id="汇聚层">汇聚层</h3><p>不提供用户访问Internet所需的路由服务</p><p>基本功能</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911175749527.png" alt="image-20230911175749527"></p><h3 id="核心交换层">核心交换层</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911182423848.png" alt="image-20230911182423848"></p><h3 id="宽带城域网">宽带城域网</h3><p>结构（三个平台一个出口）</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911175533514.png" alt="image-20230911175533514"></p><p>光以太网</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911180322849.png" alt="image-20230911180322849"></p><p>带内管理：利用传统电信网进行的网络管理，如数据通信网（DCN）或公共交换电话网（PSTN）拨号，对网络设备进行配置</p><p>带外管理：利用IP协议进行的网络管理，利用的是SNMP协议</p><h3 id="服务器技术">服务器技术</h3><ul><li>服务器磁盘性能表现在磁盘存储容量与I/O速度</li><li>服务器<strong>可靠性</strong>通常用平均无故障时间（MTBF），用平均维修时间（MTBR）来度量系统<strong>可维护性</strong>，而<strong>可用性=MTBF/(MTBF+MTBR)</strong></li></ul><h3 id="SDN">SDN</h3><p>主要用于广域网中（而非城域网）</p><h3 id="ADSL">ADSL</h3><p>使用一对铜双绞线</p><p>ADSL Modem（解调器）用于连接计算机</p><p>提供非对称带宽特性</p><ul><li>上行速度：64Kbit/s ~ 640Kbit/s</li><li>下行速度：500Kbit/s ~ 7Mbit/s</li></ul><p>在现有用户电话线上支持电话业务和数字业务</p><p>xDSL按上行和下行速率分为速率对称和非对称</p><p>HDSL上行传输速率为1.544Mbps</p><h3 id="光接入网">光接入网</h3><p>光接入网不适宜使用复杂的激光器及其他复杂光器件，以减少大量用户接入时的安装、维护的工作量，以降低成本提高系统可靠性。这些要求意味着无源光接入网比有源光接入网更符合实际应用</p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911172000367.png" alt="image-20230911172000367"></p><h2 id="第二章">第二章</h2><h2 id="题库">题库</h2><h3 id="IP地址计算">IP地址计算</h3><p>网络地址：主机位变0</p><p>直接广播地址：主机位变1</p><p>主机号：网络为变0</p><p>子网第一个可用ip地址：网络地址+1</p><h3 id="NAT转换">NAT转换</h3><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911185634062.png" alt="image-20230911185634062"></p><p><img src="../assets/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF_Image/image-20230911185647419.png" alt="image-20230911185647419"></p><h1>AI总结</h1><h2 id="第一章-2">第一章</h2><h3 id="RPR-2">RPR</h3><p>RPR（Rapid Spanning Tree Protocol）技术是一种用于以太网网络的协议，旨在解决环路问题和提高网络可靠性。它具有以下关键特点：</p><ol><li><p><strong>环路防护</strong>：RPR防止以太网网络中的环路形成，避免广播风暴和数据包洪泛等问题，从而提高网络性能。</p></li><li><p><strong>快速收敛</strong>：RPR能够快速检测网络故障并快速恢复，降低网络中断的时间，相比传统的STP更快速。</p></li><li><p><strong>冗余路径</strong>：RPR支持多个路径，当主路径出现问题时，可以迅速切换到备用路径，提高网络可用性。</p></li><li><p><strong>QoS支持</strong>：RPR允许配置不同的服务质量，确保关键应用程序性能。</p></li><li><p><strong>分布式架构</strong>：RPR使用分布式架构，不需要中央控制器，提高了网络的可伸缩性和稳定性。</p></li><li><p><strong>适用性</strong>：RPR通常用于大型以太网网络，如城域网和广域网，特别适用于需要高可用性和快速恢复的应用场景。</p></li></ol><p>总之，RPR技术旨在改善以太网网络的性能和可靠性，通过防止环路和快速恢复故障来确保网络的高可用性。这对于大型网络和关键应用程序至关重要。</p><h3 id="STP">STP</h3><p>STP（Spanning Tree Protocol）技术是一种用于以太网网络的协议，旨在防止网络中的环路并确保数据包传输的稳定性。STP是IEEE 802.1D标准的一部分，它的主要作用是构建一个无环的树状拓扑结构，以避免广播风暴和数据包洪泛。</p><p>以下是STP技术的关键概念和特点：</p><ol><li><p><strong>环路防护</strong>：STP的主要目标是防止以太网网络中的环路。环路可能导致数据包在网络中无限循环，从而耗尽网络资源并降低性能。STP通过选择一条主要路径，将其他冗余路径禁用，以确保网络中不存在环路。</p></li><li><p><strong>桥和交换机</strong>：STP协议适用于桥和交换机（也称为网桥和交换机），这些设备在以太网网络中传输数据帧。每个桥或交换机参与STP协议，共同协商并维护拓扑信息。</p></li><li><p><strong>树状拓扑</strong>：STP构建一个树状拓扑结构，其中一个桥或交换机被选为根桥（Root Bridge），所有其他桥或交换机都通过最佳路径连接到根桥。这确保了无环的网络拓扑。</p></li><li><p><strong>端口状态</strong>：STP定义了端口状态，包括阻塞、监听、学习和转发状态。在树状拓扑中，只有一个端口处于转发状态，其余端口处于阻塞状态，以防止环路。</p></li><li><p><strong>故障恢复</strong>：STP能够检测到网络中的拓扑更改，例如链路故障或设备添加/移除，并自动重新计算拓扑以适应这些更改，以确保网络的稳定性。</p></li><li><p><strong>多个变种</strong>：STP有几个变种，包括经典STP（CSTP）、快速STP（RSTP），以及更快速的多重实例STP（MSTP）。这些变种增强了STP的性能和快速故障恢复能力。</p></li></ol><p>总之，STP技术是一种用于以太网网络的关键协议，旨在防止环路并确保网络的可靠性。它通过构建无环的树状拓扑结构来实现这一目标，并能够在网络拓扑发生变化时自动进行调整，以维护网络的稳定性。不过，需要注意的是，STP的收敛速度相对较慢，因此在要求更快速的网络恢复的情况下，可能需要考虑使用其他协议，如RSTP或MSTP。</p><h3 id="RPR和STP区别">RPR和STP区别</h3><p>RPR（Rapid Spanning Tree Protocol）和STP（Spanning Tree Protocol）是两种不同的网络协议，用于以太网网络中的环路防护，它们之间有一些关键的区别：</p><ol><li><p><strong>目标</strong>:</p><ul><li><p><strong>RPR</strong>：RPR的主要目标是提高以太网网络的恢复速度和性能。它旨在快速检测网络中的故障并迅速切换到备用路径，以减少网络中断时间。</p></li><li><p><strong>STP</strong>：STP的主要目标是防止网络中的环路，而不是强调快速恢复。STP构建一个无环的树状拓扑结构，确保数据包不会在网络中无限循环。</p></li></ul></li><li><p><strong>收敛速度</strong>:</p><ul><li><p><strong>RPR</strong>：RPR被设计为快速收敛的协议，通常能够在毫秒级别内检测到网络故障并快速恢复，降低网络中断的影响。</p></li><li><p><strong>STP</strong>：STP的收敛速度相对较慢，通常需要几秒钟或更长时间来恢复网络。这是因为STP使用定时器和状态机来确定最佳路径，需要一些时间来计算和选择新的路径。</p></li></ul></li><li><p><strong>拓扑结构</strong>:</p><ul><li><p><strong>RPR</strong>：RPR允许多个路径同时存在于网络中，以提高冗余性。如果主路径出现故障，RPR可以快速切换到备用路径，确保网络的连通性。</p></li><li><p><strong>STP</strong>：STP构建一个树状拓扑结构，其中只有一个主路径，其他路径处于阻塞状态。这可以防止环路，但是对于冗余路径的利用有限。</p></li></ul></li><li><p><strong>分布式 vs. 集中式</strong>:</p><ul><li><p><strong>RPR</strong>：RPR采用分布式架构，网络中的每个节点可以独立进行决策，而无需中央控制器。这提高了网络的可伸缩性和稳定性。</p></li><li><p><strong>STP</strong>：STP通常是集中式的，网络中的一个节点被选为根桥，然后计算路径以连接到根桥。这种集中式方法可以导致性能瓶颈和单点故障。</p></li></ul></li><li><p><strong>适用性</strong>:</p><ul><li><p><strong>RPR</strong>：RPR通常用于城域网（Metropolitan Area Networks，MANs）和广域网（Wide Area Networks，WANs）等大型以太网网络，特别是需要高可用性和快速恢复的应用场景。</p></li><li><p><strong>STP</strong>：STP通常用于局域网（Local Area Networks，LANs）或小型网络，要求环路防护，但对于快速恢复性能要求不是很高的情况。</p></li></ul></li></ol><p>总的来说，RPR和STP是两种不同的环路防护协议，它们的设计目标和性能特点有所不同。RPR强调快速恢复和冗余路径支持，适用于大型网络，而STP主要用于小型网络，其主要目标是环路防护。选择哪种协议取决于网络规模、性能要求和特定的应用场景。</p><h3 id="FDDI">FDDI</h3><p>FDDI（Fiber Distributed Data Interface）是一种早期的局域网（LAN）技术，最早于1987年由美国国家标准协会（ANSI）标准化。它是一种基于光纤和双绞线的高性能网络技术，旨在提供高带宽、低延迟和高可用性的网络连接。以下是关于FDDI的主要特点和特点：</p><ol><li><p><strong>光纤传输</strong>：FDDI的核心特点是使用光纤作为主要的传输媒介。光纤具有高带宽、低信号衰减和抗电磁干扰的特点，因此能够支持远距离的数据传输，并提供较高的数据传输速度。</p></li><li><p><strong>双环拓扑</strong>：FDDI网络采用双环拓扑结构，分为主环（Primary Ring）和备用环（Secondary Ring）。这两个环状结构可以在网络故障时提供冗余路径，以确保网络的高可用性。如果主环中的某一部分出现故障，数据将被切换到备用环路，几乎无感知地继续传输。</p></li><li><p><strong>高带宽</strong>：FDDI支持高带宽，最初的速度为100 Mbps（兆比特每秒）。后来，FDDI-II标准提出了更高速度的变种，达到了200 Mbps。这使得FDDI成为当时性能最高的LAN技术之一。</p></li><li><p><strong>低延迟</strong>：FDDI设计用于支持实时应用程序，因此具有低延迟特性。这对于需要快速响应时间的应用程序非常重要，例如音频和视频传输。</p></li><li><p><strong>支持多协议</strong>：FDDI可以支持多种协议，包括TCP/IP、IPX/SPX等，使其在不同的操作系统和应用程序环境中通用。</p></li><li><p><strong>管理和可靠性</strong>：FDDI具有强大的管理功能，可以监视网络性能和识别故障。它还具有自动检测和纠正环路故障的能力，以确保网络的稳定性。</p></li><li><p><strong>物理层和数据链路层</strong>：FDDI定义了物理层和数据链路层的标准，包括光纤传输规范、帧格式和MAC（Media Access Control）协议。</p></li><li><p><strong>适用性</strong>：FDDI最初设计用于大型企业网络和数据中心，以满足高带宽、高可用性和低延迟的需求。然而，随着技术的发展，以太网等其他LAN技术逐渐崭露头角，FDDI在较小规模的网络中的使用逐渐减少。</p></li></ol><p>总之，FDDI是一种光纤局域网技术，具有高带宽、低延迟、高可用性和强大的管理功能。尽管它在过去曾经是主要的网络技术之一，但随着以太网等技术的崭露头角，FDDI的使用逐渐减少。然而，它的一些特点仍然在特定的网络环境中有价值，例如需要高可靠性和低延迟的应用场景。</p><h3 id="ADSL-2">ADSL</h3><p>ADSL（Asymmetric Digital Subscriber Line）是一种常见的宽带接入技术，用于将数字数据通过普通电话线传输。ADSL之所以称为&quot;不对称&quot;，是因为它支持不同的上行（上传）和下行（下载）数据传输速度，通常下载速度较高，适用于大多数家庭用户的需求。以下是有关ADSL的主要特点和工作原理：</p><ol><li><p><strong>不对称速度</strong>：</p><ul><li>下行速度（从互联网到用户）通常比上行速度（从用户到互联网）快得多。这种设计是基于家庭用户通常更多地下载内容而较少上传的使用模式。</li></ul></li><li><p><strong>电话线传输</strong>：</p><ul><li>ADSL使用普通电话线（铜线）来传输数字数据。这意味着在大多数情况下，用户不需要新的电缆或基础设施，只需使用电话线接入ADSL即可。</li></ul></li><li><p><strong>拆分频段</strong>：</p><ul><li>ADSL技术允许电话线同时传输模拟电话信号和数字数据信号。为了实现这一点，频谱被划分为不同的频段，其中一部分用于传输语音信号，而另一部分用于传输数字数据。</li></ul></li><li><p><strong>调制与解调制</strong>：</p><ul><li>ADSL中，数字数据通过调制（在发送端）和解调制（在接收端）的过程来传输。调制将数字数据转换成模拟信号，以便通过电话线传输。解调制则将接收到的信号还原为数字数据。</li></ul></li><li><p><strong>距离限制</strong>：</p><ul><li>ADSL的性能受到用户和提供商之间的距离限制。通常，用户越远离提供商的中心局（DSLAM，DSL Access Multiplexer），其ADSL连接速度就会降低。这是因为信号在长距离传输过程中会逐渐减弱。</li></ul></li><li><p><strong>不适用于对称需求</strong>：</p><ul><li>尽管ADSL适用于家庭用户和小型企业，但对于需要对称上传和下载速度的应用（如视频会议或远程服务器访问），ADSL可能不是最佳选择。</li></ul></li><li><p><strong>普及性</strong>：</p><ul><li>在过去的几十年中，ADSL曾是家庭和小型企业宽带接入的主要选择，因为它提供了相对较高的下载速度，而且普及率高。然而，随着光纤和有线宽带技术的发展，ADSL在一些地区逐渐被更快的宽带连接替代。</li></ul></li></ol><p>总体而言，ADSL是一种宽带接入技术，适用于家庭用户和小型企业，因其便捷性和相对低廉的成本而受欢迎。然而，在需要更高对称带宽或更远距离连接的场景中，可能需要考虑其他宽带技术，如光纤或有线宽带。</p><h3 id="NAT">NAT</h3><p>NAT，全称为Network Address Translation（网络地址转换），是一种网络技术，常用于连接私有网络与公共互联网之间，以实现多台设备共享单个公共IP地址的目的。NAT的主要功能是将内部私有网络中的设备与外部互联网之间的通信进行转换和管理。以下是有关NAT的主要概念和功能：</p><ol><li><p><strong>IP地址转换</strong>：</p><ul><li>NAT主要工作是将内部私有网络中的设备使用私有IP地址与外部互联网之间的通信进行转换。私有IP地址通常位于以下保留地址段之一：10.0.0.0至10.255.255.255、172.16.0.0至172.31.255.255或192.168.0.0至192.168.255.255。</li></ul></li><li><p><strong>单一公共IP地址</strong>：</p><ul><li>NAT允许多台设备在内部私有网络中使用相同的公共IP地址进行互联网访问。这种方式可以帮助节省公共IP地址，并提高网络的安全性，因为内部设备的IP地址对外部不可见。</li></ul></li><li><p><strong>端口映射</strong>：</p><ul><li>除了IP地址转换，NAT还可以使用端口映射（Port Mapping）来将多个内部设备与同一个公共IP地址关联起来。通过在公共IP地址和端口之间建立映射，NAT可以将外部请求正确路由到内部的特定设备上。</li></ul></li><li><p><strong>类型</strong>：</p><ul><li>有不同类型的NAT，包括静态NAT、动态NAT和PAT（Port Address Translation）。<ul><li><strong>静态NAT</strong>：为特定内部设备分配一个固定的公共IP地址，通常用于服务器等需要对外部可见的设备。</li><li><strong>动态NAT</strong>：为内部设备动态分配公共IP地址，通常是从一个可用的地址池中选择。</li><li><strong>PAT</strong>：是一种特殊形式的NAT，它使用单个公共IP地址，并通过不同的端口号来区分不同的内部设备。</li></ul></li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>NAT提供一定程度的安全性，因为内部设备的IP地址对外部互联网不可见。这可以防止外部网络直接访问内部设备，提高了网络的安全性。</li></ul></li><li><p><strong>IPv4地址枯竭问题</strong>：</p><ul><li>NAT也有助于缓解IPv4地址短缺问题，因为它允许多个内部设备共享一个公共IP地址。这对于面临IP地址不足问题的网络非常重要。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>NAT常用于家庭网络路由器、企业网络和云计算环境中，以允许多个设备在内部网络中访问互联网。它也用于在虚拟化环境中管理虚拟机的网络连接。</li></ul></li></ol><p>总之，NAT是一种网络技术，用于将内部私有网络中的设备与外部互联网之间的通信进行转换和管理，以实现多个设备共享单个公共IP地址的目的。它对网络的安全性和IPv4地址枯竭问题都有积极的影响。</p><h3 id="数字信号和模拟信号">数字信号和模拟信号</h3><p>模拟信号和数字信号是两种不同类型的信号，它们在电子通信和信息处理中具有重要作用。以下是有关模拟信号和数字信号的主要特点和区别：</p><p><strong>模拟信号（Analog Signals）</strong>：</p><ol><li><p><strong>连续性</strong>：模拟信号是连续的，它们可以在一定范围内取任意值。在模拟信号中，信号的值在时间上不断变化，可以采用无限数量的值。</p></li><li><p><strong>波形</strong>：模拟信号可以呈现为连续的波形，如正弦波、余弦波或任何复杂的波形。这些波形表示信号在时间上的变化。</p></li><li><p><strong>物理表示</strong>：模拟信号通常由连续的物理量表示，例如电压、电流或声音压力。这些物理量的变化对应于信号的变化。</p></li><li><p><strong>精度</strong>：模拟信号的精度受到噪声和干扰的影响，可能存在信号失真。因此，保持信号的质量需要采取一些措施，如滤波和放大。</p></li><li><p><strong>用途</strong>：模拟信号常用于传输连续的信息，如音频、视频和传感器数据。传统的电话线路就是一个传输模拟信号的例子。</p></li></ol><p><strong>数字信号（Digital Signals）</strong>：</p><ol><li><p><strong>离散性</strong>：数字信号是离散的，它们只能取有限数量的离散值。在数字信号中，信号的值以离散的步进方式变化。</p></li><li><p><strong>表示</strong>：数字信号通常表示为二进制代码，即由一系列0和1组成的序列。每个二进制数字代表信号的离散值。</p></li><li><p><strong>抗干扰性</strong>：数字信号在传输和处理过程中对噪声和干扰具有较强的抗性。由于信号是以离散值表示的，可以更容易地检测和纠正传输中的错误。</p></li><li><p><strong>精度</strong>：数字信号的精度通常较高，因为它们可以以足够高的分辨率表示信号，以便准确传输和处理。</p></li><li><p><strong>用途</strong>：数字信号广泛用于计算机和数字通信中，包括互联网、数字音频和视频传输、数字电视和移动通信等领域。数字信号也用于数字电子设备的内部通信和处理。</p></li></ol><p>总结起来，模拟信号是连续的、具有无限可能值的信号，通常用于传输连续的信息。而数字信号是离散的、以二进制代码表示的信号，对噪声具有较强的抗性，广泛用于数字化信息和数据的处理、传输和存储。在现代通信和信息技术中，数字信号通常更为常见，因为它们具有高精度和抗干扰性，适用于数字系统中的多种应用。</p><h3 id="地址划分">地址划分</h3><p>IPv4地址空间被分为五个不同的地址类别：A、B、C、D和E。每个地址类别都具有不同的地址范围和用途。以下是各个IPv4地址类别的地址范围：</p><ol><li><p><strong>A类地址</strong>：</p><ul><li>A类地址用于大型网络，通常由大型组织、政府机构或互联网服务提供商使用。A类地址的特点是其高位字节的最高位为0。A类地址的地址范围是从1.0.0.0到126.0.0.0，其中最小的A类地址是1.0.0.0，而最大的A类地址是126.255.255.255。A类地址中有16,777,214个可用的主机地址。</li></ul></li><li><p><strong>B类地址</strong>：</p><ul><li>B类地址用于中型网络，通常由中等规模的组织或公司使用。B类地址的特点是其高位字节的最高位为10。B类地址的地址范围是从128.0.0.0到191.255.0.0，其中最小的B类地址是128.0.0.0，而最大的B类地址是191.255.255.255。B类地址中有65,534个可用的主机地址。</li></ul></li><li><p><strong>C类地址</strong>：</p><ul><li>C类地址用于小型网络，通常由小型企业或组织使用。C类地址的特点是其高位字节的最高位为110。C类地址的地址范围是从192.0.0.0到223.255.255.0，其中最小的C类地址是192.0.0.0，而最大的C类地址是223.255.255.255。C类地址中有254个可用的主机地址。</li></ul></li><li><p><strong>D类地址</strong>：</p><ul><li>D类地址用于多播（Multicast）通信。多播地址用于一对多或多对多的通信，而不是一对一的通信。D类地址的地址范围是从224.0.0.0到239.255.255.255。</li></ul></li><li><p><strong>E类地址</strong>：</p><ul><li>E类地址保留用于实验和研究，不用于正式的互联网通信。E类地址的地址范围是从240.0.0.0到255.255.255.255。</li></ul></li></ol><p>需要注意的是，这些地址范围中的一些地址已被保留用于特定用途，如私有地址空间、保留地址和多播地址。此外，IPv4地址空间已经耗尽，IPv6被广泛采用以应对IPv4地址短缺问题。因此，在实际网络中，IPv6地址分配已经变得越来越重要。</p><h3 id="POS">POS</h3><p>在计算机网络技术中，POS（Point of Sale）技术通常指的是与零售业务相关的计算机系统和设备，用于处理销售交易和管理商店或企业的销售活动。POS技术在零售、餐饮和服务行业中广泛应用，以提高交易效率、管理库存、跟踪销售数据等。以下是计算机网络中的POS技术的关键方面：</p><ol><li><p><strong>POS终端</strong>：</p><ul><li>POS系统通常包括POS终端，这是一种特殊的计算机设备或应用程序，用于处理交易。POS终端通常与网络连接，以便与后端服务器或数据库进行通信，以获取产品价格、库存信息等。</li></ul></li><li><p><strong>网络连接</strong>：</p><ul><li>POS终端需要与后端服务器或云服务进行通信，以获取实时的产品信息、价格、库存状态等。这通常需要网络连接，可以是有线或无线网络，以确保快速和可靠的交易处理。</li></ul></li><li><p><strong>支付处理</strong>：</p><ul><li>POS技术通常包括支付处理功能，允许客户使用各种支付方式，如信用卡、借记卡、移动支付、现金等，完成交易。支付信息需要安全传输和处理，因此网络连接通常会采用加密和安全协议。</li></ul></li><li><p><strong>库存管理</strong>：</p><ul><li>POS系统能够跟踪库存水平，以便在销售产品时更新库存。当产品售罄或库存低于阈值时，POS系统可以自动发出订单或提醒库存管理人员。</li></ul></li><li><p><strong>销售数据和报告</strong>：</p><ul><li>POS系统记录每笔交易的详细信息，包括产品、价格、日期、时间等。这些数据可用于生成销售报告和分析，帮助商家了解销售趋势、产品流行度等信息。</li></ul></li><li><p><strong>客户管理</strong>：</p><ul><li>一些POS系统包括客户管理功能，允许商家跟踪客户购买历史、发送促销信息、管理客户积分或奖励计划等。</li></ul></li><li><p><strong>云POS</strong>：</p><ul><li>最近，云POS技术也逐渐流行起来。云POS系统将POS数据存储在云服务器上，允许商家远程访问和管理POS数据，无论在何地都可以查看销售数据。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>POS技术必须具备高度的安全性，以保护支付信息和客户数据。这包括加密数据传输、安全访问控制、防止恶意软件攻击等安全措施。</li></ul></li></ol><p>总之，计算机网络中的POS技术是用于处理销售和管理零售业务的关键工具。它通过网络连接、支付处理、库存管理、数据分析等功能，帮助商家提高交易效率、提供更好的客户服务，并为经营决策提供有用的数据。</p><h3 id="SDN-2">SDN</h3><p>SDN（Software-Defined Networking）技术是一种网络架构和管理方法，它通过将网络控制平面（Control Plane）与数据转发平面（Data Plane）分离，并将网络控制逻辑集中化，以实现更灵活、可编程和自动化的网络管理。下面是关于SDN技术的一些重要信息：</p><ol><li><p><strong>控制平面与数据平面分离</strong>：传统网络设备如路由器和交换机通常将控制平面和数据平面集成在一起，这意味着网络的控制逻辑与数据包的处理在同一设备上完成。SDN将这两个平面分开，允许网络管理员集中管理网络策略，而数据平面设备则负责根据这些策略来转发数据包。</p></li><li><p><strong>SDN控制器</strong>：SDN网络的核心是SDN控制器，它是一个中央实体，负责管理网络设备和路由流量。流行的SDN控制器包括OpenDaylight、ONOS、Floodlight和Cisco的APIC-EM等。这些控制器提供了一种接口，允许管理员定义网络策略、监控流量并动态配置网络设备。</p></li><li><p><strong>网络可编程性</strong>：SDN使网络更加可编程，允许管理员根据应用程序需求动态配置网络策略。这使得网络能够更好地适应不同应用的要求，从而提供更高的灵活性和性能。</p></li><li><p><strong>自动化</strong>：SDN技术可以自动化许多网络管理任务，例如流量工程、负载均衡和故障恢复。通过集中化的控制，网络管理员可以更轻松地实施这些自动化任务，提高了网络的可靠性和效率。</p></li><li><p><strong>SDN协议</strong>：在SDN中，OpenFlow是最常用的通信协议之一，用于在控制器和数据平面设备之间传递流量转发规则。此外，其他协议如NETCONF和RESTful API也可以用于SDN控制器与网络设备之间的通信。</p></li><li><p><strong>SDN的优势</strong>：SDN技术提供了更好的网络管理和资源利用率，有助于降低运营成本。它还允许网络更好地适应新的应用需求，提高了网络的灵活性和可扩展性。</p></li><li><p><strong>SDN的应用</strong>：SDN技术广泛应用于数据中心网络、广域网（WAN）、电信网络和企业网络中。它在虚拟化、云计算、物联网（IoT）和5G网络等领域都有着重要的作用。</p></li></ol><p>需要注意的是，SDN技术虽然具有许多优点，但也存在一些挑战，例如安全性和复杂性。网络管理员需要仔细考虑如何有效地部署和管理SDN网络，以确保网络的稳定性和安全性。</p><h3 id="QoS-2">QoS</h3><p>QoS（Quality of Service）是一种网络技术，用于管理和控制网络上的数据流，以确保不同类型的数据流能够在网络中得到适当的带宽、延迟、丢包率等服务质量参数。QoS技术的主要目标是满足网络上不同应用和服务的性能需求，并确保关键应用的良好运行。</p><p>以下是QoS技术的主要组成部分和相关概念：</p><ol><li><p><strong>带宽管理</strong>：QoS的一个关键方面是带宽管理，它涉及分配和控制网络中可用带宽的方式。这包括带宽分配、带宽保障、带宽调整等策略，以确保重要应用能够获得足够的带宽。</p></li><li><p><strong>流量分类</strong>：QoS技术根据流量的特性对数据流进行分类。通常，流量可以分为不同的类别，如实时流量（例如VoIP和视频流）、交互式流量（例如Web浏览）和后台传输流量（例如文件下载）。这些不同的类别通常需要不同的QoS处理。</p></li><li><p><strong>标记和标签</strong>：为了对不同的数据流应用QoS策略，网络设备通常使用标记或标签来识别流量。这些标记可以通过不同的字段（如DiffServ或802.1p标头字段）添加到数据包中，并在网络中路由和处理数据包时参考。</p></li><li><p><strong>流量控制</strong>：QoS技术允许管理员设置流量控制策略，以控制数据流的速率和优先级。这包括流量调度、队列管理和拥塞控制等技术，以确保高优先级流量在网络中得到及时传输。</p></li><li><p><strong>拥塞管理</strong>：拥塞是网络中常见的问题，会导致数据包丢失和延迟增加。QoS技术可以帮助网络设备识别和应对拥塞情况，例如通过降低低优先级流量的速率来保护高优先级流量。</p></li><li><p><strong>策略配置</strong>：QoS策略通常需要在网络设备上进行配置。这包括设置流量分类、标记和标签、定义带宽限制和优先级、配置队列等。</p></li><li><p><strong>监测和报告</strong>：QoS技术通常需要监测网络性能，并生成报告以评估QoS策略的有效性。这可以通过网络监控工具和QoS报告生成器来实现。</p></li></ol><p>QoS技术在各种网络环境中都有重要应用，特别是在需要支持实时应用程序（如VoIP和视频会议）的企业网络、云计算环境和电信网络中。通过有效实施QoS策略，可以提供更稳定、可靠和高性能的网络服务，确保重要应用的用户体验。</p><h3 id="HFC-3">HFC</h3><p>HFC（Hybrid Fiber-Coaxial）是一种通信网络架构，通常用于提供有线电视和宽带互联网服务。HFC网络结合了光纤（Fiber）和同轴电缆（Coaxial Cable）两种不同的传输介质，以实现高速数据传输和广播电视信号的分发。以下是HFC网络的一些关键特点和组成部分：</p><ol><li><p><strong>光纤部分</strong>：</p><ul><li>HFC网络的核心是光纤（光导纤维），通常由光缆组成。光纤具有高带宽和低损耗的特点，使其能够传输大量数据，同时具有较长的传输距离。</li><li>在HFC网络中，光纤通常延伸到网络提供商的中央办公室（Headend）或数据中心。</li></ul></li><li><p><strong>同轴电缆部分</strong>：</p><ul><li>从中央办公室延伸出来的光纤通常会连接到同轴电缆，这是一种特殊的电缆，具有较高的信号传输能力。</li><li>同轴电缆在最后一英里（Last Mile）或用户家庭附近的网络中用于传输数据和电视信号。它通常分为多个信号频带，每个频带用于不同的目的。</li></ul></li><li><p><strong>分配器和放大器</strong>：</p><ul><li>在HFC网络中，光纤到达街区（通常称为节点）的地方，然后通过分配器将信号分发到各个用户家庭。</li><li>放大器（Amplifiers）用于增强信号，以弥补信号在同轴电缆中的传输损耗。这些放大器通常位于同轴电缆的不同位置，以确保信号质量。</li></ul></li><li><p><strong>数据和电视信号</strong>：</p><ul><li>HFC网络旨在支持多种服务，包括宽带互联网、有线电视和电话服务。光纤部分主要用于数据传输，而同轴电缆部分同时用于广播电视信号的传输。</li><li>数据信号通常采用数字传输，而电视信号可以是模拟或数字信号，具体取决于网络提供商的技术和服务。</li></ul></li><li><p><strong>双向通信</strong>：</p><ul><li>HFC网络通常是双向的，允许用户同时下载和上传数据。这使得它非常适合宽带互联网服务，用户可以通过网络上传和下载大文件、流媒体内容等。</li></ul></li><li><p><strong>网络提供商</strong>：</p><ul><li>HFC网络通常由电视有线运营商或互联网服务提供商提供和维护。这些提供商通过HFC网络向用户提供多种服务，并通常会提供有线电视、宽带互联网和电话服务的捆绑套餐。</li></ul></li></ol><p>总的来说，HFC网络是一种灵活且多用途的通信网络架构，它结合了光纤的高速数据传输能力和同轴电缆的广播电视信号传输能力，为用户提供了多种通信和娱乐服务。然而，随着技术的发展，一些地区正在逐渐升级到更先进的纯光纤网络，以提供更高的速度和性能。</p><h3 id="MPLS">MPLS</h3><p>MPLS（Multiprotocol Label Switching）是一种用于构建高效、灵活和可管理的数据网络的通信协议和技术。它将传统的IP路由和数据包交换与标签交换相结合，为数据包在网络中的传输提供了更高的性能和质量。</p><p>以下是MPLS的关键特点和工作原理：</p><ol><li><p><strong>标签交换</strong>：</p><ul><li>MPLS引入了一个称为&quot;标签&quot;的数据包头部信息，用于标识数据包的路由和处理方式。</li><li>这些标签是短、固定长度的值，被附加到数据包的头部，以便路由器和交换机能够快速查找和转发数据包，而不必进行复杂的IP路由查找。</li></ul></li><li><p><strong>标签交换的优点</strong>：</p><ul><li>更快的数据包转发速度：由于标签查找速度比传统IP路由更快，MPLS可以实现更高的数据包转发速度，适用于要求低延迟的应用。</li><li>灵活性：MPLS可以根据标签的值来实现流量工程、负载均衡和服务质量（QoS）管理，从而更好地满足网络运营商和企业的需求。</li></ul></li><li><p><strong>标签分发和交换</strong>：</p><ul><li>MPLS网络中的路由器和交换机被称为&quot;MPLS节点&quot;，它们负责为数据包分发和交换标签。</li><li>当数据包进入MPLS网络时，第一个MPLS节点（通常是边缘路由器）会分配一个标签，并将其附加到数据包头部。</li><li>数据包在MPLS网络中根据标签进行路由，每个MPLS节点根据标签决定数据包的下一跳。</li><li>当数据包离开MPLS网络时，最后一个MPLS节点会将标签移除，将数据包发送到目标。</li></ul></li><li><p><strong>MPLS应用</strong>：</p><ul><li>MPLS广泛用于构建虚拟专用网络（VPN）和多协议标签交换（MPLS-VPN）。</li><li>它也用于支持服务提供商网络中的服务质量（QoS）管理、流量工程和负载均衡。</li><li>MPLS还在广域网（WAN）和数据中心网络中得到广泛应用，以提供高性能的互联互通。</li></ul></li><li><p><strong>MPLS与IP</strong>：</p><ul><li>MPLS与IP是可以协同工作的技术。事实上，MPLS可以在现有的IP网络上部署，提供额外的功能和性能优势。</li><li>MPLS通常与BGP（Border Gateway Protocol）等路由协议一起使用，以确定数据包的路径和标签分发。</li></ul></li></ol><p>总的来说，MPLS是一种强大的网络技术，用于提高数据网络的性能、可管理性和质量。它在提供广域网连接、建立虚拟专用网络、实现服务质量管理等方面发挥了重要作用，并在大型企业网络、云服务和电信网络中得到广泛应用。</p><h3 id="频分复用">频分复用</h3><p>频分复用（Frequency Division Multiplexing，FDM）是一种多路复用技术，用于在通信系统中将多个独立的信号或数据流合并成一个复合信号，并通过不同的频率将它们传输到目标接收端。这个技术允许多个信号同时共享传输介质，而不会相互干扰。</p><p>以下是频分复用的一些关键概念和工作原理：</p><ol><li><p><strong>信号分离</strong>：</p><ul><li>在频分复用中，每个独立的信号或数据流被分配到不同的频率带宽上。</li><li>每个信号通常经过一个调制器（Modulator），将其转换成可以在特定频段内传输的信号。</li></ul></li><li><p><strong>合并和传输</strong>：</p><ul><li>合并器（Multiplexer）负责将所有分配给不同频率的信号合并成一个复合信号。</li><li>复合信号随后被传输到通信媒介（如电缆、光纤或空中传输）上，以便传输到接收端。</li></ul></li><li><p><strong>频率选择</strong>：</p><ul><li>接收端使用一个分频器（Demultiplexer）来选择特定频率带宽，并将其分离成独立的信号。</li><li>每个分离出的信号经过解调器（Demodulator）以还原原始数据或信息。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>频分复用允许多个信号并行传输，而不会干扰彼此。</li><li>它可以提高通信系统的效率，允许多个用户或应用程序共享通信通道，从而减少了通信系统的成本。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>频分复用广泛应用于各种通信系统，包括有线电视、广播、卫星通信、移动通信和计算机网络等。</li><li>在移动通信领域，不同的移动电话用户可以使用不同的频段，以便在同一时间共享相同的通信基础设施。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>频分复用的主要缺点是需要足够的频带宽来容纳所有信号。如果频带宽度不足，可能会导致信号重叠和干扰。</li><li>它也可能在信道的传输距离较长或带宽有限的情况下效率不高。</li></ul></li></ol><p>需要注意的是，频分复用是一种传统的多路复用技术，虽然仍然在一些应用中广泛使用，但在一些现代通信系统中，例如数字通信和光纤通信，更高级的复用技术如时分复用（TDM）和码分复用（CDM）也得到了广泛应用。这些技术在提供高效、可靠通信方面具有重要作用。</p><h3 id="多路复用">多路复用</h3><p>多路复用技术是一种将多个信号或数据流合并在一起并在共享传输媒体上同时传输它们的通信技术。这有助于有效地利用通信资源，以满足多个用户或应用程序的需求。以下是一些常用的多路复用技术：</p><ol><li><p><strong>时分复用（Time Division Multiplexing，TDM）</strong>：</p><ul><li>TDM将时间划分为一系列间隔，并在每个时间间隔内依次传输不同信号的部分。</li><li>这意味着每个信号占用独占的时间间隔，使得多个信号可以在共享传输媒体上传输，而不会相互干扰。</li><li>TDM常用于电话网络和数字通信系统中。</li></ul></li><li><p><strong>频分复用（Frequency Division Multiplexing，FDM）</strong>：</p><ul><li>FDM将频谱分成多个不同的频带，每个频带用于传输不同信号。</li><li>这允许多个信号以不同的频率并行传输，而不会相互干扰。</li><li>FDM广泛应用于广播、电视和一些无线通信系统中。</li></ul></li><li><p><strong>码分复用（Code Division Multiplexing，CDM）</strong>：</p><ul><li>CDM使用不同的编码序列来区分和合并多个信号。</li><li>不同的编码序列允许多个信号在相同的频带上传输，并且只有接收端使用正确的解码序列才能还原原始信号。</li><li>CDM用于CDMA（Code Division Multiple Access）等无线通信技术中。</li></ul></li><li><p><strong>波分复用（Wavelength Division Multiplexing，WDM）</strong>：</p><ul><li>WDM是一种光纤通信中常用的技术，它使用不同的光波长（波长）来传输多个独立的信号。</li><li>每个波长代表一个独立的通道，可以传输不同数据流。</li><li>WDM广泛应用于长距离光纤通信和光网络中。</li></ul></li><li><p><strong>码分多址（Code Division Multiple Access，CDMA）</strong>：</p><ul><li>CDMA是一种无线通信技术，允许多个用户在相同的频率范围内传输数据，而不会相互干扰。</li><li>每个用户使用唯一的编码序列，使接收端能够将特定用户的信号从混合信号中分离出来。</li><li>CDMA用于3G和4G移动通信网络中。</li></ul></li><li><p><strong>统计复用</strong>：</p><ul><li>统计复用技术根据信号的需求动态分配传输资源，以提高资源的利用率。</li><li>与固定分配不同，统计复用允许多个用户共享资源，但可能需要处理竞争和碰撞等问题。</li><li>统计复用广泛用于以太网和互联网通信中。</li></ul></li></ol><p>不同的多路复用技术适用于不同的通信场景和需求。选择正确的多路复用技术取决于网络设计的要求、资源可用性以及传输媒体的特性。这些技术在提高通信系统效率、增加容量和满足多用户需求方面都发挥了关键作用。</p>]]></content>
    
    
    <summary type="html">🍔本文汇总计算机三级网络技术考试内容</summary>
    
    
    
    <category term="网络" scheme="https://momoao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://momoao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://momoao.github.io/posts/202308290811.html"/>
    <id>https://momoao.github.io/posts/202308290811.html</id>
    <published>2023-08-29T07:33:03.000Z</published>
    <updated>2023-08-29T01:40:21.882Z</updated>
    
    <content type="html"><![CDATA[<h1>JavaScript</h1><h2 id="所有数据类型">所有数据类型</h2><p>JavaScript支持多种数据类型，这些数据类型可以根据其特性和用途进行分类。以下是JavaScript中的主要数据类型：</p><ol><li><p><strong>基本数据类型（Primitive Data Types）</strong>：</p><ul><li><strong>String</strong>（字符串）：表示文本数据，使用单引号或双引号括起来。</li><li><strong>Number</strong>（数字）：表示数值，可以是整数或浮点数。</li><li><strong>Boolean</strong>（布尔）：表示逻辑值，只有两个可能的值：<code>true</code>（真）和<code>false</code>（假）。</li><li><strong>null</strong>：表示空值或无值。</li><li><strong>undefined</strong>：表示未定义的值。</li></ul></li><li><p><strong>复杂数据类型（Complex Data Types）</strong>：</p><ul><li><strong>Object</strong>（对象）：表示一个键值对集合，可以包含属性和方法。对象可以用花括号 <code>&#123;&#125;</code> 来定义。</li><li><strong>Array</strong>（数组）：表示有序的列表，包含一组值。数组可以用方括号 <code>[]</code> 来定义。</li><li><strong>Function</strong>（函数）：表示可执行的代码块，可以被调用执行。</li></ul></li><li><p><strong>特殊数据类型</strong>：</p><ul><li><strong>Symbol</strong>（符号）：ES6引入的数据类型，表示唯一的、不可变的值，主要用于创建对象属性的唯一键。</li></ul></li><li><p><strong>包装对象（Wrapper Objects）</strong>：</p><ul><li>JavaScript为基本数据类型提供了相应的包装对象，使其可以像对象一样访问属性和方法。例如，<code>String</code>、<code>Number</code> 和 <code>Boolean</code>。</li></ul></li></ol><p>这些数据类型在JavaScript中具有不同的特性和用途。例如，字符串用于处理文本，数字用于数值计算，对象和数组用于组织和存储数据，函数用于封装可执行的代码块等。</p><p>在JavaScript中，数据类型通常是动态的，这意味着变量的类型可以在运行时改变。这种灵活性使JavaScript非常适合用于各种应用程序，从网页交互到服务器端开发。</p><h3 id="null和undefined和NAN的区别">null和undefined和NAN的区别</h3><p><code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都是 JavaScript 中表示特殊值或特定情况的值，它们在含义和用法上有所不同：</p><ol><li><p><strong>null</strong>：</p><ul><li><code>null</code> 表示一个空值或缺失值。</li><li>当您想要明确地表示一个变量没有值时，可以将其赋值为 <code>null</code>。</li><li><code>null</code> 是一个原始数据类型，表示一个空的或无效的对象引用。</li><li>在逻辑判断中，<code>null</code> 被视为一个&quot;假值&quot;（falsey value），但不等于布尔值 <code>false</code>。</li></ul></li><li><p><strong>undefined</strong>：</p><ul><li>当声明了一个变量但没有为其赋值时，它的值就是 <code>undefined</code>。</li><li>函数没有显式返回值时，默认返回 <code>undefined</code>。</li><li>访问对象上不存在的属性时，返回的值也是 <code>undefined</code>。</li><li>在逻辑判断中，<code>undefined</code> 被视为一个&quot;假值&quot;（falsey value），但不等于布尔值 <code>false</code>。</li></ul></li><li><p><strong>NaN</strong>（Not-a-Number）：</p><ul><li><code>NaN</code> 表示一个非数字的值，通常在进行数学运算出错时返回。</li><li>例如，字符串解析成数字失败时，结果就是 <code>NaN</code>。</li><li><code>NaN</code> 是一个特殊的数值，它与任何其他值都不相等，包括自身。因此，<code>NaN !== NaN</code>。</li><li>在逻辑判断中，<code>NaN</code> 被视为一个&quot;假值&quot;（falsey value），但不等于布尔值 <code>false</code>。</li></ul></li></ol><p>总结区别：</p><ul><li><code>null</code> 表示明确的空值或缺失值，是一个赋值的操作，属于原始数据类型。</li><li><code>undefined</code> 表示未定义的值，可以是变量声明但未赋值，函数未返回值等情况。</li><li><code>NaN</code> 表示非数字的值，通常在数学运算出错时返回，属于数值类型。</li><li>在逻辑判断中，<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都被视为&quot;假值&quot;，但不等于布尔值 <code>false</code>。</li></ul><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出：null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> parsedNumber = <span class="built_in">parseInt</span>(c);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parsedNumber); <span class="comment">// 输出：NaN</span></span><br></pre></td></tr></table></figure><p>了解这些特殊值的含义和行为可以帮助您更好地处理变量赋值、逻辑判断和数学运算等情况。</p><h2 id="基本语法">基本语法</h2><ul><li>JavaScript的语法与许多其他编程语言相似，包括变量、数据类型、运算符等。</li><li>定义变量使用 <code>var</code>、<code>let</code> 或 <code>const</code>，其中 <code>let</code> 和 <code>const</code> 是ES6引入的新声明方式。</li><li>基本数据类型包括数字、字符串、布尔值，以及特殊值 <code>null</code> 和 <code>undefined</code>。</li><li>使用 <code>+</code> 运算符可以连接字符串，执行数字相加。</li><li>条件语句如 <code>if</code>、<code>else if</code> 和 <code>else</code> 用于控制代码的执行路径。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量和数据类型</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件语句</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Number is greater than 5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Number is not greater than 5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="var、let、const的区别">var、let、const的区别</h3><p>在JavaScript中，<code>var</code>、<code>let</code>和<code>const</code>是用于声明变量的关键字，它们在作用域、可变性和生命周期等方面有不同的行为。以下是它们的主要区别：</p><ol><li><p><strong>var</strong>：</p><ul><li><code>var</code> 是在ES5中引入的变量声明关键字。</li><li>变量声明提升：在作用域内，<code>var</code> 声明的变量会被提升到作用域的顶部。这意味着您可以在声明之前引用变量。</li><li>没有块级作用域：<code>var</code> 声明的变量在函数作用域内有效，而不仅仅是在块（如循环或条件语句）中有效。</li><li>允许重复声明：在同一作用域内，您可以多次使用 <code>var</code> 声明同一个变量。</li></ul></li><li><p><strong>let</strong>：</p><ul><li><code>let</code> 是在ES6中引入的块级作用域变量声明关键字。</li><li>块级作用域：<code>let</code> 声明的变量仅在其声明的块内有效，不会提升到作用域的顶部。</li><li>不允许重复声明：在同一作用域内，不允许使用 <code>let</code> 重复声明同一个变量。</li></ul></li><li><p><strong>const</strong>：</p><ul><li><code>const</code> 也是在ES6中引入的，用于声明常量，即一旦赋值后就不能再改变的变量。</li><li>块级作用域：<code>const</code> 同样遵循块级作用域规则，只在其声明的块内有效。</li><li>必须初始化：在声明 <code>const</code> 变量时必须进行初始化，否则会引发错误。</li><li>常量值不可变：一旦赋值，<code>const</code> 变量的值就不能再改变。</li></ul></li></ol><p>总结区别：</p><ul><li>使用 <code>var</code> 可能会导致变量提升和难以预测的作用域行为。它的使用已经逐渐被 <code>let</code> 和 <code>const</code> 取代。</li><li><code>let</code> 允许在块级作用域内声明变量，并且变量的值可以重新赋值。</li><li><code>const</code> 用于声明常量，变量的值在初始化后不能更改，并且也遵循块级作用域。</li></ul><p>推荐在现代JavaScript代码中使用 <code>let</code> 和 <code>const</code> 来获得更严格的作用域控制和代码可维护性。</p><h2 id="函数">函数</h2><ul><li>使用 <code>function</code> 关键字定义函数。函数可以接受参数，也可以返回值。</li><li>可以使用匿名函数（无名函数），也可以使用命名函数。</li><li>函数可以在其他函数中调用，也可以作为回调传递给其他函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> multiply = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">3</span>, <span class="number">5</span>));       <span class="comment">// 输出：8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiply</span>(<span class="number">2</span>, <span class="number">4</span>)); <span class="comment">// 输出：8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数组和对象">数组和对象</h2><ul><li>数组用于存储多个值，可以通过索引访问。使用方括号 <code>[]</code> 创建数组。</li><li>对象用于存储键值对，每个键对应一个值。使用大括号 <code>&#123;&#125;</code> 创建对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Johnson&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers[<span class="number">2</span>]);        <span class="comment">// 输出：3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">firstName</span>);  <span class="comment">// 输出：&quot;Alice&quot;</span></span><br></pre></td></tr></table></figure><h2 id="循环">循环</h2><ul><li>使用 <code>for</code> 循环和 <code>while</code> 循环可以重复执行一组操作。</li><li><code>for...of</code> 循环用于遍历数组等可迭代对象的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while 循环</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件和DOM操作">事件和DOM操作</h2><ul><li>JavaScript可以用于操作网页上的元素。通过DOM（文档对象模型）可以获取和修改HTML元素。</li><li>使用 <code>addEventListener</code> 来附加事件处理程序，例如点击事件、鼠标移动等。</li></ul><!DOCTYPE html><html><head>  <title>DOM Example</title></head><body>  <button id="myButton">Click Me</button>  <script>    const button = document.getElementById('myButton');    button.addEventListener('click', () => {      alert('Button Clicked!');    });  </script></body></html><h2 id="异步编程">异步编程</h2><ul><li>JavaScript中的异步编程非常重要。可以使用回调函数、Promise和async/await来处理异步操作，如定时器、网络请求等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 setTimeout 模拟异步操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;End&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="JSON">JSON</h2><ul><li>JSON（JavaScript Object Notation）是一种数据格式，用于表示结构化数据。它在JavaScript中广泛使用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Jane&quot;, &quot;age&quot;: 25&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> parsedData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonData);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parsedData.<span class="property">name</span>); <span class="comment">// 输出：&quot;Jane&quot;</span></span><br></pre></td></tr></table></figure><h2 id="模块化">模块化</h2><ul><li>在大型项目中，模块化使代码更有组织性。可以使用 <code>import</code> 和 <code>export</code> 关键字进行模块导入和导出。</li><li>在模块中不使用export导出的内容时私有的，别的模块中不能使用import引用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 输出：7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🍔本文汇总JavaScript的基础知识点</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JavaScript" scheme="https://momoao.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://momoao.github.io/posts/202308281533.html"/>
    <id>https://momoao.github.io/posts/202308281533.html</id>
    <published>2023-08-28T07:33:03.000Z</published>
    <updated>2023-08-29T00:10:26.364Z</updated>
    
    <content type="html"><![CDATA[<h1>Java反射</h1><h1>概念</h1><p>1.反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。</p><p>2.反射可以在一个类运行的时候获取类的信息的机制，可以获取在编译期不可能获得的类的信息。</p><p>3.对于任意一个对象，都能调用它的任意一个方法和属性。</p><p>4.因为类的信息是保存在Class对象中的，而这个Class对象是在程序运行时被类加载器（ClassLoader）动态加载的。</p><p>5.当类加载器装载运行了类后，动态获取Class对象的信息以及动态操作Class对象的属性和方法的功能称为Java的反射机制。</p><h1>作用</h1><p>1.反编译：.class —&gt; .java。</p><p>2.通过反射机制访问Java对象中的属性、方法、构造方法等。</p><h1>反射原理</h1><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/format,png.png" alt="img"></p><h1>类加载过程</h1><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/image-20230523192847278.png" alt="image-20230523192847278"></p><p>Java的反射就是利用上面第二步加载到jvm中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。</p><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p><h2 id="类加载器层次结构">类加载器层次结构</h2><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/image-20230523193541423.png" alt="image-20230523193541423"></p><h2 id="获取class的三种结构">获取class的三种结构</h2><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/format,png-16848418498382.png" alt="img"></p><h2 id="class类常用方法">class类常用方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>String getName()</code></td><td>返回类的全限定名。</td></tr><tr><td><code>Class&lt;?&gt; getSuperclass()</code></td><td>返回父类的Class对象。</td></tr><tr><td><code>Class&lt;?&gt;[] getInterfaces()</code></td><td>返回实现的接口的Class对象数组。</td></tr><tr><td><code>boolean isInterface()</code></td><td>判断是否是接口。</td></tr><tr><td><code>boolean isAssignableFrom(Class&lt;?&gt; cls)</code></td><td>判断是否可以赋值给指定的类。</td></tr><tr><td><code>Object newInstance()</code></td><td>创建该类的实例。</td></tr><tr><td><code>Field[] getFields()</code></td><td>返回所有公共字段的数组，包括父类的字段。</td></tr><tr><td><code>Field getField(String name)</code></td><td>返回指定名称的公共字段，包括父类的字段。</td></tr><tr><td><code>Field[] getDeclaredFields()</code></td><td>返回当前类声明的所有字段的数组，不包括父类的字段。</td></tr><tr><td><code>Field getDeclaredField(String name)</code></td><td>返回当前类声明的指定名称的字段，不包括父类的字段。</td></tr><tr><td><code>Method[] getMethods()</code></td><td>返回所有公共方法的数组，包括父类的方法。</td></tr><tr><td><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>返回指定名称和参数类型的公共方法，包括父类的方法。</td></tr><tr><td><code>Method[] getDeclaredMethods()</code></td><td>返回当前类声明的所有方法的数组，不包括父类的方法。</td></tr><tr><td><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>返回当前类声明的指定名称和参数类型的方法，不包括父类的方法。</td></tr><tr><td><code>Constructor&lt;?&gt;[] getConstructors()</code></td><td>返回所有公共构造函数的数组。</td></tr><tr><td><code>Constructor&lt;?&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></td><td>返回指定参数类型的公共构造函数。</td></tr><tr><td><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code></td><td>返回当前类声明的所有构造函数的数组。</td></tr><tr><td><code>Constructor&lt;?&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td><td>返回当前类声明的指定参数类型的构造函数。</td></tr></tbody></table><p>作者总结的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">getName()：获得类的完整名字。</span><br><span class="line"></span><br><span class="line">getFields()：获得类的<span class="keyword">public</span>类型的属性。</span><br><span class="line"></span><br><span class="line">getDeclaredFields()：获得类的所有属性。包括<span class="keyword">private</span> 声明的和继承类</span><br><span class="line"></span><br><span class="line">getMethods()：获得类的<span class="keyword">public</span>类型的方法。</span><br><span class="line"></span><br><span class="line">getDeclaredMethods()：获得类的所有方法。包括<span class="keyword">private</span> 声明的和继承类</span><br><span class="line"></span><br><span class="line">getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</span><br><span class="line"></span><br><span class="line">getConstructors()：获得类的<span class="keyword">public</span>类型的构造方法。</span><br><span class="line"></span><br><span class="line">getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</span><br><span class="line"></span><br><span class="line">newInstance()：通过类的构造方法创建这个类的一个对象。</span><br></pre></td></tr></table></figure><h1>Class类能实现的功能</h1><h2 id="能实现的功能">能实现的功能</h2><p>1判断对象属于哪个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">Class class2= person.getClass();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;class2：&quot;</span>+class2);</span><br><span class="line"></span><br><span class="line">输出：class2：<span class="keyword">class</span> <span class="title class_">reflect</span>.Person</span><br></pre></td></tr></table></figure><p>2获取类信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">Method[] methods = class1.getMethods();</span><br><span class="line"></span><br><span class="line">Method[] declaredMethods = class1.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">Field[] declaredFields = class1.getDeclaredFields();</span><br></pre></td></tr></table></figure><p>3构建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">Class class2= person.getClass();</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> class2.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//强转前先用instanceof判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line"></span><br><span class="line">((Person) o).workIng();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4动态执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">work</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;work&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">work.invoke(person);</span><br></pre></td></tr></table></figure><p>5动态操作属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflect.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">field.set(person,<span class="string">&quot;pine&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="动态赋值和普通赋值的区别">动态赋值和普通赋值的区别</h2><p><img src="image/Java%E5%8F%8D%E5%B0%84_Image/image-20230523201134659.png" alt="image-20230523201134659"></p>]]></content>
    
    
    <summary type="html">🍔本文汇总Java反射的知识点</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://momoao.github.io/posts/202308281529.html"/>
    <id>https://momoao.github.io/posts/202308281529.html</id>
    <published>2023-08-28T07:30:03.000Z</published>
    <updated>2023-08-28T07:30:10.788Z</updated>
    
    <content type="html"><![CDATA[<h1>Spring</h1><h1>开发步骤</h1><ol><li><p>导入Spring开发的基本包坐标</p><p><img src="../assets/image/Spring_Image/image-20230524091130200.png" alt="image-20230524091130200"></p></li><li><p>编写Dao接口和实现类</p></li><li><p>创建Spring核心配置文件</p></li><li><p>在Spring配置文件中配置UserDaoImpl</p></li><li><p>使用Spring的API获得Bean实例</p><p><img src="../assets/image/Spring_Image/image-20230524093003542.png" alt="image-20230524093003542"></p></li></ol><h1>Spring配置文件</h1><p>默认使用无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="scope属性值">scope属性值</h2><p><img src="../assets/image/Spring_Image/image-20230524093629771.png" alt="image-20230524093629771"></p><h3 id="singleton模式">singleton模式</h3><p><img src="../assets/image/Spring_Image/image-20230524100219430.png" alt="image-20230524100219430"></p><h3 id="prototype模式">prototype模式</h3><p><img src="../assets/image/Spring_Image/image-20230524110346654.png" alt="image-20230524110346654"></p><p><img src="../assets/image/Spring_Image/image-20230524110356913.png" alt="image-20230524110356913"></p><h3 id="这两个模式创建Bean的时机不同">这两个模式创建Bean的时机不同</h3><ul><li><p>singleton模式</p><ul><li><p>在</p></li><li><pre><code>ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationCOntext.xml&quot;);<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">    -</span>   时就创建了Bean</span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span>   证明：</span><br><span class="line"></span><br><span class="line"><span class="bullet">        -</span>   ![<span class="string">image-20230524111351773</span>](<span class="link">../assets/image/Spring_Image/image-20230524111351773.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">        -</span>   在创建ApplicationContext对象的时候这个类的无参构造被调用了</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span>   prototype模式</span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span>   在</span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span>   <span class="code">```</span></span><br><span class="line"><span class="code">        UserDao userDao1 = (UserDao) app.getBean(&quot;userDao&quot;);</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>时创建了Bean</p></li></ul></li></ul><h1>Bean实现对象实例化的三种方式</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    无参构造--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    默认使用无参构造方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    工厂静态--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    工厂实例--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    工厂标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.DynamicFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    这个标签指定工厂bean、工厂方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1>将UserDao注入给UserService的方法</h1><h2 id="构造方法">构造方法</h2><p>通过有参构造将UserDao写在UserService的构造方法参数中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="set方法">set方法</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        这里name的userDao是setUserDao()名字中set后面的，但是首字母小写--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        这类ref中的userDao是上面那个bean的id--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        这个标签的用处是将bean userDao通过setUserDao()注入到bean userService中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../assets/image/Spring_Image/image-20230524164039354.png" alt="image-20230524164039354"></p><p><img src="../assets/image/Spring_Image/image-20230524171224135.png" alt="image-20230524171224135"></p><h3 id="p命名空间注入（本质也是set注入）">p命名空间注入（本质也是set注入）</h3><p>在beans标签中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这种注入方法只需要改xml文件，不需要在UserServiceImpl类中创建setUserDao()4</p><p><strong>以上讲的是引用类型数据的注入，下面讲普通数据类型和集合类型的注入</strong></p><h1>普通类型数据和引用类型的注入</h1><p><img src="../assets/image/Spring_Image/image-20230524192930799.png" alt="image-20230524192930799"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoimpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;strList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>ppp1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>ppp2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jerry&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上海&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Bean标签的常用方法</h1><p><img src="../assets/image/Spring_Image/image-20230524201233971.png" alt="image-20230524201233971"></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>指定bean的唯一标识符。</td></tr><tr><td>class</td><td>指定bean的类名。</td></tr><tr><td>name</td><td>指定bean的名称。可以使用逗号或分号分隔多个名称。</td></tr><tr><td>scope</td><td>指定bean的作用域，如singleton（单例）、prototype（原型）等。</td></tr><tr><td>constructor-arg</td><td>指定bean的构造函数参数。可以通过<code>&lt;value&gt;</code>或<code>&lt;ref&gt;</code>子元素来指定值或引用其他bean。</td></tr><tr><td>property</td><td>指定bean的属性。可以通过<code>&lt;value&gt;</code>或<code>&lt;ref&gt;</code>子元素来指定值或引用其他bean。</td></tr><tr><td>init-method</td><td>指定bean初始化时调用的方法。</td></tr><tr><td>destroy-method</td><td>指定bean销毁时调用的方法。</td></tr><tr><td>autowire</td><td>指定自动装配的方式，如byName、byType、constructor等。</td></tr><tr><td>lazy-init</td><td>指定是否延迟初始化bean。</td></tr><tr><td>depends-on</td><td>指定bean的依赖关系，即在当前bean实例化之前需要先实例化的其他bean。</td></tr><tr><td>factory-bean</td><td>指定一个工厂bean的名称，用于创建当前bean实例。</td></tr><tr><td>factory-method</td><td>指定工厂bean中用于创建当前bean实例的静态方法。</td></tr></tbody></table><h1>getBean()使用</h1><p><img src="../assets/image/Spring_Image/image-20230525093249319.png" alt="image-20230525093249319"></p><p>因为</p><p><img src="../assets/image/Spring_Image/image-20230525092849583.png" alt="image-20230525092849583"></p><p>但是如果有两个bean，还通过.getBean(UserService.class)获取对象就会报错。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是<span class="keyword">Object</span>，需要强转。</span><br><span class="line">当参数的数据类型是<span class="keyword">Class</span>类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错</span><br></pre></td></tr></table></figure><h1>Spring配置数据源</h1><h2 id="方法一">方法一</h2><p><img src="../assets/image/Spring_Image/image-20230525161326550.png" alt="image-20230525161326550"></p><h2 id="方法二">方法二</h2><p><img src="../assets/image/Spring_Image/image-20230525161340641.png" alt="image-20230525161340641"></p><h2 id="方法三">方法三</h2><p><img src="../assets/image/Spring_Image/image-20230525161359050.png" alt="image-20230525161359050"></p><p><img src="../assets/image/Spring_Image/image-20230525161415108.png" alt="image-20230525161415108"></p><h2 id="方法四">方法四</h2><p>这种方法虽然方便，但是每种配置文件都应该有自己的职责</p><p>例如xml配置spring用</p><p>而mysql的配置放在properties中更好一些</p><p>方法五将对这种方法进行优化</p><p><img src="../assets/image/Spring_Image/image-20230525161438908.png" alt="image-20230525161438908"></p><p><img src="../assets/image/Spring_Image/image-20230525161446087.png" alt="image-20230525161446087"></p><h2 id="方法五">方法五</h2><h3 id="在xml文件中创建命名空间context">在xml文件中创建命名空间context</h3><p>复制xmlns那行粘贴在下面，后面加:context，把beans改为context</p><p>在xsi:schemaLocation的值的字符串中添加一行新数据（注意在一个字符串中），把beans改为context</p><p><img src="../assets/image/Spring_Image/image-20230525162300727.png" alt="image-20230525162300727"></p><h3 id="加载外部配置文件">加载外部配置文件</h3><p><img src="../assets/image/Spring_Image/image-20230525162501007.png" alt="image-20230525162501007"></p><p>然后就可以在bean中使用properties了</p><p><img src="../assets/image/Spring_Image/image-20230525162631930.png" alt="image-20230525162631930"></p><p>test方法中使用bean</p><p><img src="../assets/image/Spring_Image/image-20230525162821705.png" alt="image-20230525162821705"></p><h1>Spring注解开发</h1><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p><p>Spring原始注解主要是替代<Bean>的配置</p><h2 id="原始注解">原始注解</h2><p>Spring原始注解：</p><p>2、3、4号注解和1号作用一样，只是在不同的层使用不同的注解可读性强一些</p><table><thead><tr><th><strong>注解</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td>@Component</td><td style="text-align:left">使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td style="text-align:left">使用在web层类上用于实例化Bean</td></tr><tr><td>@Service</td><td style="text-align:left">使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td style="text-align:left">使用在dao层类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td style="text-align:left">使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td style="text-align:left">结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resource</td><td style="text-align:left">相当于@Autowired+@Qualifier，按照名称进行注入</td></tr><tr><td>@Value</td><td style="text-align:left">注入普通属性</td></tr><tr><td>@Scope</td><td style="text-align:left">标注Bean的作用范围</td></tr><tr><td>@PostConstruct</td><td style="text-align:left">使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestroy</td><td style="text-align:left">使用在方法上标注该方法是Bean的销毁方法</td></tr></tbody></table><h3 id="引用数据类型注入">引用数据类型注入</h3><p>不使用注解时的开发：</p><p><img src="../assets/image/Spring_Image/image-20230525174516514.png" alt="image-20230525174516514"></p><p>使用注解的开发：</p><p><img src="../assets/image/Spring_Image/image-20230525174739036.png" alt="image-20230525174739036"></p><p><img src="../assets/image/Spring_Image/image-20230525174750940.png" alt="image-20230525174750940"></p><p><img src="../assets/image/Spring_Image/image-20230525174756764.png" alt="image-20230525174756764"></p><p>上面这个代码也可以不写set()，在属性上面写两个注解：</p><p><img src="../assets/image/Spring_Image/image-20230525175234254.png" alt="image-20230525175234254"></p><p>甚至不用@Qualifier(“userDao”)也可以</p><p>这种就是Spring根据数据类型从容器中获取（找UserDao类型的bean进行注入），但是只能有一个UserDao类型的bean，如果有多个就必须通过@Qualifier(“userDao”)来指定注入bean的id</p><p>@Qualifier每次使用都要和@Autowired搭配使用，反之则不必须</p><p><img src="../assets/image/Spring_Image/image-20230525175305381.png" alt="image-20230525175305381"></p><h3 id="普通数据类型的注入">普通数据类型的注入</h3><p><img src="../assets/image/Spring_Image/image-20230525175940199.png" alt="image-20230525175940199"></p><p><img src="../assets/image/Spring_Image/image-20230525180137750.png" alt="image-20230525180137750"></p><p>使用上面这种时记得在xml添加外部配置文件</p><p><img src="../assets/image/Spring_Image/image-20230525180235443.png" alt="image-20230525180235443"></p><p>使用注解注入bean的scope属性</p><p><img src="../assets/image/Spring_Image/image-20230525180353087.png" alt="image-20230525180353087"></p><p>只用注解指定bean的初始化和销毁方法</p><p><img src="../assets/image/Spring_Image/image-20230525180746096.png" alt="image-20230525180746096"></p><h2 id="新注解">新注解</h2><p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下：</p><p><img src="../assets/image/Spring_Image/image-20230525181241227.png" alt="image-20230525181241227"></p><p>所以需要更多的注解</p><p>新注解：</p><p><img src="../assets/image/Spring_Image/image-20230525181337349.png" alt="image-20230525181337349"></p><p>通过注解使用配置文件中的数据</p><p>主配置类：</p><p><img src="../assets/image/Spring_Image/image-20230525183645266.png" alt="image-20230525183645266"></p><p>数据源配置类：</p><p>主要负责获得数据源（例如：读取配置文件中的信息再连接MySQL）</p><p><img src="../assets/image/Spring_Image/image-20230525183738657.png" alt="image-20230525183738657"></p><p>将配置文件中的数据读到属性中才能使用</p><p><img src="../assets/image/Spring_Image/image-20230525183837510.png" alt="image-20230525183837510"></p><p>在使用@Bean(“dataSource”)将方法的返回值，放到容器中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spring会将当前方法的返回值已指定名称存储到Spring的容器中</span><br><span class="line">和<span class="meta">@Component</span>不同的地方：</span><br><span class="line"><span class="meta">@Component</span>是通过类创建bean放到容器，可能通过</span><br><span class="line">  <span class="meta">@Autowired</span>和 <span class="meta">@Qualifier</span>对引用值注入</span><br><span class="line">  <span class="meta">@Value</span>对普通数据类型注入</span><br><span class="line">而<span class="meta">@Bean</span>是把经过方法处理的数据放到容器中</span><br></pre></td></tr></table></figure><p><img src="../assets/image/Spring_Image/image-20230525183920925.png" alt="image-20230525183920925"></p><p>开发后的测试</p><p><img src="../assets/image/Spring_Image/image-20230525184150286.png" alt="image-20230525184150286"></p><h1>Spring整合JUnit</h1><p>因为：</p><p><img src="../assets/image/Spring_Image/image-20230525184729697.png" alt="image-20230525184729697"></p><p>解决思路：</p><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它</li><li>将需要进行测试Bean直接在测试类中进行注入</li></ul><p>Spring集成Junit步骤：</p><p><img src="../assets/image/Spring_Image/image-20230525184839840.png" alt="image-20230525184839840"></p><p>导入坐标</p><p><img src="../assets/image/Spring_Image/image-20230525191924851.png" alt="image-20230525191924851"></p><p>写测试类运行就可以使用</p><p><img src="../assets/image/Spring_Image/image-20230525193314457.png" alt="image-20230525193314457"></p><p>就算只运行test1()，也会从applicationContext.xml中读取需要的内容</p><p><img src="../assets/image/Spring_Image/image-20230525193502055.png" alt="image-20230525193502055"></p><p><img src="../assets/image/Spring_Image/image-20230525193733099.png" alt="image-20230525193733099"></p><p><img src="../assets/image/Spring_Image/image-20230525193800525.png" alt="image-20230525193800525"></p><p>不但可以通过xml文件进行测试，也可以通过配置类来测试</p><p><img src="../assets/image/Spring_Image/image-20230525195652352.png" alt="image-20230525195652352"></p><h1>SpringAOP</h1><h2 id="切面-切点-通知">切面=切点+通知</h2><p>什么是AOP</p><p><img src="../assets/image/Spring_Image/image-20230526151632822.png" alt="image-20230526151632822"></p><p>作用及其优势</p><p><img src="../assets/image/Spring_Image/image-20230526151657426.png" alt="image-20230526151657426"></p><p>底层实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</span><br></pre></td></tr></table></figure><h2 id="基于JDK的动态代理">基于JDK的动态代理</h2><h3 id="目标对象">目标对象</h3><p><img src="../assets/image/Spring_Image/image-20230526160309406.png" alt="image-20230526160309406"></p><h3 id="增强对象">增强对象</h3><p><img src="../assets/image/Spring_Image/image-20230526160320891.png" alt="image-20230526160320891"></p><p>使用增强对象 对 目标对象的功能进行增强</p><p><img src="../assets/image/Spring_Image/image-20230526160404843.png" alt="image-20230526160404843"></p><h2 id="基于cglib的动态代理">基于cglib的动态代理</h2><p>maven官方整合了cglib这个第三方包</p><p><img src="../assets/image/Spring_Image/image-20230526173343588.png" alt="image-20230526173343588"></p><h2 id="AOP相关概念">AOP相关概念</h2><p><img src="../assets/image/Spring_Image/image-20230526185340919.png" alt="image-20230526185340919"></p><h2 id="AOP-开发明确的事项">AOP 开发明确的事项</h2><p><img src="../assets/image/Spring_Image/image-20230526190210094.png" alt="image-20230526190210094"></p><h2 id="xml实现AOP">xml实现AOP</h2><h3 id="通知（增强）的类型">通知（增强）的类型</h3><p><img src="../assets/image/Spring_Image/image-20230527163019327.png" alt="image-20230527163019327"></p><p>增加aop命名空间</p><p><img src="../assets/image/Spring_Image/image-20230527093235236.png" alt="image-20230527093235236"></p><h3 id="使用前后置方法进行增强">使用前后置方法进行增强</h3><p>xml中的配置</p><p><img src="../assets/image/Spring_Image/image-20230527093347536.png" alt="image-20230527093347536"></p><p>使用Spring中整合的JUnit进行测试</p><p><img src="../assets/image/Spring_Image/image-20230527093414356.png" alt="image-20230527093414356"></p><p>运行结果</p><p><img src="../assets/image/Spring_Image/image-20230527093427571.png" alt="image-20230527093427571"></p><p>切点表达式的写法：</p><p><img src="../assets/image/Spring_Image/image-20230527102831520.png" alt="image-20230527102831520"></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">指定固定的某个方法，这种表达式不常用</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.aop.Target.method())</span><br><span class="line">    </span><br><span class="line">指定Target类下的所有<span class="keyword">void</span>方法</span><br><span class="line">execution(<span class="keyword">void</span> com.itheima.aop.Target.*(..))</span><br><span class="line">    </span><br><span class="line">指定aop包下的所有类的所有方法，并且返回值任意</span><br><span class="line">execution(* com.itheima.aop.*.*(..))</span><br><span class="line">    </span><br><span class="line">指定aop包及其子包下的所有类的所有方法，并且返回值任意   </span><br><span class="line">execution(* com.itheima.aop..*.*(..))</span><br><span class="line">    </span><br><span class="line">这种没有什么意义</span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure><h3 id="使用环绕方法进行增强">使用环绕方法进行增强</h3><p>效果和前后置一样</p><p><img src="../assets/image/Spring_Image/image-20230527162023399.png" alt="image-20230527162023399"></p><p>将之前写在两个方法中的内容，在一个环绕方法中实现</p><p><img src="../assets/image/Spring_Image/image-20230527162031929.png" alt="image-20230527162031929"></p><h3 id="对方法的异常处理进行增强">对方法的异常处理进行增强</h3><p>在配置文件中</p><p><img src="../assets/image/Spring_Image/image-20230527162414419.png" alt="image-20230527162414419"></p><p>在目标方法中写一个异常</p><p><img src="../assets/image/Spring_Image/image-20230527162421234.png" alt="image-20230527162421234"></p><p>在MyAspect类中新增一个用于异常处理的方法</p><p><img src="../assets/image/Spring_Image/image-20230527162431636.png" alt="image-20230527162431636"></p><h3 id="最终增强">最终增强</h3><p>在MyAspect类中新增一个用于最终增强的方法</p><p><img src="../assets/image/Spring_Image/image-20230527162649720.png" alt="image-20230527162649720"></p><p>xml中进行配置</p><p><img src="../assets/image/Spring_Image/image-20230527162714155.png" alt="image-20230527162714155"></p><p>执行结果</p><p><img src="../assets/image/Spring_Image/image-20230527162918780.png" alt="image-20230527162918780"></p><p>有异常时的增强</p><p><img src="../assets/image/Spring_Image/image-20230527162938700.png" alt="image-20230527162938700"></p><h3 id="xml中更好的写法">xml中更好的写法</h3><p>通过表达式</p><p><img src="../assets/image/Spring_Image/image-20230527173053857.png" alt="image-20230527173053857"></p><h2 id="基于注解的AOP开发">基于注解的AOP开发</h2><p>开发步骤</p><p><img src="../assets/image/Spring_Image/image-20230527173932228.png" alt="image-20230527173932228"></p><p>切点表达式用于指明对哪些方法进行增强</p><p>目标类用注解加载进容器中</p><p><img src="../assets/image/Spring_Image/image-20230527180726305.png" alt="image-20230527180726305"></p><p>带有通知的类通过注解加载到容器中，并指明这个类是切面类</p><p><img src="../assets/image/Spring_Image/image-20230527181017239.png" alt="image-20230527181017239"></p><p>将通知加载到容器中，需指明切点表达式</p><p><img src="../assets/image/Spring_Image/image-20230527181044398.png" alt="image-20230527181044398"></p><p>在xml中开启组件扫描、开启aop自动代理</p><p><img src="../assets/image/Spring_Image/image-20230527181139590.png" alt="image-20230527181139590"></p><p>在测试类中进行测试</p><p><img src="../assets/image/Spring_Image/image-20230527181156639.png" alt="image-20230527181156639"></p><p>基于注解的AOP开发的知识要点</p><p><img src="../assets/image/Spring_Image/image-20230527181339131.png" alt="image-20230527181339131"></p><h1>jdbc模板</h1><ol><li>创建数据源</li><li>创建模板</li><li>设置模板的数据源对象</li><li>执行操作</li></ol><p><img src="../assets/image/Spring_Image/image-20230527194006087.png" alt="image-20230527194006087"></p><p>将上面图片中的操作变为spring xml中的操作就是</p><p><img src="../assets/image/Spring_Image/image-20230527194833220.png" alt="image-20230527194833220"></p><p><img src="../assets/image/Spring_Image/image-20230527195216939.png" alt="image-20230527195216939"></p><p>把数据库信息放在properties中</p><p>添加命名空间、加载配置文件</p><p><img src="../assets/image/Spring_Image/image-20230527195632141.png" alt="image-20230527195632141"></p><p>用SpringJunit4进行测试</p><p><img src="../assets/image/Spring_Image/image-20230527200240194.png" alt="image-20230527200240194"></p><p>查询</p><p>查询多列（加多行）数据和单个数据</p><p><img src="../assets/image/Spring_Image/image-20230527203751932.png" alt="image-20230527203751932"></p><p>用Account类进行接受数据的操作</p><p>类中必须含有查询出来的结果的对应属性</p><p><strong>并且必须有这写属性的set()   可以没有get()</strong></p><p><strong>类的属性名和数据库的列名必须相同</strong></p><p><img src="../assets/image/Spring_Image/image-20230527204144865.png" alt="image-20230527204144865"></p><h2 id="知识要点">知识要点</h2><p><img src="../assets/image/Spring_Image/image-20230527204723426.png" alt="image-20230527204723426"></p><h1>Spring事务控制</h1><h2 id="编程式事务控制">编程式事务控制</h2><h3 id="TransactionDefinition">TransactionDefinition</h3><p><img src="../assets/image/Spring_Image/image-20230528171824146.png" alt="image-20230528171824146"></p><h3 id="事务隔离等级">事务隔离等级</h3><p>最后一个：串行化    相当于锁表</p><p><img src="../assets/image/Spring_Image/image-20230528172103438.png" alt="image-20230528172103438"></p><h3 id="事务传播行为">事务传播行为</h3><p><img src="../assets/image/Spring_Image/image-20230528172218278.png" alt="image-20230528172218278"></p><h3 id="TransactionStatus">TransactionStatus</h3><p><img src="../assets/image/Spring_Image/image-20230528173344446.png" alt="image-20230528173344446"></p><h3 id="编程式事务控制三大对象">编程式事务控制三大对象</h3><p>根据DAO层采用不同的技术时，用不同的对象控制</p><p><img src="../assets/image/Spring_Image/image-20230528174020171.png" alt="image-20230528174020171"></p><h2 id="声明式事务控制">声明式事务控制</h2><h3 id="基于XML">基于XML</h3><p>什么是声明式事务控制</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Spring</span> 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</span><br></pre></td></tr></table></figure><p>声明式事务处理的作用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</span><br><span class="line">在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</span><br></pre></td></tr></table></figure><p><strong>注意：Spring 声明式事务控制底层就是AOP</strong>（面向切面编程）</p><h3 id="实现步骤">实现步骤</h3><p><img src="../assets/image/Spring_Image/image-20230528175846163.png" alt="image-20230528175846163"></p><h4 id="在xml文件中">在xml文件中</h4><p>1.配置数据源</p><p><img src="../assets/image/Spring_Image/image-20230531090016333.png" alt="image-20230531090016333"></p><p>2.配置jdbc模板</p><p>里面注入数据源</p><p><img src="../assets/image/Spring_Image/image-20230531090144429.png" alt="image-20230531090144429"></p><p>3.配置自己写的持久层类</p><p>注入jdbc模板给这个类的属性</p><p><img src="../assets/image/Spring_Image/image-20230531090402268.png" alt="image-20230531090402268"></p><p><img src="../assets/image/Spring_Image/image-20230531090255770.png" alt="image-20230531090255770"></p><p>4.配置自己写的业务层类</p><p>注入持久层类</p><p><img src="../assets/image/Spring_Image/image-20230531090342933.png" alt="image-20230531090342933"></p><p><img src="../assets/image/Spring_Image/image-20230531090424272.png" alt="image-20230531090424272"></p><p>5.配置平台事务管理器</p><p>注入数据源</p><p><img src="../assets/image/Spring_Image/image-20230531090519305.png" alt="image-20230531090519305"></p><p>6.事务（事务管理器）的增强</p><p>先指定事务管理器</p><p>然后添加事务的属性</p><p>​[方法名]    [隔离等级]    [是否只读]</p><p>如果设置只读，name这个方法只能读数据库不能写</p><p><img src="../assets/image/Spring_Image/image-20230531092715160.png" alt="image-20230531092715160"></p><p>7.用aop将事务的增强织入到切点表达式中</p><p>虽然上面指定了需要事务控制的方法名，但是aop织入的时候也要指定将哪个事务增强织入到哪个切点表达式中</p><p><img src="../assets/image/Spring_Image/image-20230531090952569.png" alt="image-20230531090952569"></p><h3 id="基于注解的声明式事务控制">基于注解的声明式事务控制</h3><p>在xml中</p><p>开启组件扫描、添加数据源、添加jdbc模板、添加事务控制管理器、事务的注解驱动</p><p>其中jdbc模板和事务管理器都要注入数据源</p><p><strong>不加注解驱动注解可能不起作用</strong></p><p><img src="../assets/image/Spring_Image/image-20230531095808450.png" alt="image-20230531095808450"></p><p>持久层</p><p>注入jdbc模板</p><p><img src="../assets/image/Spring_Image/image-20230531095826459.png" alt="image-20230531095826459"></p><p>业务层</p><p>注入持久层</p><p>给需要事务控制的方法使用注解@Transactional</p><p>通过给注解添加属性(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)</p><p>实现隔离等级、传播、是否只读的设置</p><p><img src="../assets/image/Spring_Image/image-20230531095852416.png" alt="image-20230531095852416"></p><h1>Spring集成web环境</h1><p>pom.xml中添加两个新的坐标</p><p><img src="../assets/image/Spring_Image/image-20230601154914365.png" alt="image-20230601154914365"></p><p>web层</p><p><img src="../assets/image/Spring_Image/image-20230601160436675.png" alt="image-20230601160436675"></p><p>服务层</p><p><img src="../assets/image/Spring_Image/image-20230601160451287-16856066914451.png" alt="image-20230601160451287"></p><p>持久层</p><p><img src="../assets/image/Spring_Image/image-20230601160502709.png" alt="image-20230601160502709"></p><p>applicationContext.xml中把Dao注入到Service中</p><p><img src="../assets/image/Spring_Image/image-20230601160534406.png" alt="image-20230601160534406"></p><p>web层调用–&gt;Service–&gt;Dao</p><p>每次使用web层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>都要加载配置文件和创建应用上下文对象</p><p><img src="../assets/image/Spring_Image/image-20230601160821601.png" alt="image-20230601160821601"></p><p>解决方法：</p><p><img src="../assets/image/Spring_Image/image-20230601161003281.png" alt="image-20230601161003281"></p><h2 id="开发步骤">开发步骤</h2><h3 id="web-xml中">web.xml中</h3><p>配置全局上下文参数，在代码中可以通过name访问value的值</p><p>这样改配置文件的时候就不用改代码了</p><p><img src="../assets/image/Spring_Image/image-20230601181728122.png" alt="image-20230601181728122"></p><p>配置监听器</p><p><img src="../assets/image/Spring_Image/image-20230601181837657.png" alt="image-20230601181837657"></p><p>总结</p><p><img src="../assets/image/Spring_Image/image-20230601182916680.png" alt="image-20230601182916680"></p><p><strong>MVC == Model  View  Control</strong></p><h1>SpringMVC</h1><p>概述</p><p><img src="../assets/image/Spring_Image/image-20230601190911958.png" alt="image-20230601190911958"></p><h2 id="开发步骤-2">开发步骤</h2><p><img src="../assets/image/Spring_Image/image-20230602152213016.png" alt="image-20230602152213016"></p><h3 id="web-xml">web.xml</h3><p>配置前端控制器</p><p><img src="../assets/image/Spring_Image/image-20230602162411110.png" alt="image-20230602162411110"></p><p>配置全局初始化参数</p><p>将优先初始化这个资源xml文件</p><p><img src="../assets/image/Spring_Image/image-20230602162502572.png" alt="image-20230602162502572"></p><p>配置监听器</p><p><img src="../assets/image/Spring_Image/image-20230602162714540.png" alt="image-20230602162714540"></p><p>配置自己的映射</p><p>网址后加上/userServelet将运行com.itheima.web.UserServelet类中的doGet()</p><p><img src="../assets/image/Spring_Image/image-20230602162742705.png" alt="image-20230602162742705"></p><p><img src="../assets/image/Spring_Image/image-20230602162839136.png" alt="image-20230602162839136"></p><h3 id="applicationContext-xml">applicationContext.xml</h3><p><img src="../assets/image/Spring_Image/image-20230602162924426.png" alt="image-20230602162924426"></p><h3 id="spring-mvc-xml">spring-mvc.xml</h3><p>配置组件扫描，用于扫描包中的注解</p><p><img src="../assets/image/Spring_Image/image-20230602163017412.png" alt="image-20230602163017412"></p><h3 id="webapp">webapp</h3><p>下面创建一个网页success.jsp</p><p><img src="../assets/image/Spring_Image/image-20230602163052149.png" alt="image-20230602163052149"></p><p>在组件扫描的包中写个类，用于链接到success.jsp</p><p>该类使用@Controller将这个类加载到spring容器中</p><p>使用@RequestMapping(“/quick”)指定了网址，在网址后加上这个就可以访问这个方法返回的String指定位置的文件</p><p><img src="../assets/image/Spring_Image/image-20230602163141705.png" alt="image-20230602163141705"></p><h2 id="程序寻找顺序">程序寻找顺序</h2><p>输入localhost:8080/quick后</p><p>先找Tomcat</p><p>然后在web.xml因为有前端控制器并且</p><p><url-pattern>/</url-pattern></p><p>表示找任何地址都先经过这个控制器</p><p>然后就能找到/quick了</p><p><img src="../assets/image/Spring_Image/image-20230602163424126.png" alt="image-20230602163424126"></p><p>能找到/quick是因为资源配置文件spring-mvc.xml中开启了包com.itheima.controller的扫描</p><p><img src="../assets/image/Spring_Image/image-20230602163820093.png" alt="image-20230602163820093"></p><p>然后在这个包中有个类</p><p>通过注解将这个类加到了容器中，而用注解@RequestMapping(“/quick”)注解的方法，当输入这个网址时就会调用，执行完方法后，链接到返回的String指引的文件上</p><p><img src="../assets/image/Spring_Image/image-20230603110612766.png" alt="image-20230603110612766"></p><p>success.jsp文件中是html代码</p><p><img src="../assets/image/Spring_Image/image-20230602164008972.png" alt="image-20230602164008972"></p><h2 id="逻辑流程图">逻辑流程图</h2><p><img src="../assets/image/Spring_Image/image-20230603093641452.png" alt="image-20230603093641452"></p><h2 id="SpringMVC执行流程">SpringMVC执行流程</h2><p><img src="../assets/image/Spring_Image/image-20230603094019177.png" alt="image-20230603094019177"></p><h2 id="组件解析">组件解析</h2><p><img src="../assets/image/Spring_Image/image-20230603100720670.png" alt="image-20230603100720670"></p><p><img src="../assets/image/Spring_Image/image-20230603100743066.png" alt="image-20230603100743066"></p><p>在使用组件扫描时可以以指定扫描包含哪些注解或除去哪些注解</p><p><img src="../assets/image/Spring_Image/image-20230603141215035.png" alt="image-20230603141215035"></p><p>配置内部资源解析器</p><p>在配置之前，因为jsp文件都在jsp文件夹中，所以return的值要写前缀和后缀（.jsp）</p><p><img src="../assets/image/Spring_Image/image-20230603141255107.png" alt="image-20230603141255107"></p><p>配置之后，只需要写文件名</p><p><img src="../assets/image/Spring_Image/image-20230603141349511.png" alt="image-20230603141349511"></p><p>在spring-mvc.xml中配置</p><p>表示为每个带有@RequestMapping注解的方法返回的String加上前后缀</p><p><img src="../assets/image/Spring_Image/image-20230603141418537.png" alt="image-20230603141418537"></p><h2 id="注解解析">注解解析</h2><p><img src="../assets/image/Spring_Image/image-20230603100808598.png" alt="image-20230603100808598"></p><p>例如：</p><p><img src="../assets/image/Spring_Image/image-20230603111806588.png" alt="image-20230603111806588"></p><p>需要的url链接必须要有参数usernmae l</p><p><img src="../assets/image/Spring_Image/image-20230603111841101.png" alt="image-20230603111841101"></p><h2 id="SpringMVC相关组件">SpringMVC相关组件</h2><p><img src="../assets/image/Spring_Image/image-20230603141627910.png" alt="image-20230603141627910"></p><p>在return &quot;suuccess&quot;时默认前面带forward，意思是在当前网址后加上后访问的目录。如果写return &quot;redirect:suuccess&quot;就会把网址变为localhost:8080/success   而不是网址叠加</p><p><img src="../assets/image/Spring_Image/image-20230603142014109.png" alt="image-20230603142014109"></p><h1>浏览器请求方式</h1><p><img src="../assets/image/Spring_Image/image-20230603111430937.png" alt="image-20230603111430937"></p><h1>SpringMVC数据响应</h1><h2 id="数据响应方式">数据响应方式</h2><p><img src="../assets/image/Spring_Image/image-20230603142722394.png" alt="image-20230603142722394"></p><h3 id="页面跳转">页面跳转</h3><p>返回字符串形式</p><p><img src="../assets/image/Spring_Image/image-20230603143115529.png" alt="image-20230603143115529"></p><p>返回ModelAndView形式</p><p><img src="../assets/image/Spring_Image/image-20230603143228470.png" alt="image-20230603143228470"></p><p>数据在jsp文件中可以使用${键名}的方式提取</p><p><img src="../assets/image/Spring_Image/image-20230603143902717.png" alt="image-20230603143902717"></p><p><img src="../assets/image/Spring_Image/image-20230603143943620.png" alt="image-20230603143943620"></p><p>springMVC框架会检测参数，可以自动提供一个ModelAndView对象</p><p><img src="../assets/image/Spring_Image/image-20230603144544631.png" alt="image-20230603144544631"></p><p>也可以单独返回Model</p><p>但是不设置视图的话，会自动查找</p><p><img src="../assets/image/Spring_Image/image-20230603144831279.png" alt="image-20230603144831279"></p><p><img src="../assets/image/Spring_Image/image-20230603145121111.png" alt="image-20230603145121111"></p><h3 id="回写数据">回写数据</h3><h4 id="返回字符串">返回字符串</h4><p>方法1</p><p><img src="../assets/image/Spring_Image/image-20230603150457780.png" alt="image-20230603150457780"></p><p>方法2</p><p><img src="../assets/image/Spring_Image/image-20230603150536247.png" alt="image-20230603150536247"></p><p>返回json字符串，使用ObjectMapper将对象转换为json字符串</p><p><img src="../assets/image/Spring_Image/image-20230603151501882.png" alt="image-20230603151501882"></p><h4 id="返回对象或集合">返回对象或集合</h4><p>可以通过配置处理器映射器来告诉SpringMVC框架自动将消息转换</p><p>自动将返回的对象转换为json字符串</p><p><img src="../assets/image/Spring_Image/image-20230603152340236.png" alt="image-20230603152340236"></p><p><img src="../assets/image/Spring_Image/image-20230603152353202.png" alt="image-20230603152353202"></p><p>可以配置mvc注解驱动来让mvc自己调用映射器，而不用自己配置</p><p><img src="../assets/image/Spring_Image/image-20230603152959755.png" alt="image-20230603152959755"></p><p><strong>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。</strong></p><h1>SpringMVC获得请求数据</h1><p><img src="../assets/image/Spring_Image/image-20230603155305748.png" alt="image-20230603155305748"></p><h2 id="基本类型数据">基本类型数据</h2><p><img src="../assets/image/Spring_Image/image-20230603160109243.png" alt="image-20230603160109243"></p><h2 id="POJO类型参数">POJO类型参数</h2><p>输入的参数和User类的属性名一致，就可以自动封装</p><p><img src="../assets/image/Spring_Image/image-20230603160333507.png" alt="image-20230603160333507"></p><h2 id="数组类型参数">数组类型参数</h2><p><img src="../assets/image/Spring_Image/image-20230603160957402.png" alt="image-20230603160957402"></p><p><img src="../assets/image/Spring_Image/image-20230603161003841.png" alt="image-20230603161003841"></p><h2 id="集合类型参数">集合类型参数</h2><p>第一种方法</p><p>还是封装在类中</p><p><img src="../assets/image/Spring_Image/image-20230603172517789.png" alt="image-20230603172517789"></p><p><img src="../assets/image/Spring_Image/image-20230603172529481.png" alt="image-20230603172529481"></p><p>在jsp文件中使用表单提交集合对象，要求和类中的属性名一致。可以指定集合中第几个元素的某个属性</p><p><img src="../assets/image/Spring_Image/image-20230603172552484.png" alt="image-20230603172552484"></p><p>第二种方法</p><p>直接接收由浏览器页面发出的数据</p><p>使用jquery包中的方法，发送数据</p><p>访问ajax.jsp</p><p><img src="../assets/image/Spring_Image/image-20230604201620098.png" alt="image-20230604201620098"></p><p><img src="../assets/image/Spring_Image/image-20230604201336222.png" alt="image-20230604201336222"></p><p>并将jquery的访问权限开放，不然浏览器可能跳转到jquery时就停止跳转</p><p>在spring-mvc.xml中配置对jquery资源的访问权限</p><p><img src="../assets/image/Spring_Image/image-20230604202315828.png" alt="image-20230604202315828"></p><p>之后访问ajax.jsp，浏览器的跳转顺序就会这样</p><p><img src="../assets/image/Spring_Image/image-20230604202350908.png" alt="image-20230604202350908"></p><p>还有一种开放资源的办法</p><p><img src="../assets/image/Spring_Image/image-20230604203052408.png" alt="image-20230604203052408"></p><h2 id="参数绑定注解">参数绑定注解</h2><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。</p><p>如果网址后提交的参数不是username是name就这样改</p><p><img src="../assets/image/Spring_Image/image-20230604203429433.png" alt="image-20230604203429433"></p><p>改完之后就只能用name提交了，因为有这个注解的存在，会将name的值映射到username上</p><p>@RequestParam注解的其他参数</p><p><img src="../assets/image/Spring_Image/image-20230604203836242.png" alt="image-20230604203836242"></p><p>默认name参数不必须包含，提交后打印值为null</p><p><img src="../assets/image/Spring_Image/image-20230604203927135.png" alt="image-20230604203927135"></p><p><img src="../assets/image/Spring_Image/image-20230604203952230.png" alt="image-20230604203952230"></p><p>使用了默认值，提交后打印itcast</p><p><img src="../assets/image/Spring_Image/image-20230604204045987.png" alt="image-20230604204045987"></p><p><img src="../assets/image/Spring_Image/image-20230604204054637.png" alt="image-20230604204054637"></p><h2 id="获取Restful风格的参数">获取Restful风格的参数</h2><p>在网址中写入请求方式</p><p><img src="../assets/image/Spring_Image/image-20230605162451916.png" alt="image-20230605162451916"></p><p>@PathVariable中的value必须和@RequestMapping相同，但是可以和参数中的String不同</p><p><img src="../assets/image/Spring_Image/image-20230605162842599.png" alt="image-20230605162842599"></p><p>使用：</p><p><img src="../assets/image/Spring_Image/image-20230605163339876.png" alt="image-20230605163339876"></p><p><img src="../assets/image/Spring_Image/image-20230605163344930.png" alt="image-20230605163344930"></p><h2 id="自定义类型转换器">自定义类型转换器</h2><p><img src="../assets/image/Spring_Image/image-20230605163640580.png" alt="image-20230605163640580"></p><p>像这种int age框架虽然接收的是String，但是会自动转换后传给参数</p><p><img src="../assets/image/Spring_Image/image-20230605163703848.png" alt="image-20230605163703848"></p><p>手动实现类型转换</p><p>实现背景：</p><p><img src="../assets/image/Spring_Image/image-20230605192805294.png" alt="image-20230605192805294"></p><p><img src="../assets/image/Spring_Image/image-20230605192906187.png" alt="image-20230605192906187"></p><p>提交数据时，默认需要接收用/的时间格式，但是提交时如果用了-分离就会报错，下面写一个格式转换器来进行格式转换</p><p>先写一个用于将String转换为Date的类，实现了接口Converter</p><p><img src="../assets/image/Spring_Image/image-20230605194004702.png" alt="image-20230605194004702"></p><p>然后在spring-mvc.xml中配置</p><p>声明一个工厂用于创建自己写的格式转换器</p><p><img src="../assets/image/Spring_Image/image-20230605194052205.png" alt="image-20230605194052205"></p><p>同时也要更改MVC的注解驱动</p><p><img src="../assets/image/Spring_Image/image-20230605194156791.png" alt="image-20230605194156791"></p><h2 id="获得请求头">获得请求头</h2><p><img src="../assets/image/Spring_Image/image-20230605195538973.png" alt="image-20230605195538973"></p><p>自己写的方法</p><p><img src="../assets/image/Spring_Image/image-20230605195947915.png" alt="image-20230605195947915"></p><p>访问</p><p><img src="../assets/image/Spring_Image/image-20230605195953802.png" alt="image-20230605195953802"></p><p>然后输出的就是请求头中属性User-Agent对应的值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Mozilla</span>/<span class="number">5</span>.<span class="number">0</span> (Windows NT <span class="number">10</span>.<span class="number">0</span>; Win64; x64) AppleWebKit/<span class="number">537</span>.<span class="number">36</span> (KHTML, like Gecko) Chrome/<span class="number">114.0.0.0</span> Safari/<span class="number">537</span>.<span class="number">36</span></span><br></pre></td></tr></table></figure><p>当然还有其他属性的信息都可以获取（Cookie除外）</p><p><img src="../assets/image/Spring_Image/image-20230605200132776.png" alt="image-20230605200132776"></p><p><img src="../assets/image/Spring_Image/image-20230605200139984.png" alt="image-20230605200139984"></p><p>也可以设置为这个信息不必须提交，这样就算请求头中没有User-Agent属性，也可以继续访问</p><p><img src="../assets/image/Spring_Image/image-20230605200308335.png" alt="image-20230605200308335"></p><p>Cookie值特殊，需要用特殊的注解获取@CookieValue</p><p><img src="../assets/image/Spring_Image/image-20230605200445310.png" alt="image-20230605200445310"></p><p><img src="../assets/image/Spring_Image/image-20230605200739049.png" alt="image-20230605200739049"></p><h2 id="文件上传">文件上传</h2><h3 id="文件上传客户端三要素">文件上传客户端三要素</h3><p><img src="../assets/image/Spring_Image/image-20230606083616517.png" alt="image-20230606083616517"></p><p>文件上传原理</p><p><img src="../assets/image/Spring_Image/image-20230606084525462.png" alt="image-20230606084525462"></p><h3 id="单文件上传步骤">单文件上传步骤</h3><p><img src="../assets/image/Spring_Image/image-20230606084701980.png" alt="image-20230606084701980"></p><p>第一步</p><p><img src="../assets/image/Spring_Image/image-20230606084721236.png" alt="image-20230606084721236"></p><p>第二步</p><p><img src="../assets/image/Spring_Image/image-20230606084849265.png" alt="image-20230606084849265"></p><p>第三步</p><p><img src="../assets/image/Spring_Image/image-20230607100141415.png" alt="image-20230607100141415"></p><p>如果不指定路径，默认为</p><p><img src="../assets/image/Spring_Image/image-20230607101118195.png" alt="image-20230607101118195"></p><h1>SpringMVC拦截器</h1><h2 id="作用">作用</h2><p><img src="../assets/image/Spring_Image/image-20230607110544253.png" alt="image-20230607110544253"></p><p>主义：只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的</p><h2 id="拦截器和过滤器的区别">拦截器和过滤器的区别</h2><p><img src="../assets/image/Spring_Image/image-20230607111126956.png" alt="image-20230607111126956"></p><h2 id="自定义拦截器创建">自定义拦截器创建</h2><p><img src="../assets/image/Spring_Image/image-20230607111300321.png" alt="image-20230607111300321"></p><p>1、写拦截器的类，实现HandlerInterceptor接口</p><p>接口中有3个方法，并且都有方法体，所以实现HandlerInterceptor接口后没有必须要重写的方法，只是需要哪个就重写哪个就行了</p><p>HandlerInterceptor接口内容：</p><p><img src="../assets/image/Spring_Image/image-20230607122443128.png" alt="image-20230607122443128"></p><p>写拦截器用的类；</p><p><img src="../assets/image/Spring_Image/image-20230607122512532.png" alt="image-20230607122512532"></p><p>其中的方法：</p><p>preHandle()</p><p>​这个方法在要拦截的内容方法前执行</p><p>​其中可以做一些处理，方法返回值为true时才会调用下一个  preHandle()或者目标资源，如果返回false则不会调用。所以可以在返回false前做一些处理，例如返回一个专门显示错误信息的jsp</p><p>postHandle()</p><p>​这个方法在拦截的方法后执行，但在视图对象返回之前</p><p>afterCompletion()</p><p>​最后执行</p><p>然后在spring-mvc.xml中配置</p><p>这里配置了两个拦截器，也就形成了拦截器链</p><p><img src="../assets/image/Spring_Image/image-20230607122823858.png" alt="image-20230607122823858"></p><p>执行顺序：MyInterceptor2的preHandle()  —&gt;  MyInterceptor1的preHandle()  —&gt;  目标资源执行  —&gt;  MyInterceptor1的postHandle()  —&gt;  MyInterceptor2的postHandle()  —&gt;  视图对象返回  —&gt;  MyInterceptor1的afterCompletion()  —&gt;  MyInterceptor2的afterCompletion()</p><p><img src="../assets/image/Spring_Image/image-20230607122923203.png" alt="image-20230607122923203"></p><p>注意：执行顺序中在拦截器链前面的类的方法在目标资源执行前先执行，之后在拦截器链前面的类的方法都后执行</p><p>拦截器的方法详细说明：</p><p><img src="../assets/image/Spring_Image/image-20230607123702698.png" alt="image-20230607123702698"></p><h2 id="案例-用户登录权限控制">案例-用户登录权限控制</h2><p><img src="../assets/image/Spring_Image/image-20230607192734604.png" alt="image-20230607192734604"></p><p>拦截器也可以配置不拦截哪些资源</p><p><img src="../assets/image/Spring_Image/image-20230607193905008.png" alt="image-20230607193905008"></p><h1>SpringMVC异常处理</h1><h2 id="异常处理的思路">异常处理的思路</h2><p><img src="../assets/image/Spring_Image/image-20230607195612215.png" alt="image-20230607195612215"></p><p>配置异常处理器，在spring-mvc.xml中</p><p>配置默认错误视图和指定错误对应的视图</p><p><img src="../assets/image/Spring_Image/image-20230607202438481.png" alt="image-20230607202438481"></p><p>写一个专门抛出异常的类</p><p><img src="../assets/image/Spring_Image/image-20230607203325123.png" alt="image-20230607203325123"></p><p>在web层调用</p><p><img src="../assets/image/Spring_Image/image-20230607203359140.png" alt="image-20230607203359140"></p><h2 id="自定义异常处理">自定义异常处理</h2><p>show5()抛出的就是自定义异常</p><p>写一个自定义异常类，继承Exception</p><p><img src="../assets/image/Spring_Image/image-20230607203530172.png" alt="image-20230607203530172"></p><p>写一个自定义异常处理器类，实现HandlerExceptionResolver</p><p><img src="../assets/image/Spring_Image/image-20230607203629158.png" alt="image-20230607203629158"></p><p>在spring-mvc.xml中声明这个类</p><p><img src="../assets/image/Spring_Image/image-20230607203813066.png" alt="image-20230607203813066"></p><p>和SpringMVC自带的异常处理器不同，自己写的异常处理器在spring-mvc.xml中声明要断的多，只需要一个bean，框架就可以调用类中的resolveException()来处理异常。</p><p>如果配置了多个异常处理器，其中都有同一个异常，那框架以在上面声明的异常处理器为主</p><p><img src="../assets/image/Spring_Image/image-20230607204705168.png" alt="image-20230607204705168"></p><h2 id="总结：异常处理步骤">总结：异常处理步骤</h2><ol><li>创建异常处理器类实现HandlerExceptionResolver接口</li><li>配置异常处理器</li><li>编写异常页面</li><li>测试异常跳转</li></ol><h1>Spring+SpringMVC练习</h1><p>web层</p><p>​尽量一个方法解决问题，将传入的参数传个这个方法</p><p>service层</p><p>​尽量将大问题拆成几个小步骤，调用若干个方法进行实现</p><p>dao层</p><p>​实现若干个小方法，留个service层调用</p><h2 id="环境搭建步骤">环境搭建步骤</h2><p><img src="../assets/image/Spring_Image/image-20230608202124896.png" alt="image-20230608202124896"></p><h2 id="开始">开始</h2><h3 id="配置文件">配置文件</h3><h4 id="web-xml-2">web.xml</h4><ol><li>全局初始化参数</li><li>配置Spring监听器</li><li>SpringMVC前端控制器</li></ol><p><img src="../assets/image/Spring_Image/image-20230609112404748.png" alt="image-20230609112404748"></p><h4 id="spring-mvc-xml-2">spring-mvc.xml</h4><ol><li>MVC注解驱动</li><li>视图解析器</li><li>静态资源权限全开放</li></ol><p><img src="../assets/image/Spring_Image/image-20230609160409257.png" alt="image-20230609160409257"></p><h4 id="applicationContext-xml-2">applicationContext.xml</h4><ol><li>加载jdbc.properties配置文件</li><li>配置数据源</li><li>配置jdbc模板</li></ol><p><img src="../assets/image/Spring_Image/image-20230609112644396.png" alt="image-20230609112644396"></p><h4 id="给每个表编写一个类">给每个表编写一个类</h4><p><img src="../assets/image/Spring_Image/image-20230609163953792.png" alt="image-20230609163953792"></p><p><img src="../assets/image/Spring_Image/image-20230609164003304.png" alt="image-20230609164003304"></p><h3 id="数据库设计">数据库设计</h3><p>用户和角色之间是多对多关系</p><p>​一个用户可以有多个角色，一个角色可以被多个用户拥有，所以他们之间的关系用另一个表记录</p><p><img src="../assets/image/Spring_Image/image-20230609113549707.png" alt="image-20230609113549707"></p><p>CEO:首席执行官</p><p>COO:首席运营官</p><p>CFO:首席财务官</p><p>CTO:首席技术官</p><p>role表</p><p><img src="../assets/image/Spring_Image/image-20230609113623333.png" alt="image-20230609113623333"></p><p>user表</p><p><img src="../assets/image/Spring_Image/image-20230609113639037.png" alt="image-20230609113639037"></p><p>user_role表：</p><p><img src="../assets/image/Spring_Image/image-20230609113655789.png" alt="image-20230609113655789"></p><h3 id="角色列表展示">角色列表展示</h3><h4 id="展示效果">展示效果</h4><p><img src="../assets/image/Spring_Image/image-20230609150749690.png" alt="image-20230609150749690"></p><h4 id="步骤">步骤</h4><p><img src="../assets/image/Spring_Image/image-20230609150758116.png" alt="image-20230609150758116"></p><h5 id="打开组件扫描">打开组件扫描</h5><p>spring-mvc.xml</p><p><img src="../assets/image/Spring_Image/image-20230609163626091.png" alt="image-20230609163626091"></p><h5 id="配置web-xml">配置web.xml</h5><p><img src="../assets/image/Spring_Image/image-20230609185121145.png" alt="image-20230609185121145"></p><h5 id="配置Dao层和Service的Bean">配置Dao层和Service的Bean</h5><p>applicationCOntext.xml</p><p><img src="../assets/image/Spring_Image/image-20230609163751635.png" alt="image-20230609163751635"></p><h5 id="编写Dao层">编写Dao层</h5><p><img src="../assets/image/Spring_Image/image-20230609163815759.png" alt="image-20230609163815759"></p><h5 id="编写Service层">编写Service层</h5><p><img src="../assets/image/Spring_Image/image-20230609163832462.png" alt="image-20230609163832462"></p><h5 id="编写Controller层">编写Controller层</h5><p><img src="../assets/image/Spring_Image/image-20230609163905690.png" alt="image-20230609163905690"></p><h5 id="修改超链接">修改超链接</h5><p>在jsp中将对应的超链接改为Controller层中的对应方法</p><p><img src="../assets/image/Spring_Image/image-20230609164144033.png" alt="image-20230609164144033"></p><h3 id="角色添加">角色添加</h3><h4 id="步骤-2">步骤</h4><p><img src="../assets/image/Spring_Image/image-20230609183629603.png" alt="image-20230609183629603"></p><h5 id="编写Controller层-2">编写Controller层</h5><p>提交完后重定向到/role/list下</p><p><img src="../assets/image/Spring_Image/image-20230609185958417.png" alt="image-20230609185958417"></p><h5 id="编写Service层-2">编写Service层</h5><p><img src="../assets/image/Spring_Image/image-20230609190025182.png" alt="image-20230609190025182"></p><h5 id="编写Dao层-2">编写Dao层</h5><p><img src="../assets/image/Spring_Image/image-20230609190049284.png" alt="image-20230609190049284"></p><h5 id="修改表单提交链接">修改表单提交链接</h5><p><img src="../assets/image/Spring_Image/image-20230609190143789.png" alt="image-20230609190143789"></p><p>因为是用post方式提交，可能有乱码问题</p><h5 id="配置编码过滤器">配置编码过滤器</h5><p>web.xml中</p><p><img src="../assets/image/Spring_Image/image-20230609190308082.png" alt="image-20230609190308082"></p><h3 id="用户列表展示">用户列表展示</h3><h4 id="展示效果-2">展示效果</h4><p><img src="../assets/image/Spring_Image/image-20230609191548547.png" alt="image-20230609191548547"></p><h4 id="给User类添加属性">给User类添加属性</h4><p><img src="../assets/image/Spring_Image/image-20230609191711651.png" alt="image-20230609191711651"></p><h4 id="改页面中的超链接">改页面中的超链接</h4><p><img src="../assets/image/Spring_Image/image-20230609191917227.png" alt="image-20230609191917227"></p><h4 id="编写Controller层-3">编写Controller层</h4><p><img src="../assets/image/Spring_Image/image-20230609193514470.png" alt="image-20230609193514470"></p><h4 id="编写Service层-3">编写Service层</h4><p><img src="../assets/image/Spring_Image/image-20230609193545907.png" alt="image-20230609193545907"></p><h4 id="编写Dao层-3">编写Dao层</h4><p><img src="../assets/image/Spring_Image/image-20230609193603053.png" alt="image-20230609193603053"></p><h4 id="配置Service层、Dao层的bean">配置Service层、Dao层的bean</h4><p><img src="../assets/image/Spring_Image/image-20230609193648087.png" alt="image-20230609193648087"></p><h4 id="jsp中引入核心标签库">jsp中引入核心标签库</h4><p><img src="../assets/image/Spring_Image/image-20230609194314134.png" alt="image-20230609194314134"></p><p><img src="../assets/image/Spring_Image/image-20230609194325662.png" alt="image-20230609194325662"></p><h4 id="展示角色名称">展示角色名称</h4><p>因为User表和Role表的关系存在外表中，想查到User对应的Role就要把Class User中的private List<Role> roles;  中的属性封装好</p><h5 id="Controller层">Controller层</h5><p>不变，他只调用了Service层中的list()</p><p><img src="../assets/image/Spring_Image/image-20230610093414020.png" alt="image-20230610093414020"></p><h5 id="Service层">Service层</h5><p>应为UserServiceImpl要调用RoleDao的方法，所以在xml中注入</p><p><img src="../assets/image/Spring_Image/image-20230610094728489.png" alt="image-20230610094728489"></p><p>遍历userList，主要使用每一个其中每一个User 的Id，利用Id调用Dao层的方法查询Role</p><p>一些经常用的操作，像findRoleByUserId就交给Dao层实现</p><p><img src="../assets/image/Spring_Image/image-20230610093442919.png" alt="image-20230610093442919"></p><h5 id="Dao层">Dao层</h5><p>因为主要目的是findRole，所以这个方法放在RoleDaoImpl中</p><p><img src="../assets/image/Spring_Image/image-20230610094003364.png" alt="image-20230610094003364"></p><h4 id="user-list-jsp">user-list.jsp</h4><p>前面将User中的private List<Role> roles;属性完成了封装</p><p>在jsp文件中就可以使用了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c<span class="keyword">:forEach</span> <span class="attribute">items</span>=<span class="string">&quot;<span class="variable">$&#123;userList&#125;</span>&quot;</span> <span class="attribute">var</span>=<span class="string">&quot;user&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>意思是遍历userList中的属性，每次取出的值名为user，即user是userList中的每一个元素，然后就可以通过user.来访问这个元素的对象</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c<span class="keyword">:forEach</span> <span class="attribute">items</span>=<span class="string">&quot;<span class="variable">$&#123;user.roles&#125;</span>&quot;</span> <span class="attribute">var</span>=<span class="string">&quot;role&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>遍历user中的roles属性，就是List<Role> roles，使用其中元素（Role实例）的roleName属性</p><p><img src="../assets/image/Spring_Image/image-20230610094123889.png" alt="image-20230610094123889"></p><h3 id="用户添加">用户添加</h3><h4 id="Controller层-2">Controller层</h4><p>因为在新建页面中，用户角色是要选择的，所以在从user-list.jsp跳到user-add.jsp的新建按钮上要将链接连接到方法上</p><p><img src="../assets/image/Spring_Image/image-20230610113940607.png" alt="image-20230610113940607"></p><p>在web层尽量使用service层的方法，而不是直接使用dao层的，所以这里注入新的属性，private RoleService roleService;使用其中的方法，查询数据库中存在的所有role的rolename,添加到ModelAndView的Model中</p><p><img src="../assets/image/Spring_Image/image-20230610113951453.png" alt="image-20230610113951453"></p><h4 id="user-add-jsp">user-add.jsp</h4><p>中就可以使用放在ModelAndView中查询出来的roleList了</p><p><img src="../assets/image/Spring_Image/image-20230610114301033.png" alt="image-20230610114301033"></p><p>这样在每次打开新建用户界面时，用户角色的选项条就是从数据库中查出的最新的</p><h4 id="Service层-2">Service层</h4><p><img src="../assets/image/Spring_Image/image-20230610135331934.png" alt="image-20230610135331934"></p><h4 id="Dao层-2">Dao层</h4><p>使用save(User user)保存User实例，并将保存在数据库后生成的ID返回</p><p><img src="../assets/image/Spring_Image/image-20230610135353401.png" alt="image-20230610135353401"></p><p>jdbcTemplate.update()的不同使用方法</p><p>常见的使用方式：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(&quot;<span class="keyword">insert</span> <span class="keyword">into</span> sys_user_role <span class="keyword">values</span>(?,?)<span class="string">&quot;,userId,roleId);</span></span><br></pre></td></tr></table></figure><p>但是这里要求嗲用方法后还要返回ID，所以这么写</p><p>创建PreparedStatementCreator对象，将要执行的语句的格式和数据都封装在对象里。</p><p>创建GeneratedKeyHolder对象，在执行jdbcTemplate.update()时，会保存PreparedStatementCreator实例生成的ID</p><p>GeneratedKeyHolder的作用就是将还没传过去的主键保存下来</p><p><img src="../assets/image/Spring_Image/image-20230610135648256.png" alt="image-20230610135648256"></p><h3 id="用户删除">用户删除</h3><p>删除和之前的不一样，需要从网页获取ID后返回后台</p><p>点击删除后调用delUser()</p><p>使用confirm()函数来在网页中跳出弹窗询问用户是否确认删除</p><p><img src="../assets/image/Spring_Image/image-20230610141223329.png" alt="image-20230610141223329"></p><p>delUser()负责提醒用户是否继续，如果是，就将userId返给后台</p><p><img src="../assets/image/Spring_Image/image-20230610141249752.png" alt="image-20230610141249752"></p><h4 id="Web层中">Web层中</h4><p>使用网址来接受userId，使用注解@PathVariable(“userId”)将网址中的userId装递给参数</p><p><img src="../assets/image/Spring_Image/image-20230610142229279.png" alt="image-20230610142229279"></p><h4 id="Service层-3">Service层</h4><p>这里没有级联删除，所以要先删除关系表中的数据</p><p><img src="../assets/image/Spring_Image/image-20230610142316603.png" alt="image-20230610142316603"></p><h4 id="Dao层-3">Dao层</h4><p><img src="../assets/image/Spring_Image/image-20230610142352244.png" alt="image-20230610142352244"></p>]]></content>
    
    
    <summary type="html">🍔本文汇总Spring和SpringMVC的开发步骤</summary>
    
    
    
    <category term="框架" scheme="https://momoao.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://momoao.github.io/tags/Spring/"/>
    
    <category term="SpringMVC" scheme="https://momoao.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://momoao.github.io/posts/202308281527.html"/>
    <id>https://momoao.github.io/posts/202308281527.html</id>
    <published>2023-08-28T07:27:00.000Z</published>
    <updated>2023-08-28T07:29:07.081Z</updated>
    
    <content type="html"><![CDATA[<h1>Mybatis</h1><h1>简介</h1><h2 id="回顾原始jdbc操作">回顾原始jdbc操作</h2><p>查询</p><p><img src="../assets/image/Mybatis_Image/image-20230610142612838.png" alt="image-20230610142612838"></p><p>插入</p><p><img src="../assets/image/Mybatis_Image/image-20230610142816805.png" alt="image-20230610142816805"></p><p>原始jdbc存在的问题和解决方案</p><p><img src="../assets/image/Mybatis_Image/image-20230610143103345.png" alt="image-20230610143103345"></p><h2 id="什么是Mybatis">什么是Mybatis</h2><p><img src="../assets/image/Mybatis_Image/image-20230610143700208.png" alt="image-20230610143700208"></p><h1>开发步骤</h1><p><img src="../assets/image/Mybatis_Image/image-20230611081715389.png" alt="image-20230611081715389"></p><h2 id="快速入门">快速入门</h2><h3 id="文件结构">文件结构</h3><p><img src="../assets/image/Mybatis_Image/image-20230611085537432.png" alt="image-20230611085537432"></p><h3 id="核心配置文件">核心配置文件</h3><p>sqlMapConfig.xml</p><p><img src="../assets/image/Mybatis_Image/image-20230611085605028.png" alt="image-20230611085605028"></p><h3 id="sql语句文件">sql语句文件</h3><p>UserMapper.xml</p><p><img src="../assets/image/Mybatis_Image/image-20230611085613972.png" alt="image-20230611085613972"></p><h3 id="测试文件">测试文件</h3><p><img src="../assets/image/Mybatis_Image/image-20230611085648930.png" alt="image-20230611085648930"></p><h3 id="必须要添加的坐标">必须要添加的坐标</h3><p><img src="../assets/image/Mybatis_Image/image-20230611085757976.png" alt="image-20230611085757976"></p><h2 id="映射文件概述">映射文件概述</h2><p><img src="../assets/image/Mybatis_Image/image-20230611090222574.png" alt="image-20230611090222574"></p><h1>增删改查操作</h1><h2 id="增">增</h2><p>UserMapper.xml</p><p><img src="../assets/image/Mybatis_Image/image-20230611093202381.png" alt="image-20230611093202381"></p><p>测试代码</p><p>执行结果返回还是1，但是数据库并没有收影响</p><p><img src="../assets/image/Mybatis_Image/image-20230611093244040.png" alt="image-20230611093244040"></p><p>mybatis的事务默认是不提交的，原始的jdbc默认是提交的，所以要提交后数据才会进到数据库</p><p><img src="../assets/image/Mybatis_Image/image-20230611095203056.png" alt="image-20230611095203056"></p><p>提交后发现id是3而不是1，因为sql已经到了数据库，但是业务没提交，只有id自增了，但是表内的数据没变</p><p><img src="../assets/image/Mybatis_Image/image-20230611095217220.png" alt="image-20230611095217220"></p><p>注意事项</p><p><img src="../assets/image/Mybatis_Image/image-20230611101214983.png" alt="image-20230611101214983"></p><h2 id="改">改</h2><p><img src="../assets/image/Mybatis_Image/image-20230611102918409.png" alt="image-20230611102918409"></p><p><img src="../assets/image/Mybatis_Image/image-20230611102928968.png" alt="image-20230611102928968"></p><p>注意事项</p><p><img src="../assets/image/Mybatis_Image/image-20230611103409878.png" alt="image-20230611103409878"></p><h2 id="删">删</h2><p>因为这里只有一个参数java.lang.Integer，所以#{}中写什么名字都行，写id是为了提高可读性</p><p><img src="../assets/image/Mybatis_Image/image-20230611103216866.png" alt="image-20230611103216866"></p><p><img src="../assets/image/Mybatis_Image/image-20230611103321664.png" alt="image-20230611103321664"></p><p>注意事项</p><p><img src="../assets/image/Mybatis_Image/image-20230611103421397.png" alt="image-20230611103421397"></p><h2 id="知识小结">知识小结</h2><p><img src="../assets/image/Mybatis_Image/image-20230611105031427.png" alt="image-20230611105031427"></p><h1>核心配置文件概述</h1><h2 id="层级关系">层级关系</h2><p><img src="../assets/image/Mybatis_Image/image-20230611154600251.png" alt="image-20230611154600251"></p><h2 id="environments标签">environments标签</h2><p><img src="../assets/image/Mybatis_Image/image-20230611155133546.png" alt="image-20230611155133546"></p><p><img src="../assets/image/Mybatis_Image/image-20230611155345158.png" alt="image-20230611155345158"></p><h2 id="mappers标签">mappers标签</h2><p><img src="../assets/image/Mybatis_Image/image-20230611160012398.png" alt="image-20230611160012398"></p><p><img src="../assets/image/Mybatis_Image/image-20230611160046561.png" alt="image-20230611160046561"></p><h2 id="Properties标签">Properties标签</h2><p>在文件中引入配置文件</p><p><img src="../assets/image/Mybatis_Image/image-20230611160827286.png" alt="image-20230611160827286"></p><p><img src="../assets/image/Mybatis_Image/image-20230611160835561.png" alt="image-20230611160835561"></p><h2 id="typeAliases标签">typeAliases标签</h2><p>作用是声明全局别名，例如将com.itheima.domain.User声明为user</p><p>在以后使用的时候就可以直接使用user了</p><p><img src="../assets/image/Mybatis_Image/image-20230611161044825.png" alt="image-20230611161044825"></p><p><img src="../assets/image/Mybatis_Image/image-20230611161202020.png" alt="image-20230611161202020"></p>]]></content>
    
    
    <summary type="html">🍔本文汇总使用Mybatis开发的基本步骤，简易提交看Spring的相关笔记</summary>
    
    
    
    <category term="框架" scheme="https://momoao.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
    <category term="Mybatis" scheme="https://momoao.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>VSCode中C++环境配置</title>
    <link href="https://momoao.github.io/posts/202308241554.html"/>
    <id>https://momoao.github.io/posts/202308241554.html</id>
    <published>2023-08-09T10:19:03.000Z</published>
    <updated>2023-08-25T12:44:14.007Z</updated>
    
    <content type="html"><![CDATA[<h1>VSCode配置</h1><h1>c++环境配置</h1><ul><li><p>下载这个拓展，1.8.4版本<img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714165903555.png" alt="image-20230714165903555"></p></li><li><p>选择编译器第一个</p><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714170141470.png" alt="image-20230714170141470"></p></li><li><p>还是第一个</p><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714170213229.png" alt="image-20230714170213229"></p></li><li><p>运行后自动生成配置文件配置文件</p><ul><li><p>launch.json</p><ul><li>设置program指定exe文件生成路径</li><li>设置externalConsole指定是否在控制台中输出<ul><li>一般使用true（默认false），不然会有乱码问题</li></ul></li><li><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714170851815.png" alt="image-20230714170851815"></li></ul></li><li><p>task.json</p><ul><li>这里也指定exe文件的路径，需要与上面的一样</li><li><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714171026376.png" alt="image-20230714171026376"></li></ul></li></ul></li></ul><h1>自定义代码段配置</h1><ul><li></li><li><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714171247386.png" alt="image-20230714171247386"></li></ul><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjI2NTE2Mi0yNzRiZTI5ZWQxNGY3NWU4LnBuZw.png" alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjI2NTE2Mi0yNzRiZTI5ZWQxNGY3NWU4LnBuZw"></p><ul><li><p>文件中的配置</p></li><li><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714172404490.png" alt="image-20230714172404490"></p></li><li><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714172345791.png" alt="image-20230714172345791"></p></li><li><p>配置书写规范</p></li><li><p><img src="../assets/image/VSCode%E9%85%8D%E7%BD%AE_Image/image-20230714172431725.png" alt="image-20230714172431725"></p></li></ul>]]></content>
    
    
    <summary type="html">🥧本文汇总VSCode中C++环境的配置和使用</summary>
    
    
    
    <category term="工具" scheme="https://momoao.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="VSCode" scheme="https://momoao.github.io/tags/VSCode/"/>
    
    <category term="软件配置" scheme="https://momoao.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>C++QT</title>
    <link href="https://momoao.github.io/posts/202308241636.html"/>
    <id>https://momoao.github.io/posts/202308241636.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-27T07:39:45.715Z</updated>
    
    <content type="html"><![CDATA[<h1>C++QT</h1><h1>概述</h1><h2 id="QT">QT</h2><p>QT（Qt）是一个跨平台的应用程序开发框架，用于开发图形界面应用程序和嵌入式系统。它由Qt Company（前身为Nokia）开发并维护，采用C++编写，并提供了丰富的库和工具，以简化软件开发过程。</p><p>Qt提供了一套完整的工具和组件，使开发人员能够构建高性能、可扩展和易于维护的应用程序。它支持多种操作系统，包括Windows、macOS、Linux、Android和iOS等。使用Qt，开发人员可以编写一次代码，然后将其移植到不同平台上运行，从而实现跨平台开发。</p><p>Qt框架的主要特点包括：</p><ol><li><p>跨平台：Qt允许开发人员在不同的操作系统上进行开发，并提供了一致的API和工具。</p></li><li><p>可视化设计：Qt提供了一套可视化设计工具，如Qt Designer，可帮助开发人员轻松设计和布局图形界面。</p></li><li><p>丰富的库：Qt提供了许多功能强大的库，涵盖了各种领域，包括图形渲染、网络通信、数据库访问、多媒体处理等。</p></li><li><p>信号与槽机制：Qt引入了信号与槽机制，用于实现对象之间的通信和事件处理，使得应用程序的逻辑更加灵活和易于组织。</p></li><li><p>多线程支持：Qt提供了多线程编程的支持，使开发人员能够轻松地编写并发和并行的应用程序。</p></li></ol><p>Qt广泛用于开发各种类型的应用程序，包括桌面应用程序、移动应用程序、嵌入式系统和图形化工具等。它被广泛应用于行业领域，如自动化、医疗、游戏开发、航空航天等。</p><p>总而言之，Qt是一个跨平台的应用程序开发框架，用于开发图形界面应用程序和嵌入式系统。它提供了丰富的库和工具，使开发人员能够轻松构建跨平台、高性能和可扩展的应用程序。</p><h2 id="QML">QML</h2><p>QML（Qt Meta-Object Language）是一种用于构建用户界面的声明性语言，由Qt框架提供支持。它被广泛用于开发跨平台的桌面、移动和嵌入式应用程序。QML的设计理念是将界面的结构、外观和交互逻辑分离，使开发人员能够以一种直观和灵活的方式创建富有吸引力的用户界面。</p><p>以下是QML的一些重要特点和概念：</p><ol><li><p><strong>声明性语言</strong>：QML是一种声明性语言，它通过描述界面元素之间的关系和属性来定义用户界面。开发人员可以使用简洁的语法来声明界面的结构、样式和行为，而无需编写大量的代码。</p></li><li><p><strong>对象模型</strong>：QML基于对象模型，其中界面元素被表示为可重用的对象。这些对象可以具有属性、信号和方法，可以嵌套和组合形成层次结构。这种对象模型使得构建复杂的界面变得容易，并支持代码的模块化和重用。</p></li><li><p><strong>视觉元素</strong>：QML提供了丰富的视觉元素来构建用户界面，包括矩形、圆角矩形、文本、图像、按钮、列表视图等。这些元素可以通过设置属性来定制外观和行为，并可以使用动画和过渡效果来增强用户体验。</p></li><li><p><strong>布局和位置</strong>：QML提供了灵活的布局和位置管理器，使开发人员能够定义界面元素的位置和大小。可以使用垂直布局、水平布局、栅格布局等来自动排列元素，并支持锚点、填充、对齐等属性来控制元素的位置。</p></li><li><p><strong>信号和槽机制</strong>：QML支持信号和槽机制，用于处理用户输入和界面元素之间的通信。可以定义信号并将其连接到特定的槽函数，以响应事件或数据的变化。这种机制使得实现交互逻辑和处理用户操作变得简单和直观。</p></li><li><p><strong>动画和过渡效果</strong>：QML具有内置的动画和过渡效果系统，使开发人员能够创建平滑的界面动画。可以在属性之间定义动画，例如淡入淡出、平移、旋转等，以及在不同界面状态之间定义过渡效果，例如页面切换效果。</p></li><li><p><strong>与C++的交互</strong>：QML可以与C++代码进行无缝集成，通过Qt的元对象系统实现跨语言交互。可以将QML界面与后端的C++逻辑相结合，使开</p></li></ol><p>发人员能够充分利用Qt框架提供的强大功能和库。</p><p>总而言之，QML是一种强大的用户界面开发语言，它以声明性的方式描述界面元素，具有灵活的布局和位置管理，支持动画和过渡效果，并能与C++代码进行交互。通过使用QML，开发人员可以更快速、更高效地构建出色的跨平台应用程序。</p><h2 id="信号和槽机制">信号和槽机制</h2><p>在Qt中，信号（Signals）和槽（Slots）机制是一种用于实现对象间通信的重要机制。它是Qt框架中的核心特性之一，用于解耦和连接不同的对象。</p><p>信号（Signals）是Qt对象在特定事件发生时发出的消息。一个信号可以被视为一个特定事件的发出者。例如，当按钮被点击时，QPushButton类可以发出一个clicked（点击）信号。</p><p>槽（Slots）是Qt对象中的成员函数，用于响应信号的发出。槽可以被视为信号的接收者，它定义了当特定信号发生时应该执行的操作。例如，你可以创建一个槽函数来处理按钮点击事件，并执行相应的操作。</p><p>信号和槽机制的连接是通过使用QObject类的connect()函数来实现的。这个函数接受一个发出信号的对象、一个信号的名称、一个接收信号的对象和一个槽函数的名称作为参数。当信号被发出时，与之连接的槽函数会被自动调用。</p><p>以下是一个简单的示例，演示了信号和槽的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(QObject *parent = <span class="literal">nullptr</span>) : <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">        QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click me&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">connect</span>(button, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleButtonClick</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Button clicked!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyClass myObject;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，MyClass是一个自定义的QObject子类，它包含一个按钮（QPushButton）。当按钮被点击时，clicked()信号会被发出。这个信号与MyClass类中的handleButtonClick()槽函数连接起来。当点击按钮时，handleButtonClick()函数会被调用，并输出&quot;Button clicked!&quot;。</p><p>需要注意的是，为了使用信号和槽机制，必须将QObject子类的头文件包含进来，并在类的定义中使用Q_OBJECT宏。这个宏会为类添加必要的元对象（Meta-Object）信息，以支持信号和槽的连接。</p><p>总结一下，信号和槽机制是Qt中一种强大的对象间通信方式，它允许对象之间的解耦和灵活连接。通过使用信号和槽，你可以实现事件的响应和数据的传递，使得Qt程序更加灵活和可扩展。</p><h1>界面解读</h1><h2 id="设计界面">设计界面</h2><p><img src="../assets/image/C++QT_Image/image-20230622134750896.png" alt="image-20230622134750896"></p><h3 id="Layouts-布局">Layouts-布局</h3><p><img src="../assets/image/C++QT_Image/image-20230622135030754.png" alt="image-20230622135030754"></p><p>水平布局</p><p>垂直布局</p><p>网格布局（计算器）</p><p>表单布局</p><h3 id="Spacers-弹簧">Spacers-弹簧</h3><p><img src="../assets/image/C++QT_Image/image-20230622135023591.png" alt="image-20230622135023591"></p><p>水平弹簧</p><p>竖直弹簧</p><p><img src="../assets/image/C++QT_Image/image-20230622135014724.png" alt="image-20230622135014724"></p><p>例如：确定的左边就空了好多地方，就是因为有一个水平的弹簧</p><h3 id="Buttons-按钮">Buttons-按钮</h3><p><img src="../assets/image/C++QT_Image/image-20230622135116717.png" alt="image-20230622135116717"></p><p>普通按钮</p><p>工具按钮</p><p>单选按钮</p><p>复选按钮</p><p>命令链接按钮</p><p>对话框按钮盒</p><h3 id="Item-Views-Model-Based-单元视图">Item Views(Model-Based)-单元视图</h3><p><img src="../assets/image/C++QT_Image/image-20230622152529030.png" alt="image-20230622152529030"></p><p>列表视图</p><p>树形视图</p><p>表格视图</p><h2 id="界面元素">界面元素</h2><p>从上到下表明了继承关系</p><p><img src="../assets/image/C++QT_Image/image-20230622154010513.png" alt="image-20230622154010513"></p><h1>按钮操作</h1><h2 id="第一种写法">第一种写法</h2><p>右键按钮选择转到槽</p><p><img src="../assets/image/C++QT_Image/image-20230622162057438.png" alt="image-20230622162057438"></p><p>之后选择一种信号类型</p><p><img src="../assets/image/C++QT_Image/image-20230622162121883.png" alt="image-20230622162121883"></p><p>在widget.h文件中就会自动生成</p><p><img src="../assets/image/C++QT_Image/image-20230622162157178.png" alt="image-20230622162157178"></p><p>在widget.cpp文件中就会自动生成</p><p><img src="../assets/image/C++QT_Image/image-20230622162213901.png" alt="image-20230622162213901"></p><p>之后在方法体里写点击按钮后执行的操作</p><p>获取对象文本，执行这个进程</p><p>例如：输入notepad后就会打开记事本</p><p><img src="../assets/image/C++QT_Image/image-20230622162236358.png" alt="image-20230622162236358"></p><h2 id="第二种方法">第二种方法</h2><p>在构造方法中使用connect函数</p><p><img src="../assets/image/C++QT_Image/image-20230622162400415.png" alt="image-20230622162400415"></p><h1>connect()使用</h1><p>在Qt中，<code>connect()</code>函数是用于建立信号与槽（Signal-Slot）之间的连接，实现对象之间的通信。以下是<code>connect()</code>函数的基本语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(signal), receiver, <span class="built_in">SLOT</span>(slot));</span><br></pre></td></tr></table></figure><p>例如：</p><p><img src="../assets/image/C++QT_Image/image-20230623123021722.png" alt="image-20230623123021722"></p><p>其中，<code>sender</code>是发送信号的对象，<code>signal</code>是信号的名称，<code>receiver</code>是接收信号的对象，<code>slot</code>是槽的名称。</p><p>下面是一个使用<code>connect()</code>函数的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sender</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSignal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">mySignal</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">(<span class="type">const</span> QString&amp; message)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receiveSlot</span><span class="params">(<span class="type">const</span> QString&amp; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(<span class="literal">nullptr</span>, <span class="string">&quot;Message&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    Sender sender;</span><br><span class="line">    Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接信号和槽</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;sender, <span class="built_in">SIGNAL</span>(<span class="built_in">mySignal</span>(<span class="type">const</span> QString&amp;)), &amp;receiver, <span class="built_in">SLOT</span>(<span class="built_in">receiveSlot</span>(<span class="type">const</span> QString&amp;)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    sender.<span class="built_in">sendSignal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，定义了两个类：<code>Sender</code>和<code>Receiver</code>。<code>Sender</code>类有一个<code>sendSignal()</code>函数，它通过<code>emit</code>关键字发出一个带有字符串参数的自定义信号<code>mySignal</code>。<code>Receiver</code>类有一个<code>receiveSlot()</code>槽函数，它接收一个字符串参数，并使用<code>QMessageBox::information()</code>显示消息框。</p><p>在<code>main()</code>函数中，创建了<code>Sender</code>和<code>Receiver</code>的实例。然后，使用<code>connect()</code>函数将<code>Sender</code>对象的<code>mySignal</code>信号与<code>Receiver</code>对象的<code>receiveSlot</code>槽函数进行连接。</p><p>最后，调用<code>sender.sendSignal()</code>发送信号，当信号发出时，会自动触发槽函数<code>receiver.receiveSlot()</code>，并在消息框中显示收到的消息。</p><p>需要注意的是，为了正确使用信号和槽机制，需要在相应的类声明中添加<code>Q_OBJECT</code>宏，并使用<code>SIGNAL()</code>和<code>SLOT()</code>宏来指定信号和槽的名称。此外，还需要使用Qt的元对象系统（Meta-Object System）来支持信号和槽的连接，因此需要在代码中包含<code>&lt;QObject&gt;</code>头文件，并在构建配置文件中添加相应的Qt模块依赖。</p><p>这只是一个简单的<code>connect()</code>函数使用示例，实际中可以根据具体的需求和场景来连接不同的信号和槽。在Qt的官方文档中可以找到更详细的<code>connect()</code>函数用法和示例。</p><h2 id="QT自带信号">QT自带信号</h2><p>Qt框架自带了许多常用的信号，可以在各种Qt类中使用。以下是一些常见的Qt自带信号的示例：</p><ol><li><p>QPushButton类的信号：</p><ul><li>clicked()：按钮被点击时发出的信号。</li><li>pressed()：按钮被按下时发出的信号。</li><li>released()：按钮被释放时发出的信号。</li></ul></li><li><p>QCheckBox类的信号：</p><ul><li>clicked()：复选框被点击时发出的信号。</li><li>stateChanged(int)：复选框状态改变时发出的信号，参数是新的状态值。</li></ul></li><li><p>QLineEdit类的信号：</p><ul><li>textChanged(const QString&amp;)：文本框内容改变时发出的信号，参数是新的文本内容。</li><li>editingFinished()：编辑完成时发出的信号。</li></ul></li><li><p>QComboBox类的信号：</p><ul><li>currentIndexChanged(int)：下拉框当前选项改变时发出的信号，参数是新选中的选项索引。</li></ul></li><li><p>QSlider类的信号：</p><ul><li>valueChanged(int)：滑动条值改变时发出的信号，参数是新的值。</li></ul></li><li><p>QListWidget类的信号：</p><ul><li>itemClicked(QListWidgetItem*)：列表项被点击时发出的信号，参数是被点击的列表项对象。</li></ul></li><li><p>QTimer类的信号：</p><ul><li>timeout()：定时器超时时发出的信号。</li></ul></li></ol><p>以上只是一些常见的Qt类的信号示例，实际上Qt框架中还有很多其他类的信号可供使用。你可以通过查阅Qt的官方文档来获取完整的信号列表和使用说明，以便在编程中选择适合的信号来实现所需的功能。</p><p>附加：</p><p><code>returnPressed()</code>是Qt中某些组件（如QLineEdit）的一个信号。当用户在该组件上按下回车键时，就会发出<code>returnPressed()</code>信号。</p><h1>组件中值的获取</h1><p>在Qt的UI中，可以使用各种组件（例如QLineEdit、QComboBox、QSlider等）来接收用户的输入或选择。要获取这些组件中的值，可以使用相应的方法或属性。下面是一些常见组件值获取的示例：</p><ol><li><p>QLineEdit（文本框）：</p><ul><li>使用<code>text()</code>方法获取文本框中的文本值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLineEdit* lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">QString text = lineEdit-&gt;<span class="built_in">text</span>();</span><br></pre></td></tr></table></figure></li><li><p>QComboBox（下拉框）：</p><ul><li>使用<code>currentText()</code>方法获取当前选中项的文本值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QComboBox* comboBox = <span class="keyword">new</span> <span class="built_in">QComboBox</span>(<span class="keyword">this</span>);</span><br><span class="line">QString selectedText = comboBox-&gt;<span class="built_in">currentText</span>();</span><br></pre></td></tr></table></figure></li><li><p>QSlider（滑动条）：</p><ul><li>使用<code>value()</code>方法获取滑动条的当前值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSlider* slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="type">int</span> value = slider-&gt;<span class="built_in">value</span>();</span><br></pre></td></tr></table></figure></li><li><p>QCheckBox（复选框）：</p><ul><li>使用<code>isChecked()</code>方法获取复选框的选中状态。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox* checkBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="type">bool</span> checked = checkBox-&gt;<span class="built_in">isChecked</span>();</span><br></pre></td></tr></table></figure></li><li><p>QRadioButton（单选按钮）：</p><ul><li>使用<code>isChecked()</code>方法获取单选按钮的选中状态。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton* radioButton = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="type">bool</span> checked = radioButton-&gt;<span class="built_in">isChecked</span>();</span><br></pre></td></tr></table></figure></li></ol><p>这些是一些常见组件值获取的示例，每个组件都有适用于获取值的方法。可以根据具体的组件类型和需求，查阅Qt的官方文档以获取更多关于组件的属性和方法的详细信息。</p><p>另外，还可以使用信号和槽机制来捕获组件值的变化。例如，可以连接文本框的<code>textChanged()</code>信号或滑动条的<code>valueChanged()</code>信号，当值发生变化时触发相应的槽函数，在槽函数中获取最新的值并进行处理。</p><h1>添加图片资源</h1><p>右键项目添加新文件</p><p><img src="../assets/image/C++QT_Image/image-20230623131551654.png" alt="image-20230623131551654"></p><p>将图片文件放在一个res文件夹内，并放在项目下</p><p><img src="../assets/image/C++QT_Image/image-20230623131634103.png" alt="image-20230623131634103"></p><p>将rcc.exe添加到环境变量中</p><p>D:\QT5.9\5.9\mingw53_32\bin</p><p>在cmd中使用rcc指令将qrc中包含的图片文件变为二进制文件plane.rcc</p><p><strong>rcc -binary res.qrc -o plane.rcc</strong></p><p><img src="../assets/image/C++QT_Image/image-20230623131736291.png" alt="image-20230623131736291"></p><p>使用这个二进制文件时，需要包含头文件</p><p>#include <QResource></p><p>注册二进制文件信息</p><p>之后就可以通过QResource::registerResource(GAME_RES_PATH);来指明引入了什么资源，可以删除qrc文件，但是res文件夹要留着</p><p>注意：这里的路径是项目的所在目录，而不是项目目录下</p><p>#define GAME_RES_PATH “PlaneWar/plane.rcc”</p><p><img src="../assets/image/C++QT_Image/image-20230623132226055.png" alt="image-20230623132226055"></p><p>在初始化方法中设置图标即可在窗口左上角加载</p><p>需要#include <QIcon></p><p><img src="../assets/image/C++QT_Image/image-20230623132645766.png" alt="image-20230623132645766"></p><h1>程序开发</h1><h2 id="地图滚动">地图滚动</h2><h3 id="map-h">map.h</h3><p>负责定义地图的坐标计算方法</p><p><img src="../assets/image/C++QT_Image/image-20230623162142354.png" alt="image-20230623162142354"></p><h3 id="map-cpp">map.cpp</h3><p>在构造方法里加载地图图片，初始化这两个图片Y坐标，设置滚动速度</p><p>地图的坐标改变计算</p><p><img src="../assets/image/C++QT_Image/image-20230623163427376.png" alt="image-20230623163427376"></p><h3 id="mainscene-h">mainscene.h</h3><p><img src="../assets/image/C++QT_Image/image-20230624082153740.png" alt="image-20230624082153740"></p><h3 id="mainscene-cpp">mainscene.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainscene.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QIcon&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">MainScene::<span class="built_in">MainScene</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化场景</span></span><br><span class="line">    <span class="built_in">initScene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动游戏</span></span><br><span class="line">    <span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainScene::~<span class="built_in">MainScene</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::initScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置窗口固定尺寸</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(GAME_WIDTH,GAME_HEIGHT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(GAME_TITLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载图标</span></span><br><span class="line">    <span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(GAME_ICON));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器初始化</span></span><br><span class="line">    m_Timer.<span class="built_in">setInterval</span>(GAME_RATE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    m_Timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听监听器发送的信号</span></span><br><span class="line">    <span class="comment">//（哪个监听器，时间到了发送什么信号，用方法处理）</span></span><br><span class="line">    <span class="built_in">connect</span>(&amp;m_Timer,&amp;QTimer::timeout,[=]()&#123;</span><br><span class="line">        <span class="comment">//更新游戏中所有元素的坐标</span></span><br><span class="line">        <span class="built_in">updatePosition</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制到屏幕上</span></span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制地图</span></span><br><span class="line">    <span class="comment">//(x坐标，y坐标，QPixmap对象)</span></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,m_map.m_map1_posY,m_map.m_map1);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,m_map.m_map2_posY,m_map.m_map2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::updatePosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_map.<span class="built_in">mapPosition</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Clion QT开发</h1><h2 id="基础操作">基础操作</h2><p>新建项目</p><p><img src="../assets/image/C++QT_Image/image-20230622185007059.png" alt="image-20230622185007059"></p><p>创建目录方便管理</p><p>右键项目目录新建qtui文件</p><p>将.ui文件放在Forms中</p><p>将.h文件放在Headers中</p><p>将.cpp文件放在Sources中</p><p><img src="../assets/image/C++QT_Image/image-20230622185031539.png" alt="image-20230622185031539"></p><p>在CMakeLists.txt中添加</p><p>该命令用于告诉 CMake 编译器在编译过程中要搜索头文件的路径</p><p><img src="../assets/image/C++QT_Image/image-20230622185231986.png" alt="image-20230622185231986"></p><p>改mainwindow.cpp文件包含的头文件地址</p><p>将#include &quot;ui_MainWindow.h&quot;改为</p><p>​#include “Forms/ui_MainWindow.h”</p><p><img src="../assets/image/C++QT_Image/image-20230622185351011.png" alt="image-20230622185351011"></p><p>改main.cpp文件中的内容</p><p><img src="../assets/image/C++QT_Image/image-20230622185430456.png" alt="image-20230622185430456"></p><p>在设置中找到外部工具</p><p><img src="../assets/image/C++QT_Image/image-20230622185459076.png" alt="image-20230622185459076"></p><p>添加用于编写UI的designer.exe</p><p><img src="../assets/image/C++QT_Image/image-20230622185532722.png" alt="image-20230622185532722"></p><p>之后就可以在clion的右键菜单中直接使用</p><p><img src="../assets/image/C++QT_Image/image-20230622185602055.png" alt="image-20230622185602055"></p><h2 id="添加额外头文件">添加额外头文件</h2><p>例如要添加Network相关的库</p><p>在CMakeLists.txt文件中</p><p>这两个地方添加Network的描述</p><p>然后在Clion中使用#include <QNetworkAccessManager>时不会报错并且有代码提示，但是运行还是会闪退</p><p><img src="../assets/image/C++QT_Image/image-20230622190238095.png" alt="image-20230622190238095"></p><p><img src="../assets/image/C++QT_Image/image-20230622190246224.png" alt="image-20230622190246224"></p><p>还需要将下面路径中的文件复制到cmake-build-debug文件夹下</p><p>D:\QT\6.2.4\mingw_64\bin\Qt6Network.dll</p><p><img src="../assets/image/C++QT_Image/image-20230622190424926.png" alt="image-20230622190424926"></p><h2 id="添加信号和槽">添加信号和槽</h2><p>在mainwindow.h文件中</p><p>在类MainWindow中</p><p>添加以下代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_commitButton_clicked</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_cancelButton_clicked</span>()</span>;</span><br></pre></td></tr></table></figure><p>表示给commitButton组件添加clicked信号</p><p>表示给cancelButton组件添加clicked信号</p><p><img src="../assets/image/C++QT_Image/image-20230622191908562.png" alt="image-20230622191908562"></p><p>在文件mainwindow.cpp文件中进行实现</p><p><img src="../assets/image/C++QT_Image/image-20230622192226007.png" alt="image-20230622192226007"></p>]]></content>
    
    
    <summary type="html">🍔本文汇总QT编程的基础内容，和QTCreator的基本使用</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://momoao.github.io/tags/C/"/>
    
    <category term="QT" scheme="https://momoao.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://momoao.github.io/posts/202308241930.html"/>
    <id>https://momoao.github.io/posts/202308241930.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-25T12:42:33.829Z</updated>
    
    <content type="html"><![CDATA[<h1>C++基础</h1><h1>零碎问题</h1><h2 id="指针和引用的区别">指针和引用的区别</h2><p>在C++中，指针（Pointers）和引用（References）都是用于处理内存和变量的重要概念，但它们有一些重要的区别。让我来解释一下它们的区别：</p><ol><li><p>内存地址：</p><ul><li>指针：指针是一个变量，存储的是一个内存地址，指向某个变量或对象在内存中的位置。</li><li>引用：引用是某个变量或对象的别名，没有自己的内存地址。它与被引用的变量共享相同的内存地址。</li></ul></li><li><p>初始化：</p><ul><li>指针：指针在定义时需要显式地初始化为一个有效的内存地址，可以是nullptr（空指针）或者指向某个对象。</li><li>引用：引用在定义时必须初始化为一个已存在的变量或对象，且不能被重新赋值为引用其他变量。</li></ul></li><li><p>空值（null）：</p><ul><li>指针：指针可以是空指针（nullptr），即不指向任何有效的内存地址。</li><li>引用：引用必须始终引用某个已存在的变量或对象，不存在空引用的概念。</li></ul></li><li><p>重定向：</p><ul><li>指针：指针可以在运行时重新指向不同的变量或对象。</li><li>引用：一旦引用被初始化，它将一直引用同一个变量或对象，无法改变引用的目标。</li></ul></li><li><p>空间占用：</p><ul><li>指针：指针本身占据内存空间（通常是4个字节或8个字节，取决于系统）。</li><li>引用：引用在内存中不占据额外的空间，它只是被引用变量的别名。</li></ul></li><li><p>空间符号：</p><ul><li>指针：使用<code>*</code>来声明指针变量，并使用<code>*</code>来访问指针指向的对象（解引用）。</li><li>引用：使用<code>&amp;</code>来声明引用，但在使用时不需要加<code>&amp;</code>符号，直接使用引用即可。</li></ul></li></ol><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x; <span class="comment">// 指针ptr指向变量x</span></span><br><span class="line"><span class="type">int</span>&amp; ref = x;  <span class="comment">// 引用ref是变量x的别名</span></span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 修改指针ptr指向的变量的值（x变为20）</span></span><br><span class="line">ref = <span class="number">30</span>;  <span class="comment">// 修改引用ref所引用的变量的值（x变为30）</span></span><br></pre></td></tr></table></figure><p>总结：<br>指针和引用在C++中都是非常有用的工具，它们都用于处理变量和内存。选择使用指针还是引用取决于具体的情况和需求。通常情况下，如果你需要在运行时更改指向的对象，或者需要支持空值，使用指针是更好的选择。如果你只需要别名来简化代码并且不需要重新指向其他对象，使用引用可能更方便和安全。</p><h2 id="final和const区别">final和const区别</h2><p><code>final</code>和<code>const</code>是两个不同的关键字，用于不同的目的和场景。它们之间的区别如下：</p><ol><li><p>用途和作用：</p><ul><li><code>final</code>关键字用于类、函数和继承关系，用于限制继承、函数重写和继承链的扩展性。</li><li><code>const</code>关键字用于声明常量、指示对象为只读，以及修饰函数参数和成员函数，用于控制数据的不可修改性。</li></ul></li><li><p>应用范围：</p><ul><li><code>final</code>关键字适用于类的声明、虚函数的声明和派生类的声明。</li><li><code>const</code>关键字适用于变量、函数参数、函数返回类型和成员函数。</li></ul></li><li><p>修改限制：</p><ul><li><code>final</code>关键字用于禁止类被继承、虚函数被重写和派生类的进一步派生。</li><li><code>const</code>关键字用于声明常量或指示对象为只读，不能修改被声明为<code>const</code>的对象。</li></ul></li><li><p>作用于对象：</p><ul><li><code>final</code>关键字作用于类和函数，用于限制其可继承性和重写性。</li><li><code>const</code>关键字作用于变量和函数，用于声明常量、指示只读性以及限制对被修饰对象的修改。</li></ul></li></ol><p>总的来说，<code>final</code>关键字用于限制继承和函数重写的扩展性，而<code>const</code>关键字用于声明常量和指示对象的只读性。它们在用途、应用范围和作用于对象上都有明显的差异。</p><h2 id="使用-和-的区别">使用 .和-&gt;的区别</h2><p>在C++中，使用<code>.</code>和<code>-&gt;</code>是用于访问指针所指向的对象的成员的两种方式。</p><ol><li><p>点操作符（.）：点操作符用于直接访问对象的成员，它只能用于对象本身，而不能用于指针。如果要使用点操作符，需要将指针解引用为对象。</p></li><li><p>箭头操作符（-&gt;）：箭头操作符用于通过指针间接访问对象的成员，它是指针特有的操作符。使用箭头操作符时，不需要将指针解引用为对象。</p></li></ol><p>下面是一个简单的示例代码，演示了<code>.</code>和<code>-&gt;</code>的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.value = <span class="number">42</span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>();      <span class="comment">// 使用点操作符直接访问对象成员，输出: Value: 42</span></span><br><span class="line"></span><br><span class="line">    MyClass* ptr = &amp;obj;</span><br><span class="line">    ptr-&gt;value = <span class="number">24</span>;</span><br><span class="line">    ptr-&gt;<span class="built_in">printValue</span>();     <span class="comment">// 使用箭头操作符通过指针间接访问对象成员，输出: Value: 24</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个<code>MyClass</code>类，其中包含一个整型成员变量<code>value</code>和一个成员函数<code>printValue()</code>。在<code>main()</code>函数中，我们创建了一个<code>MyClass</code>对象<code>obj</code>，并通过点操作符直接访问了对象的成员变量<code>value</code>和成员函数<code>printValue()</code>。</p><p>然后，我们创建了一个指向<code>obj</code>的指针<code>ptr</code>，并使用箭头操作符通过指针间接访问了对象的成员变量<code>value</code>和成员函数<code>printValue()</code>。注意，使用箭头操作符时，不需要解引用指针。</p><p>总结起来：</p><ul><li>使用<code>.</code>操作符用于直接访问对象的成员，需要对象本身而不是指针。</li><li>使用<code>-&gt;</code>操作符用于通过指针间接访问对象的成员，不需要解引用指针。</li></ul><h2 id="为什么说-bits-stdc-h-是万能头文件">为什么说&lt;bits/stdc++.h&gt;是万能头文件</h2><p>在C++编程中，<code>&lt;bits/stdc++.h&gt;</code>是一个非标准头文件，它通常被用于竞赛编程和快速原型开发，被认为是&quot;万能头文件&quot;。这个头文件包含了大量常用的标准C++库的其他头文件，因此在使用它之后，就不需要为每个标准库引入单独的头文件了。</p><p>使用<code>&lt;bits/stdc++.h&gt;</code>头文件的好处是它简化了代码的编写，因为只需要包含一个头文件即可使用大部分标准库的功能，不需要考虑具体的头文件路径和引入顺序。这在竞赛编程中尤为方便，因为可以节省编写和调试代码所需的时间。</p><p>然而，需要注意的是，<code>&lt;bits/stdc++.h&gt;</code>不是标准C++的一部分，它只是某些编译器（如GCC和MinGW）的扩展。因此，在一些特定的开发环境中，可能无法使用这个头文件。此外，它包含了大量标准库的内容，可能会导致编译时间增加，因此在大型项目或需要精细控制的场景中，最好使用具体的标准库头文件，而不是依赖于<code>&lt;bits/stdc++.h&gt;</code>。</p><p>总而言之，尽管<code>&lt;bits/stdc++.h&gt;</code>头文件方便编写快速原型和竞赛代码，但在实际开发中，建议使用精确的标准库头文件来保证代码的可读性和可维护性。</p><h2 id="中常量和静态变量的区别">中常量和静态变量的区别</h2><p>在C++中，常量和静态变量是两种不同的概念。</p><ol><li><p>常量（Constants）：</p><ul><li>常量是指在程序中声明的固定值，其值在整个程序执行期间不可改变。</li><li>常量可以使用<code>const</code>关键字声明，并且必须在声明时进行初始化。</li><li>常量的值在编译时确定，并且不能在程序运行时修改。</li><li>常量在内存中通常被视为字面值，并且可能会被编译器进行优化。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li><li><p>静态变量（Static Variables）：</p><ul><li>静态变量是指在函数内部或者类的成员变量中声明的变量，在程序执行期间保持其值不变。</li><li>静态变量在内存中只有一份拷贝，被所有对象或者函数所共享。</li><li>静态变量在函数内部时，只会在第一次执行函数时进行初始化，并且在函数调用结束后不会被销毁。</li><li>静态成员变量在类中时，可以通过类名和作用域解析运算符来访问。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  count++;</span><br><span class="line">  cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> instanceCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::instanceCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><p>总结：<br>常量是指在程序中声明的固定值，其值在整个程序执行期间不可改变。而静态变量是在函数或类中声明的变量，它们的值在程序执行期间保持不变。常量在声明时必须初始化，而静态变量可以在声明时初始化，也可以在需要的时候进行赋值。常量在内存中通常被视为字面值，而静态变量在内存中只有一份拷贝。</p><h2 id="为什么常量引用就可以赋普通数值">为什么常量引用就可以赋普通数值</h2><p>在C++中，常量引用可以绑定到普通数值，是因为编译器会进行隐式类型转换。</p><p>当一个常量引用被初始化为一个普通数值时，编译器会自动进行类型转换，将普通数值转换为一个临时的匿名常量。这个匿名常量与原始的普通数值具有相同的值，但是它被视为一个常量，因此可以绑定到常量引用。</p><p>这种隐式类型转换在编译器层面进行，开发者不需要手动进行类型转换操作。这样的设计使得常量引用能够更灵活地与普通数值进行交互，同时保持了对常量的限制。</p><p>以下是一个示例，展示了常量引用绑定到普通数值的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(number);  <span class="comment">// 常量引用绑定到普通数值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>printValue</code>函数接受一个常量引用参数，然后打印该值。在<code>main</code>函数中，我们将一个普通数值<code>number</code>作为参数传递给<code>printValue</code>函数。编译器会进行隐式类型转换，将普通数值<code>number</code>转换为一个匿名常量，并将其绑定到函数中的常量引用参数。</p><p>需要注意的是，这种隐式类型转换只适用于常量引用，而不能直接应用于非常量引用。如果尝试将一个非常量引用绑定到普通数值，则会引发编译错误。</p><h2 id="c-版本">c++版本</h2><p>C++98是C++语言的第一个标准化版本，于1998年发布。在C++98之后，还发布了几个C++标准版本，每个版本都引入了新的特性和语言改进。以下是C++98之后的一些重要版本及其主要特性：</p><ol><li><p>C++03（C++98修正版）：</p><ul><li>C++03于2003年发布，是对C++98标准的一些小修正和改进。</li><li>主要修正了一些语言和库的缺陷，提供了更好的兼容性和稳定性。</li></ul></li><li><p>C++11（C++0x）：</p><ul><li>C++11于2011年发布，是C++标准的重大更新。</li><li>引入了许多新的语言特性，如自动类型推导（auto关键字）、统一的初始化语法（初始化列表和花括号初始化）、lambda表达式、右值引用（移动语义）、智能指针、范围-based for循环等。</li><li>添加了一些标准库组件，如std::thread（多线程编程）、std::regex（正则表达式库）、std::chrono（时间和时钟库）等。</li><li>引入了异常规范的改进和新的关键字（例如noexcept和constexpr）。</li></ul></li><li><p>C++14：</p><ul><li>C++14于2014年发布，是对C++11的一些小改进和扩展。</li><li>改进了类型推导规则，简化了代码书写。</li><li>增加了二进制字面值、通用的lambda捕获初始化、返回类型推导、constexpr函数的放宽等新特性。</li><li>扩展了标准库，包括std::make_unique（智能指针的增强版）、std::user-defined literals（自定义字面值）等。</li></ul></li><li><p>C++17：</p><ul><li>C++17于2017年发布，引入了一些重要的新功能。</li><li>增加了结构化绑定（structured bindings）、if语句中的初始化、折叠表达式（fold expressions）等语言特性。</li><li>扩展了标准库，包括std::optional（可选值）、std::variant（变体类型）、std::any（类型安全的任意类型容器）等。</li></ul></li><li><p>C++20：</p><ul><li>C++20于2020年发布，是一个较大的标准更新。</li><li>引入了一些新的语言特性，如概念（Concepts）、协程（Coroutines）、三方运算符（Three-Way Comparison）等。</li><li>扩展了标准库，包括std::span（跨度类型）、std::ranges（范围库）、std::format（格式化字符串）等。</li></ul></li></ol><p>每个C++标准版本都带来了新的语言特性和库扩展，以提供更好的编程体验和更强大的功能。开发者可以根据目标平台和</p><h2 id="CMake是什么">CMake是什么</h2><p>CMake是一个跨平台的开源构建工具，用于管理软件项目的构建过程。它可以生成适用于不同编译器和操作系统的构建配置文件（如Makefile、Visual Studio项目文件等），使得开发者能够在不同的平台上方便地构建和管理项目。</p><p>CMake的设计目标是提供一种简化和标准化的构建系统，使得开发者能够更容易地跨平台开发和构建软件。它使用一种声明式的方式来描述项目的构建过程，开发者可以编写CMakeLists.txt文件，其中包含了构建配置和规则。</p><p>CMake具有以下特点和功能：</p><ol><li><p>跨平台支持：CMake可以在各种操作系统上工作，包括Windows、macOS、Linux等，以及多种编译器和构建工具。</p></li><li><p>简化的语法：CMake使用一种简化的声明式语法，开发者可以通过编写CMakeLists.txt文件来描述项目的构建规则，包括源文件、编译选项、链接库等。</p></li><li><p>自动检测依赖：CMake能够自动检测项目所依赖的外部库和组件，并生成相应的构建配置，以确保构建过程中的依赖关系得到满足。</p></li><li><p>多种构建系统支持：CMake可以生成各种常见的构建系统配置文件，如Makefile、Ninja、Visual Studio项目文件等，使得开发者可以选择他们熟悉的构建工具进行项目构建。</p></li><li><p>嵌套项目支持：CMake支持管理和构建多个嵌套的子项目，使得大型项目可以被分解为多个模块，并方便地进行组织和构建。</p></li></ol><p>使用CMake，开发者可以根据自己的需求和目标平台，编写CMakeLists.txt文件来定义项目的构建过程。然后，通过运行CMake命令来生成适合于不同平台和编译器的构建配置文件，最后使用相应的构建工具进行项目构建。</p><p>总结起来，CMake是一个跨平台的开源构建工具，用于管理软件项目的构建过程。它提供了一种简化和标准化的构建系统，使得开发者能够更容易地跨平台开发和构建软件。</p><h2 id="头文件条件编译指令">头文件条件编译指令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</span></span></span><br><span class="line">什么意思</span><br></pre></td></tr></table></figure><p>这段代码是C++中的条件编译指令，用于在编译过程中控制头文件的包含。下面解释每一行的含义：</p><ol><li><p><code>#ifndef EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是条件编译指令的开始部分。<code>#ifndef</code>表示&quot;if not defined&quot;，即如果<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>未定义，执行后续操作。</p></li><li><p><code>#define EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是宏定义指令。它定义了一个名为<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>的宏，并将其设置为非零值。这个宏的作用是用于条件判断，后续可以根据这个宏是否被定义来执行不同的代码。</p></li><li><p><code>#endif //EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>：这是条件编译指令的结束部分。<code>#endif</code>表示结束条件编译块，此处是与<code>#ifndef</code>对应的结束。<code>//EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>是一个注释，用于提供对<code>#ifndef</code>的标识说明。</p></li></ol><p>整个代码的作用是，当<code>EMPLOYEEMANAGEMENTSYSTEM_STUDENT_H</code>宏未定义时，执行后续的代码，即将头文件的内容包含在条件编译块中。这样可以避免重复包含头文件，防止多重定义错误。</p><p>常见的做法是将这样的条件编译指令放在头文件的开头和结尾，以确保头文件只被编译一次。这样可以防止在多个源文件中包含同一个头文件时出现重复定义的问题。</p><h2 id="Clang-Tidy-Function-‘getId’-should-be-marked-nodiscard">Clang-Tidy: Function ‘getId’ should be marked [[nodiscard]]</h2><p>这个提示来自于Clang-Tidy，它建议在函数<code>getId</code>上添加<code>[[nodiscard]]</code>属性。</p><p><code>[[nodiscard]]</code>是C++17引入的一种属性，用于指示函数的返回值应该被使用，而不是被忽略。当函数被标记为<code>[[nodiscard]]</code>时，编译器会在函数返回值没有被使用时产生警告。</p><p>在你的情况下，Clang-Tidy建议在<code>getId</code>函数上添加<code>[[nodiscard]]</code>属性，这意味着调用该函数后应该使用其返回值。如果忽略了该返回值，编译器会发出警告，提醒开发者检查和处理函数的返回值。</p><p>为了解决这个警告，你可以按照建议在<code>getId</code>函数声明或定义的地方添加<code>[[nodiscard]]</code>属性，以明确表示该函数的返回值应该被使用。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; ... &#125;  <span class="comment">// 函数声明或定义处添加[[nodiscard]]属性</span></span><br></pre></td></tr></table></figure><p>通过遵循这个提示，可以提高代码的可读性和健壮性，防止因为未使用函数返回值而导致的潜在错误。</p><h2 id="Clang-Tidy是什么">Clang-Tidy是什么</h2><p>Clang-Tidy是一个静态代码分析工具，用于检查和改进C++代码的质量。它是基于LLVM/Clang项目开发的，可以通过对C++代码进行静态分析和规则检查，提供有关代码潜在问题和改进建议的警告和建议。</p><p>Clang-Tidy使用Clang编译器的词法和语法分析功能，对代码进行静态分析，以识别潜在的错误、低效的代码、不规范的编码风格以及其他可能影响代码质量和性能的问题。它基于一组预定义的规则（检查器）执行静态代码分析，并生成相应的警告和建议。</p><p>Clang-Tidy的一些主要功能和特点包括：</p><ol><li><p>丰富的检查器集合：Clang-Tidy提供了多个内置的检查器，覆盖了各种代码问题，如潜在的错误、代码风格违规、性能问题等。每个检查器都有一个独立的规则集，可以根据需要启用或禁用。</p></li><li><p>可配置性：Clang-Tidy允许用户通过配置文件或命令行选项自定义检查器的行为。用户可以选择性地启用或禁用特定的检查器、调整警告级别，并提供自定义规则和扩展。</p></li><li><p>集成到构建系统：Clang-Tidy可以与常见的构建系统（如CMake和Make）集成，通过构建工具自动执行静态分析，并将警告和建议集成到编译过程中。</p></li><li><p>自动修复：在某些情况下，Clang-Tidy可以自动修复一些常见的代码问题，如修复不规范的代码风格或潜在的错误。这减少了手动修复的工作量，并提高了代码的一致性。</p></li></ol><p>通过使用Clang-Tidy，开发者可以更早地发现和纠正潜在的代码问题，改进代码质量和可维护性，并遵循良好的编码实践。它可以在开发过程中作为一种辅助工具，帮助开发者编写更高质量、更健壮的C++代码。</p><h2 id="C-中域是什么">C++中域是什么</h2><p>在C++中，域（Scope）是指程序中定义和访问标识符（变量、函数、类等）的可见性和生命周期的范围。每个标识符都存在于特定的域中，并且只能在其所属的域中被访问和使用。</p><p>C++中有以下几种类型的域：</p><ol><li><p>全局域（Global Scope）：</p><ul><li>全局域是整个程序的最外层域，其中定义的标识符在整个程序中都可见。</li><li>全局域中定义的变量和函数可以在程序的任何地方使用。</li></ul></li><li><p>命名空间域（Namespace Scope）：</p><ul><li>命名空间是一种用于组织标识符的机制，在C++中可以通过<code>namespace</code>关键字定义。</li><li>在命名空间中定义的标识符只在该命名空间中可见，需要使用命名空间限定符才能访问。</li></ul></li><li><p>类域（Class Scope）：</p><ul><li>类域是指类中定义的成员变量和成员函数的可见范围。</li><li>在类中定义的成员变量和成员函数只能在类的成员函数中使用，可以通过成员访问操作符（<code>.</code>或<code>-&gt;</code>）来访问。</li></ul></li><li><p>局部域（Local Scope）：</p><ul><li>局部域是指在函数、代码块或循环结构中定义的标识符的可见范围。</li><li>在局部域中定义的变量只在其所属的代码块或函数内部可见，超出该范围后将不再可访问。</li></ul></li><li><p>语句域（Statement Scope）：</p><ul><li>语句域是指在语句中定义的标识符的可见范围。</li><li>在语句中定义的变量只在该语句中可见，超出该语句后将不再可访问。</li></ul></li></ol><p>每个域都有其特定的可见性和生命周期规则。标识符的可见性决定了它在程序的哪些位置可以被访问，而生命周期则指定了标识符在内存中存在的时间范围。理解和正确使用域是编写正确和可维护的C++程序的重要方面。</p><h2 id="常见编译器">常见编译器</h2><p>C++有多个常用的编译器可用，包括但不限于以下几种：</p><ol><li><p>GCC（GNU Compiler Collection）：这是一个开源的编译器套件，包含了C++编译器（g++）。它是许多Linux发行版的默认编译器，并且可在其他操作系统上使用。</p></li><li><p>Clang：Clang是LLVM项目的一部分，是一个开源的编译器套件。它提供了高性能和高度可配置的C++编译器。Clang也可以作为一个可替代的编译器选择。</p></li><li><p>Microsoft Visual C++：这是Windows平台上的官方C++编译器。它是Microsoft Visual Studio集成开发环境的一部分，提供了丰富的工具和功能。</p></li><li><p>Intel C++ Compiler：这是Intel提供的针对英特尔体系结构的C++编译器。它专注于优化性能，并且在某些情况下可以生成更高效的代码。</p></li><li><p>Clang-CL：这是基于Clang的微软开发的一种编译器，兼容于Windows平台，支持Microsoft Visual Studio开发环境。</p></li></ol><p>以上是一些常用的C++编译器，每个编译器都有其特点和优势。选择编译器时，可以根据特定的需求、平台和个人偏好做出决策。</p><h2 id="MinGW">MinGW</h2><p>MinGW（Minimalist GNU for Windows）是一个开源的软件开发工具包，旨在为Windows平台提供GNU工具集和开发环境。它基于GCC（GNU Compiler Collection）和binutils，并包括了一系列的工具，如C/C++编译器、链接器、调试器等。</p><p>MinGW的目标是在Windows上提供一个轻量级的开发环境，以便开发人员可以使用类Unix的工具和命令来编译、链接和调试他们的代码。它使用GNU工具链，因此能够提供广泛的开发功能和特性。</p><p>MinGW的主要优点之一是它允许开发人员在Windows上使用常见的Unix工具和库，而无需依赖于Windows特定的API和工具。这使得开发人员能够更容易地将他们的代码从Unix/Linux平台移植到Windows平台。</p><p>另一个重要的特点是MinGW提供了一个轻量级的替代品，相对于使用完整的Visual Studio开发环境，它可以更快地进行编译和构建。这使得MinGW成为一种流行的选择，特别是对于需要快速原型设计和小型项目开发的开发人员。</p><p>总而言之，MinGW是一个提供GNU工具集和开发环境的软件开发工具包，用于在Windows平台上进行C/C++开发。它为开发人员提供了一种在Windows上使用Unix工具和库的简便方式，以及更快的编译和构建速度。</p><h2 id="GNU">GNU</h2><p>GNU是一个自由软件运动的项目，目标是为用户提供自由的计算机操作系统。GNU项目的全称是“GNU’s Not Unix”，这是一个递归缩写，意思是“GNU不是Unix”。它的目标是创建一个类Unix的操作系统，但不依赖于Unix的代码。</p><p>GNU项目始于1983年，由理查德·斯托曼（Richard Stallman）发起。斯托曼意识到许多计算机用户面临私有软件的限制，无法查看、修改和分享软件的源代码。为了解决这个问题，他发起了GNU项目，旨在开发一个完全自由的操作系统。</p><p>GNU项目包括了许多关键的组件，如GNU编译器集合（GCC）、GNU调试器（GDB）、GNU Bash shell、GNU核心工具集（Coreutils）等。这些组件形成了一个完整的自由软件堆栈，可用于构建自由操作系统。</p><p>然而，GNU项目中唯一尚未完成的部分是操作系统内核。为了填补这个空白，GNU项目与Linux内核相结合，形成了今天被广泛使用的GNU/Linux操作系统。GNU/Linux操作系统的基础是Linux内核，但它包含了许多GNU项目的组件，使得用户能够使用自由软件构建和定制他们的系统。</p><p>总而言之，GNU是一个自由软件运动的项目，旨在为用户提供自由的计算机操作系统。它的组件构成了一个完整的自由软件堆栈，并与Linux内核结合形成了GNU/Linux操作系统。GNU项目强调用户自由、开放源代码和共享，对于自由软件的发展和推广做出了重要贡献。</p><h2 id="OpenGL">OpenGL</h2><p>OpenGL（Open Graphics Library）是一个用于渲染2D和3D图形的跨平台编程接口（API）。它是一个开放标准，由Khronos Group维护和推进。OpenGL提供了一系列的函数，用于操作图形硬件和执行图形计算，使开发人员能够创建高性能的图形应用程序。</p><p>OpenGL可以用于各种平台，包括Windows、macOS、Linux以及移动平台如Android和iOS。它与硬件无关，能够利用图形加速硬件（如图形处理器）来实现快速而逼真的图形渲染。</p><p>OpenGL提供了一系列功能和操作，包括几何图元绘制、纹理映射、光照、深度测试、着色器编程等。它使用一种状态机模型，通过设置不同的状态来定义绘图操作和渲染效果。开发人员可以使用OpenGL来创建各种类型的图形应用程序，包括游戏、可视化工具、模拟器、CAD软件等。</p><p>OpenGL的主要优点包括：</p><ol><li><p>跨平台：OpenGL可在多个平台上使用，使开发人员能够编写一次代码并在不同的系统上运行。</p></li><li><p>高性能：OpenGL能够利用硬件加速来实现高效的图形渲染，提供流畅的用户体验。</p></li><li><p>可扩展性：OpenGL支持扩展，开发人员可以利用额外的功能和特性来满足特定需求。</p></li><li><p>开放标准：OpenGL是一个开放的标准，各个硬件和软件供应商可以实现和支持它，确保了广泛的兼容性和可移植性。</p></li></ol><p>总而言之，OpenGL是一个跨平台的图形渲染API，用于创建高性能的2D和3D图形应用程序。它提供了丰富的功能和操作，可用于绘制几何图元、应用纹理、执行光照和着色器编程等。通过利用硬件加速，OpenGL能够实现快速而逼真的图形渲染，广泛应用于游戏开发、可视化工具、CAD软件等领域。</p><h2 id="Iceberg">Iceberg</h2><p>在计算机科学中，“Iceberg”（冰山）技术通常指的是一种数据管理和查询优化技术，用于处理大规模数据集中的稀疏数据。</p><p>Iceberg技术的目标是提高处理大型数据集中稀疏数据的效率。在许多实际应用中，数据集中只有少部分数据是频繁访问的，而大部分数据则很少被使用。传统的数据存储和查询方法会对整个数据集进行处理，包括那些很少被使用的数据，从而浪费了计算资源和存储空间。</p><p>Iceberg技术通过将数据分成热数据（频繁访问的数据）和冷数据（很少访问的数据）两个部分来解决这个问题。热数据通常被保留在高性能的存储介质上，而冷数据则被移动到低成本的存储介质上，如分布式文件系统或对象存储。这样一来，只有热数据需要频繁访问，而冷数据可以以更低的成本存储和管理。</p><p>Iceberg技术还可以针对热数据应用各种优化技术，例如数据压缩、索引和分区，以提高查询性能。此外，它还提供了数据版本控制和事务支持，使得数据的更新和变更能够被有效地管理和追踪。</p><p>Iceberg技术在大数据处理领域得到了广泛应用，特别是在数据湖和数据仓库的构建和管理中。它提供了一种灵活而高效的方式来处理和查询大规模数据集，同时减少了存储成本和查询时间。</p><h2 id="HDFS">HDFS</h2><p>HDFS（Hadoop Distributed File System）是Apache Hadoop生态系统中的一项关键技术，它是一种用于存储和处理大规模数据集的分布式文件系统。</p><p>HDFS的设计目标是在大规模集群上提供高容错性、高吞吐量和可伸缩性的数据存储解决方案。它基于主从架构，其中包括一个主节点（NameNode）和多个从节点（DataNode）组成。HDFS将数据划分为固定大小的数据块，并将这些数据块存储在从节点上。主节点负责管理文件系统的元数据，如文件的名称、位置和权限等。</p><p>HDFS的主要特点包括：</p><ol><li><p>分布式存储：数据被分散存储在多个从节点上，可以横向扩展以适应大规模数据集的存储需求。</p></li><li><p>冗余备份：HDFS会将数据块复制到多个从节点上，以提供数据的冗余备份和容错性。通常，默认情况下，每个数据块会有三个副本存储在不同的从节点上。</p></li><li><p>高容错性：当从节点发生故障或数据损坏时，HDFS能够自动检测和恢复数据，确保数据的可靠性。</p></li><li><p>适合大数据处理：HDFS的设计使其适合处理大规模数据集的工作负载。它通过数据本地性和并行计算来提高数据处理的效率。</p></li></ol><p>HDFS被广泛应用于大数据处理和分析领域。它为许多分布式计算框架（如MapReduce）提供了数据存储和访问的基础，并支持对大规模数据集的高效处理和分析。</p><h2 id="Opencv">Opencv</h2><p>OpenCV（Open Source Computer Vision）是一个开源的计算机视觉库，旨在提供一系列用于图像处理、计算机视觉和机器学习的函数和工具。它是一个广泛使用的库，可用于开发各种视觉应用程序，包括图像和视频处理、目标检测和跟踪、人脸识别、机器学习等。</p><p>OpenCV最初由英特尔公司于1999年发起，后来成为一个跨平台的开源项目。它使用C++语言编写，但也提供了许多其他编程语言的接口，包括Python、Java和MATLAB等，使得开发人员可以方便地在不同的环境中使用OpenCV。</p><p>OpenCV提供了大量的函数和算法，用于处理图像和视频数据。它支持基本的图像操作（如裁剪、调整大小、滤波等）、特征提取和描述（如边缘检测、角点检测、直线检测等）、图像匹配和配准、运动估计、三维重建等。此外，OpenCV还包含了许多机器学习算法的实现，如支持向量机（SVM）、随机森林（Random Forests）、神经网络等，用于目标分类和识别。</p><p>OpenCV被广泛应用于计算机视觉领域的研究和开发中，它在学术界和工业界都有很高的声誉和应用价值。无论是进行基础的图像处理还是复杂的计算机视觉任务，OpenCV都提供了丰富的功能和工具，使得开发者能够快速实现他们的视觉应用。</p><h2 id="命名空间在项目开发中的作用">命名空间在项目开发中的作用</h2><p>在项目开发中，命名空间具有以下几个重要的作用：</p><ol><li><p>避免命名冲突：命名空间可以将代码标识符（变量、函数、类等）分组和隔离，避免不同部分的代码之间的命名冲突。不同的命名空间中可以使用相同名称的标识符，因为它们的作用域被限定在各自的命名空间内。</p></li><li><p>提供代码组织和模块化：通过将相关的代码放置在同一个命名空间中，可以提供逻辑上的分组和组织，使得代码结构更加清晰和可维护。命名空间可以按照功能、模块或层次结构进行组织，使得开发人员能够更容易地理解和维护代码。</p></li><li><p>增加可读性和可扩展性：通过在代码中使用命名空间，可以提高代码的可读性和可理解性。命名空间可以为代码添加上下文和语义，使得代码的意图更加清晰。此外，命名空间也为项目的扩展性提供了支持，因为新的代码可以添加到现有的命名空间中，而无需修改或重构现有代码。</p></li><li><p>允许使用相同名称的标识符：不同的命名空间中可以使用相同名称的标识符，而不会发生冲突。这对于与第三方库或其他模块集成时特别有用，可以避免不同模块之间的名称冲突，并支持更好的代码重用和组合。</p></li><li><p>限定标识符的作用域：命名空间通过命名空间限定符（<code>::</code>）来限定标识符的作用域。这可以使得代码更加明确和可控，避免全局作用域的滥用。只有在需要使用特定命名空间中的标识符时，才需要显式地引用它们，提高了代码的可维护性和可读性。</p></li></ol><p>总的来说，命名空间在项目开发中起到了隔离、组织和管理代码的作用。它们提供了一种结构化的方式来处理命名冲突，并提高了代码的可读性、可维护性和可扩展性。通过合理地使用命名空间，可以更好地组织项目代码，减少潜在的问题，并提高团队协作的效率。</p><h2 id="explicit">explicit</h2><p>在C++中，<code>explicit</code>是一个关键字，用于修饰类的单参数构造函数（或除默认参数外的多参数构造函数）。使用<code>explicit</code>关键字可以防止隐式的类型转换发生。</p><p>通常情况下，当我们定义一个只有一个参数的构造函数时，编译器会自动将该构造函数用于隐式类型转换。这意味着，当我们使用该类的对象进行赋值、初始化或作为函数参数时，编译器会自动进行类型转换。</p><p>下面是一个示例，展示了没有使用<code>explicit</code>关键字时，构造函数的隐式类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with MyClass object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">5</span>;   <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="built_in">doSomething</span>(<span class="number">10</span>);   <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code>类定义了一个单参数构造函数，该构造函数接受一个<code>int</code>类型的参数。在<code>main()</code>函数中，我们使用整数值进行赋值和函数调用，编译器会自动进行隐式类型转换来创建<code>MyClass</code>对象。</p><p>然而，有时候我们希望明确地控制类型转换，避免出现意外的转换行为。这时就可以使用<code>explicit</code>关键字来声明构造函数，并禁止隐式类型转换。</p><p>下面是使用<code>explicit</code>关键字修饰构造函数的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> : m_value(value) &#123;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with MyClass object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">5</span>;    <span class="comment">// 错误，禁止隐式类型转换</span></span><br><span class="line">    <span class="built_in">doSomething</span>(<span class="number">10</span>);    <span class="comment">// 错误，禁止隐式类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们在构造函数前面加上了<code>explicit</code>关键字。这意味着构造函数只能被显式调用，而禁止了隐式类型转换。在<code>main()</code>函数中的赋值和函数调用将会导致编译错误。</p><p>通过使用<code>explicit</code>关键字，我们可以更加明确地控制对象的创建和类型转换，避免一些潜在的错误和意外行为。但需要注意，使用<code>explicit</code>关键字可能会导致一些代码的冗长性和不便利性，需要根据实际需求和设计考虑是否使用。</p><h2 id="构造函数的-后面加上-是什么意思">构造函数的()后面加上;是什么意思</h2><p>在C++中，构造函数的()后面加上;是表示一个成员初始化列表（member initializer list）的开始。</p><p>构造函数在创建对象时被调用，用于初始化对象的成员变量。成员初始化列表提供了一种在构造函数体之前初始化成员变量的方式。通过在构造函数的定义中使用成员初始化列表，可以直接为成员变量赋值或调用它们的构造函数。</p><p>下面是一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述示例中，构造函数的定义是 <code>MyClass(int value) : m_value(value) &#123;&#125;</code>。在<code>:</code>之后是成员初始化列表，其中的<code>m_value(value)</code>表示将参数<code>value</code>的值赋给成员变量<code>m_value</code>。这样，在构造函数体之前，成员变量<code>m_value</code>就已经被初始化。</p><p>通过使用成员初始化列表，可以在构造函数体之前对成员变量进行初始化，避免在构造函数体中进行赋值操作，提高代码的效率和可读性。此外，对于一些类类型的成员变量，成员初始化列表还可以调用它们的构造函数进行初始化。</p><p>需要注意的是，成员初始化列表只能用于构造函数中，用于初始化成员变量，不能用于其他成员函数。并且，成员初始化列表的顺序应该与成员变量在类中声明的顺序一致，以避免出现潜在的问题。</p><p>总结起来，构造函数的()后面加上;表示一个成员初始化列表的开始。成员初始化列表用于在构造函数体之前对成员变量进行初始化，提供了一种效率高且可读性好的初始化方式。通过成员初始化列表，可以直接为成员变量赋值或调用它们的构造函数。</p><h2 id="NDK">NDK</h2><p>C++的NDK（Native Development Kit）是一组工具和库，用于开发使用C++编写的Android应用程序。NDK允许开发人员在Android平台上编写高性能的原生代码，通常用于处理计算密集型任务、访问系统硬件和优化性能。</p><p>以下是关于C++的NDK的一些关键概念和使用方法：</p><ol><li><p>NDK的目的：NDK的主要目的是提供一种在Android应用程序中使用C++编写的原生代码的方法。使用C++可以在性能上优化应用程序，处理复杂的计算任务，访问系统级别的API和设备功能，或重用现有的C/C++库。</p></li><li><p>NDK工具链：NDK提供了一套工具链，包括交叉编译器、调试器和构建工具。这些工具链允许将C++代码编译为适用于Android平台的本机机器码。</p></li><li><p>CMake构建系统：NDK推荐使用CMake作为构建系统，用于生成Android应用程序的本机代码。CMake是一个跨平台的构建工具，它可以帮助您定义构建过程和依赖关系，并生成适用于Android的Makefile。</p></li><li><p>JNI接口：在使用NDK开发时，C++代码与Java代码之间的交互通过JNI（Java Native Interface）实现。JNI允许在Java和C++之间进行函数调用和数据传递。</p></li><li><p>支持的ABI：ABI（Application Binary Interface）是指应用程序和操作系统之间的二进制接口规范。NDK支持多个ABI，包括armeabi、armeabi-v7a、arm64-v8a、x86和x86_64。开发人员可以选择适合其应用程序的ABI，以实现最佳的性能和兼容性。</p></li><li><p>使用第三方库：NDK还允许开发人员使用现有的C/C++库，如OpenCV、Boost等。通过在NDK构建脚本中配置和链接这些库，可以轻松地将它们与Android应用程序集成在一起。</p></li><li><p>调试和性能分析：NDK提供了调试工具和性能分析工具，以帮助开发人员调试和优化其原生代码。例如，可以使用ndk-gdb命令行工具进行调试，使用perf工具进行性能分析。</p></li></ol><p>请注意，使用NDK编写原生代码需要一定的C++编程知识和Android开发经验。它主要适用于需要高性能计算、底层硬件访问或与现有C/C++库集成的情况。对于一般的Android应用程序开发，通常建议优先考虑使用Java或Kotlin编写代码。</p><h1>数据类型</h1><h2 id="基本数据类型">基本数据类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083744623.png" alt="image-20230613083744623"></p><h2 id="复合数据类型">复合数据类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083845493.png" alt="image-20230613083845493"></p><h2 id="指针类型">指针类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083858532.png" alt="image-20230613083858532"></p><h2 id="枚举类型">枚举类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083909897.png" alt="image-20230613083909897"></p><h2 id="其他数据类型">其他数据类型</h2><p><img src="../assets/image/C++%E5%9F%BA%E7%A1%80_Image/image-20230613083920385.png" alt="image-20230613083920385"></p><h1>类</h1><h2 id="例子">例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> studentId, <span class="type">const</span> std::string&amp; studentName, <span class="type">int</span> studentAge) &#123;</span><br><span class="line">        id = studentId;</span><br><span class="line">        name = studentName;</span><br><span class="line">        age = studentAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Student ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取学生姓名</span></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置学生姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; studentName)</span> </span>&#123;</span><br><span class="line">        name = studentName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="this">this</h2><p>在C++中，关键字<code>this</code>表示当前对象的指针。它是一个隐式的指针，指向调用成员函数的对象本身。通过<code>this</code>指针，可以在类的成员函数中访问和操作当前对象的成员变量和成员函数。</p><p>以下是一个简单的示例代码，演示了<code>this</code>关键字的用途：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_value = value;  <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Address: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;  <span class="comment">// 打印this指针的地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">printValue</span>();     <span class="comment">// 输出: Value: 42</span></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">24</span>);     <span class="comment">// 使用成员函数设置新的值</span></span><br><span class="line">    obj.<span class="built_in">printValue</span>();     <span class="comment">// 输出: Value: 24</span></span><br><span class="line">    obj.<span class="built_in">printAddress</span>();   <span class="comment">// 打印对象的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>MyClass</code>类包含一个整型成员变量<code>m_value</code>和几个成员函数。在<code>setValue()</code>函数中，使用<code>this</code>指针访问并修改了当前对象的成员变量<code>m_value</code>。<code>printAddress()</code>函数使用<code>this</code>指针打印了当前对象的地址。</p><p>在<code>main()</code>函数中，我们创建了一个<code>MyClass</code>对象<code>obj</code>并调用了一系列成员函数。通过使用<code>this</code>指针，我们可以在成员函数中访问和操作对象的成员变量，确保了对当前对象的正确引用。</p><p>需要注意的是，<code>this</code>指针在成员函数内部是一个自动提供的指针，无需显式声明或初始化。它是一个常量指针，不允许修改它指向的对象。</p><p>总结起来，<code>this</code>关键字在C++中表示当前对象的指针，用于在类的成员函数中访问和操作当前对象的成员变量和成员函数。通过使用<code>this</code>指针，可以确保正确引用当前对象，并进行对象内部的操作和交互。</p><h2 id="继承">继承</h2><p>在C++中，继承是一种面向对象编程的重要概念，它允许你创建一个新类（称为子类或派生类），该类继承了另一个类（称为基类或父类）的属性和行为。子类可以继承基类的成员变量和成员函数，并且可以扩展或修改它们。以下是关于继承的一些要点：</p><ol><li><p>基类和派生类：</p><ul><li>基类是已经存在的类，它提供了一组通用的属性和行为。</li><li>派生类是从基类派生而来的新类，它继承了基类的属性和行为，并且可以添加自己的属性和行为。</li></ul></li><li><p>语法：</p><ul><li>在C++中，使用冒号 <code>:</code> 来指定派生类继承基类。例如：<code>class Derived : public Base</code> 表示派生类 <code>Derived</code> 继承了基类 <code>Base</code>。</li><li>继承关系可以是公有（public）、私有（private）或保护（protected）。公有继承意味着基类的公有成员在派生类中仍然是公有的，私有继承和保护继承会有相应的访问限制。</li></ul></li><li><p>继承类型：</p><ul><li>公有继承（public inheritance）：派生类继承了基类的公有成员和保护成员，但私有成员不可直接访问。</li><li>私有继承（private inheritance）：派生类继承了基类的所有成员，但它们都变成了私有成员，只能在派生类内部访问。</li><li>保护继承（protected inheritance）：派生类继承了基类的保护成员和公有成员，但它们都变成了保护成员，只能在派生类内部和派生类的子类中访问。</li></ul></li><li><p>成员访问权限：</p><ul><li>派生类可以访问基类的公有和保护成员，但不能直接访问基类的私有成员。</li><li>派生类可以通过成员函数和友元函数来访问基类的私有成员。</li><li>在派生类中，可以使用作用域解析运算符 <code>::</code> 来引用基类的成员。</li></ul></li><li><p>重写和扩展：</p><ul><li>派生类可以重写（override）基类的成员函数，即在派生类中重新实现基类中已有的函数。这允许派生类提供自己的实现。</li><li>派生类还可以添加新的成员函数和数据成员，从而扩展基类的功能。</li></ul></li></ol><p>以下是一个简单的示例，演示了继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; <span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">Shape</span>(w, h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">int</span> w, <span class="type">int</span> h) : <span class="built_in">Shape</span>(w, h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="继承和访问关系">继承和访问关系</h2><table><thead><tr><th></th><th>基类的公有成员</th><th>基类的保护成员</th><th>基类的私有成员</th></tr></thead><tbody><tr><td>公有继承</td><td>可访问</td><td>可访问</td><td>不可访问</td></tr><tr><td>保护继承</td><td>保护</td><td>保护</td><td>不可访问</td></tr><tr><td>私有继承</td><td>私有</td><td>私有</td><td>不可访问</td></tr></tbody></table><h2 id="派生类访问基类私有成员">派生类访问基类私有成员</h2><p>在C++中，派生类是基类的扩展，可以继承基类的成员（公有、受保护和私有）。私有成员是基类中具有最高访问权限的成员，只能在基类的成员函数和友元函数中直接访问。然而，派生类可以通过以下两种方式访问基类的私有成员：</p><ol><li><p>成员函数：</p><ul><li>派生类可以通过继承基类的公有和受保护成员函数，间接地访问基类的私有成员。</li><li>由于派生类继承了基类的成员函数，这些成员函数在派生类中仍然可以访问基类的私有成员。</li></ul></li><li><p>友元函数：</p><ul><li>如果基类将派生类声明为友元类，那么派生类的成员函数和友元函数可以直接访问基类的私有成员。</li><li>友元函数是在类外部声明的函数，可以访问该类的私有成员，因此通过将派生类声明为基类的友元类，可以使派生类的成员函数和友元函数访问基类的私有成员。</li></ul></li></ol><p>通过这两种方式，派生类可以在某种程度上访问基类的私有成员，但需要注意的是，派生类应该尽量遵循封装原则，尽量不直接访问基类的私有成员，以保持类的封装性和数据的安全性。</p><p>以下是一个示例，演示了派生类通过成员函数和友元函数访问基类的私有成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> val) : <span class="built_in">privateVar</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Derived</span>;  <span class="comment">// 将Derived声明为Base的友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessBasePrivateMember</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> val = privateVar;  <span class="comment">// 可以访问基类的私有成员</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&#x27;s privateVar through Derived: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derived;</span><br><span class="line">    derived.<span class="built_in">accessBasePrivateMember</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>Base</code> 类具有一个私有成员变量 <code>privateVar</code>，而 <code>Derived</code> 类通过公有继承继承了 <code>Base</code> 类，并且将 <code>Derived</code> 声明为 <code>Base</code> 的友元类。因此，<code>Derived</code> 类的成员函数 <code>accessBasePrivateMember()</code> 可以直接访问基类 <code>Base</code> 的私有成员变量 <code>privateVar</code>。</p><p>需要注意的是，友元关系是单向的，即在上面的示例中，<code>Derived</code> 类可以访问 <code>Base</code> 类的私有成员，但 <code>Base</code> 类不能访问 <code>Derived</code> 类的私有成员。友元关系应该谨慎使用，以确保访问权限的正确性和安全性。</p><h2 id="override">override</h2><p>在C++中，<code>override</code> 关键字用于显式地标识派生类中的成员函数，表示该函数是对基类中的虚函数进行重写。<code>override</code> 关键字有助于提高代码的可读性，并在编译时进行检查，以确保正确地重写了基类的虚函数。</p><p>使用 <code>override</code> 的一般语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">Derived::function_name</span><span class="params">(parameters)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在派生类中重写基类的虚函数时，使用 <code>override</code> 关键字将其放置在函数声明的末尾。编译器会验证该函数是否正确地重写了基类的虚函数，如果未找到匹配的基类虚函数，或者函数签名不匹配，则会产生编译错误。</p><p>下面是一个示例，演示了如何使用 <code>override</code> 关键字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is the base class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is the derived class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    basePtr-&gt;<span class="built_in">printMessage</span>();  <span class="comment">// 输出: &quot;This is the derived class.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>Base</code> 类定义了一个虚函数 <code>printMessage()</code>，而 <code>Derived</code> 类通过公有继承重写了该函数。在 <code>Derived</code> 类中，使用 <code>override</code> 关键字标识了对基类函数的重写。</p><p>在 <code>main()</code> 函数中，我们创建了一个指向 <code>Derived</code> 类对象的基类指针 <code>basePtr</code>，并调用了 <code>printMessage()</code> 函数。由于基类指针指向派生类对象，因此调用的是派生类中重写的函数。输出结果为 “This is the derived class.”。</p><p>通过使用 <code>override</code> 关键字，可以确保在派生类中正确地重写了基类的虚函数，以实现多态行为。如果派生类中的函数签名与基类虚函数不匹配，编译器将发出错误提示，帮助我们检测潜在的错误。</p><h2 id="虚函数">虚函数</h2><p>虚函数是在基类中声明为虚函数的成员函数，用于实现多态性（polymorphism）。多态性是面向对象编程的一个重要特性，它允许通过基类的指针或引用来调用派生类的特定实现。</p><p>虚函数的作用包括：</p><ol><li><p>实现运行时多态：通过基类的指针或引用调用虚函数时，根据实际对象的类型确定要调用的函数版本。这样可以在运行时确定调用哪个派生类的函数实现，实现了多态性。</p></li><li><p>提供接口的扩展性：通过在基类中声明虚函数，可以让派生类根据需要进行函数的重写，从而实现接口的扩展。这样，基类的指针或引用可以灵活地调用不同派生类的不同实现。</p></li></ol><p>要将函数声明为虚函数，需要在基类中使用 <code>virtual</code> 关键字进行声明。派生类中重写虚函数时，可以使用 <code>override</code> 关键字显式标识。</p><p>以下是一个示例，演示了虚函数的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>();  <span class="comment">// 输出: &quot;Drawing a circle.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>Shape</code> 类是一个基类，其中的 <code>draw()</code> 函数被声明为虚函数。<code>Circle</code> 和 <code>Rectangle</code> 类分别是 <code>Shape</code> 类的派生类，并在派生类中重写了 <code>draw()</code> 函数。</p><p>在 <code>main()</code> 函数中，我们创建了一个基类指针 <code>shapePtr</code>，并将其指向 <code>Circle</code> 类的对象。通过该指针调用 <code>draw()</code> 函数时，由于函数是虚函数，程序在运行时确定要调用的函数版本，因此调用的是 <code>Circle</code> 类中重写的函数。输出结果为 “Drawing a circle.”。</p><p>通过使用虚函数，我们可以根据实际对象的类型来动态选择要调用的函数版本，实现了多态性和接口的扩展性。这是面向对象编程中的重要概念，有助于编写灵活、可扩展的代码。</p><h1>const</h1><p>在C++中，<code>const</code>是一个关键字，用于声明常量或指示对象为只读。<code>const</code>关键字可以应用于变量、函数参数、函数返回类型和成员函数。</p><p>以下是<code>const</code>关键字的使用方法和注意事项：</p><ol><li>声明常量：<code>const</code>关键字可以用于声明常量，即数值在程序执行期间不可修改的值。常量在声明时必须进行初始化，并且在后续的代码中不能被修改。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明只读变量：将<code>const</code>关键字应用于变量时，表示该变量的值不可被修改。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* constPtr = &amp;x;  <span class="comment">// 指向常量的指针，不可通过指针修改变量的值</span></span><br><span class="line"><span class="comment">// *constPtr = 10;  // 错误，不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">10</span>;  <span class="comment">// 声明只读变量，不可修改</span></span><br><span class="line"><span class="comment">// y = 20;  // 错误，不可修改</span></span><br></pre></td></tr></table></figure><ol start="3"><li>函数参数：将参数声明为<code>const</code>可以确保在函数内部不会修改参数的值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value = 10;  // 错误，不可修改</span></span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>函数返回类型：将函数返回类型声明为<code>const</code>表示返回的对象是只读的，不可在调用端进行修改。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">getValue</span>();</span><br><span class="line"><span class="comment">// getValue() = 10;  // 错误，不可修改返回值</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>声明为<code>const</code>的变量必须在声明时进行初始化，并且不能在后续的代码中修改。</li><li>声明为<code>const</code>的对象只能调用其成员函数中被声明为<code>const</code>的函数。</li><li><code>const</code>修饰符在指针类型中具有两个作用：<code>const int*</code>表示指向常量的指针，<code>int* const</code>表示常量指针（指针本身是常量）。</li><li>当将<code>const</code>修饰符应用于类的成员函数时，表示该函数不会修改类的成员变量。</li></ul><p>使用<code>const</code>关键字可以增加代码的可读性和安全性，防止不必要的变量修改和意外的副作用。合理使用<code>const</code>可以帮助编译器进行优化，并提供更好的代码维护性。同时，需要注意在使用<code>const</code>修饰时，确保遵守<code>const</code>修饰符的规则，避免出现编译错误。</p><h1>final</h1><p><code>final</code>是C++11引入的关键字，用于限制类、函数和继承关系的扩展性。以下是<code>final</code>关键字的使用方法和一些注意事项：</p><ol><li>类的<code>final</code>修饰：将<code>final</code>关键字放在类声明的末尾，表示该类不能被继承。这样可以防止其他类从该类派生，并覆盖或扩展其功能。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  <span class="comment">// 错误，无法从final类Derived继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数的<code>final</code>修饰：将<code>final</code>关键字放在虚函数声明的末尾，表示该虚函数不能在派生类中被重写。这样可以确保派生类无法修改基类的特定行为。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 错误，无法重写被声明为final的虚函数foo()</span></span><br><span class="line">    <span class="comment">// void foo() override &#123;</span></span><br><span class="line">    <span class="comment">//     // ...</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>继承关系中的<code>final</code>修饰：将<code>final</code>关键字放在派生类声明的末尾，表示该派生类不能有后续的派生类。这样可以在继承链上指定最后一个派生类，防止进一步的扩展。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> <span class="keyword">final</span> : <span class="keyword">public</span> Derived1 &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived3</span> : <span class="keyword">public</span> Derived2 &#123;  <span class="comment">// 错误，无法从final类Derived2继承</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>final</code>关键字的注意事项：</p><ul><li><code>final</code>关键字用于限制扩展性，应谨慎使用。在设计类和继承关系时，应仔细考虑是否真正需要限制继承和函数重写。</li><li>使用<code>final</code>关键字可以增强类的安全性和稳定性，特别是用于基类或核心函数，以防止它们被修改。</li><li>避免滥用<code>final</code>关键字，过多地使用可能导致继承层次结构变得过于僵硬和不灵活。</li><li>在继承关系中，使用<code>final</code>关键字可以明确地指定最后一个派生类，以确保继承链的终结。</li><li><code>final</code>关键字适用于类、虚函数和继承关系，但不适用于非虚普通函数。</li><li>在使用<code>final</code>关键字时，应保持代码清晰，以便其他开发人员能够理解和维护代码。</li></ul><p>总的来说，<code>final</code>关键字提供了一种在类、函数和继承关系中限制扩展性的</p><p>机制。适当地使用<code>final</code>可以增强代码的安全性和稳定性，但需要注意不要滥用它，以免造成代码的僵化和不灵活。</p><h1>指针和引用的区别</h1><p>指针和引用是C++中用于处理内存和对象的重要概念，它们有以下区别：</p><ol><li><p>指针可以被重新赋值，而引用一旦绑定到对象，就不能更改绑定的对象。</p></li><li><p>指针可以是空值（nullptr），即指向空地址，而引用必须在声明时绑定到一个对象。</p></li><li><p>指针可以指向多个不同的对象，而引用只能绑定到一个对象，并且不能更改为引用其他对象。</p></li><li><p>指针可以进行指针运算（如指针加法、指针减法等），而引用没有指针运算。</p></li><li><p>指针可以被重新分配内存，而引用不能。</p></li><li><p>引用通常用作函数的参数或返回类型，以实现传递参数或返回值的效果。指针也可以用于相同的目的，但引用通常更直观和安全。</p></li></ol><p>下面是一些示例代码来说明指针和引用之间的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyPointer</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;  <span class="comment">// 修改指针所指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyReference</span><span class="params">(<span class="type">int</span>&amp; ref)</span> </span>&#123;</span><br><span class="line">    ref = <span class="number">200</span>;  <span class="comment">// 修改引用所绑定的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;num;  <span class="comment">// 指针指向num</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = num;  <span class="comment">// 引用绑定到num</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">modifyPointer</span>(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value after modifying pointer: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">// 输出: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">modifyReference</span>(ref);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value after modifying reference: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;  <span class="comment">// 输出: 200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个整数变量 <code>num</code>，并创建了一个指向该变量的指针 <code>ptr</code> 和一个引用 <code>ref</code>。然后，我们编写了两个函数 <code>modifyPointer()</code> 和 <code>modifyReference()</code>，分别用于修改指针和引用所指向的值。</p><p>在 <code>main()</code> 函数中，我们首先通过指针调用 <code>modifyPointer()</code> 函数来修改指针所指向的值，并输出修改后的值。然后，通过引用调用 <code>modifyReference()</code> 函数来修改引用所绑定的值，并再次输出修改后的值。在两次输出中，我们可以看到变量 <code>num</code> 的值被成功修改。</p><p>通过比较指针和引用的使用方式和功能，可以选择适合特定情况的方法。指针提供了更大的灵活性，可以用于动态分配内存和处理数据结构，而引用提供了更简洁的语法和更安全的操作，常用于函数参数传递和返回值。</p><h1>宏定义</h1><p>在C++中，宏定义（Macro Definition）是一种预处理指令，用于在编译之前将代码中的标识符替换为指定的文本。它们是通过预处理器（Preprocessor）在编译阶段执行的，而不是在运行时。</p><p>宏定义使用<code>#define</code>指令来创建，语法形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名称 替换文本</span></span><br></pre></td></tr></table></figure><p>其中，宏名称是你自定义的标识符，替换文本是要替换成的代码片段或值。宏名称通常使用大写字母命名，以便与其他标识符区分开来。</p><p>宏定义可以用于替换任意代码片段，包括表达式、语句、函数调用等。例如，下面是一个简单的宏定义示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> radius = <span class="number">5.0</span>;</span><br><span class="line">    <span class="type">double</span> area = PI * radius * radius;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，宏定义<code>#define PI 3.14159</code>将标识符<code>PI</code>替换为值<code>3.14159</code>。在<code>main()</code>函数中，我们使用<code>PI</code>宏来计算圆的面积。</p><p>宏定义还可以带有参数，称为宏函数（Macro Function）。宏函数的语法与函数类似，可以接受参数并在替换文本中使用它们。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">SQUARE</span>(<span class="number">5</span>);   <span class="comment">// 展开为 ((5) * (5))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，宏函数<code>#define SQUARE(x) ((x) * (x))</code>将传入的参数<code>x</code>平方并返回结果。</p><p>需要注意的是，宏定义是简单的文本替换，没有类型检查和作用域限制。它们在预处理阶段直接替换代码，可能导致一些意想不到的行为。因此，在使用宏定义时需要谨慎，避免引入不可预测的问题。</p><p>此外，C++中还有一些预定义的宏，如<code>__FILE__</code>（当前源文件名）、<code>__LINE__</code>（当前行号）和<code>__cplusplus</code>（用于检查C++编译环境）等。这些预定义的宏在不同的编译器中可能有所差异，可以根据需要使用它们来获取一些编译时的信息。</p><p>总结起来，宏定义是C++中的预处理指令，用于在编译之前将标识符替换为指定的文本。它们可以用于定义常量、简单的代码替换和宏函数等。但需要注意宏定义的潜在问题，如缺乏类型检查和作用域限制。在实际使用中，应该慎重考虑宏</p><h1>友元</h1><p>在C++中，友元（friend）是一种机制，允许某个类或函数访问其他类的私有成员。友元关系可以用于增强类之间的协作和封装性。当一个类将另一个类声明为友元时，被声明的类就可以访问该类的私有成员。</p><p>友元关系有两种形式：类友元和函数友元。</p><ol><li>类友元：<br>类友元允许另一个类访问当前类的私有成员。在类定义中声明另一个类为友元时，友元类可以访问当前类的私有和保护成员。这种关系是双向的。</li></ol><p>下面是一个示例代码，演示了类友元的应用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 前置声明类B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">privateData</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;  <span class="comment">// 类B是类A的友元</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Private data in class A: &quot;</span> &lt;&lt; privateData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyPrivateData</span><span class="params">(A&amp; obj, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">        obj.privateData = data;  <span class="comment">// 可以访问类A的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，类A将类B声明为友元。类B的成员函数<code>modifyPrivateData()</code>可以访问类A的私有成员<code>privateData</code>。这允许类B修改类A的私有数据。</p><ol start="2"><li><p>函数友元：<br>函数友元允许一个独立的函数访问某个类的私有成员。函数友元不属于任何类，但可以访问被声明为友元的类的私有和保护成员。</p><p><strong>这个函数的声明需要在类中，并在声明前加上friend关键字，定义可以在类中或类外，因为友元函数不属于类的成员函数，所以在调用友元函数时不需要声明作用域</strong></p></li></ol><p>下面是一个示例代码，演示了函数友元的应用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">privateData</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">(A&amp; obj)</span></span>;  <span class="comment">// displayPrivateData函数是类A的友元</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayPrivateData</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Private data in class A: &quot;</span> &lt;&lt; obj.privateData &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，函数<code>displayPrivateData()</code>被声明为类A的友元。该函数可以直接访问类A的私有成员<code>privateData</code>。</p><p>友元关系的应用方式可以有多种，例如：</p><ul><li>可以将其他类声明为友元，以便它们可以访问私有成员，从而实现类之间的数据共享或协作。</li><li>可以声明一些独立函数作为友元，以便它们可以直接访问类的私有成员，提供额外的功能或实现特定的操作。</li></ul><p>请注意，友元关系会破坏封装性，因此应谨慎使用。只有在确实需要访问私有成员并且信任友元类或函数时，才应使用友元关系。</p><h1>枚举</h1><p>在C++中，枚举（enumeration）是一种用于定义命名常量集合的数据类型。枚举提供了一种方便的方式来表示一组相关的离散值，并可以增加代码的可读性和可维护性。</p><p>以下是使用枚举的基本语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumName</span> &#123;</span><br><span class="line">    Value1,</span><br><span class="line">    Value2,</span><br><span class="line">    Value3 = <span class="number">10</span>,</span><br><span class="line">    Value4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>EnumName</code> 是枚举类型的名称。<code>Value1</code>、<code>Value2</code>、<code>Value3</code> 和 <code>Value4</code> 是枚举常量，它们代表了枚举类型的不同取值。默认情况下，第一个枚举常量的值为 0，后续的枚举常量的值递增。但是，您也可以为枚举常量指定特定的值（如 <code>Value3 = 10</code>），后续的枚举常量将按照前一个常量的值递增。</p><p>枚举的常量可以在程序中直接使用，就像其他常量一样。以下是一个使用枚举的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Day today = Wednesday;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (today == Wednesday) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Today is Wednesday.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Today is not Wednesday.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个表示星期几的枚举类型 <code>Day</code>，然后使用枚举类型创建了一个变量 <code>today</code>，并将其赋值为 <code>Wednesday</code>。然后，我们可以使用条件语句来检查 <code>today</code> 是否等于 <code>Wednesday</code>，并输出相应的消息。</p><p>枚举可以与整数类型进行隐式转换，也可以通过强制类型转换将整数值转换为枚举类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Day day = <span class="built_in">static_cast</span>&lt;Day&gt;(<span class="number">2</span>);  <span class="comment">// 将整数值 2 转换为 Day 枚举类型</span></span><br></pre></td></tr></table></figure><p>枚举类型可以用作函数的参数类型或返回类型，以提供更具可读性的代码。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Day <span class="title">getNextDay</span><span class="params">(Day currentDay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Day&gt;((currentDay + <span class="number">1</span>) % <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数接受一个 <code>Day</code> 类型的参数 <code>currentDay</code>，并返回下一天的枚举值。</p><p>需要注意的是，枚举中的常量名称在同一作用域中是唯一的，不能重复定义相同名称的枚举常量。</p><p>通过使用枚举，您可以更清晰地表示一组相关的常量，并使代码更易于理解和维护。</p><h1>结构体</h1><p>在C++中，结构体（struct）是一种用户定义的数据类型，用于组合不同类型的数据成员。它类似于类（class），但有一些区别。下面是关于C++结构体的一些重要信息：</p><ol><li>定义结构体：结构体定义使用<code>struct</code>关键字，后面紧跟结构体的名称和一对花括号。在花括号中，您可以声明结构体的数据成员。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为<code>Person</code>的结构体，它有三个数据成员：<code>age</code>（整数类型），<code>name</code>（字符数组类型），和<code>height</code>（浮点数类型）。</p><ol start="2"><li>创建结构体变量：要使用结构体，您需要创建结构体的一个或多个实例（变量）。创建结构体变量时，可以使用结构体名称后跟变量名称，并用结构体的数据成员初始化它们。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person1;</span><br><span class="line">person1.age = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(person1.name, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">person1.height = <span class="number">175.5</span>;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个名为<code>person1</code>的<code>Person</code>结构体变量，并设置了其成员的值。</p><ol start="3"><li>访问结构体成员：可以使用点（<code>.</code>）运算符来访问结构体变量的成员。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person1.name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; person1.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; person1.height &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上述代码演示了如何访问<code>person1</code>结构体变量的成员并将其输出。</p><ol start="4"><li>结构体作为函数参数：结构体可以作为函数的参数传递。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonInfo</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; p.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数并传递结构体变量</span></span><br><span class="line"><span class="built_in">printPersonInfo</span>(person1);</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为<code>printPersonInfo</code>的函数，它接受一个<code>Person</code>结构体参数，并打印该结构体的成员信息。</p><p>这些是关于C++结构体的基本概念和用法。结构体允许您在一个数据类型中组合多个相关数据成员，以便更方便地操作和管理数据。</p><h1>共同体</h1><p>在C++中，共同体（union）是一种特殊的数据类型，允许在同一内存空间中存储不同类型的数据。与结构体不同，共同体的所有成员共享同一块内存。共同体的大小等于其最大成员的大小。</p><p>下面是有关C++共同体的一些重要信息：</p><ol><li>定义共同体：使用<code>union</code>关键字定义共同体，后跟共同体的名称和一对花括号。在花括号中，您可以声明共同体的成员。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> intValue;</span><br><span class="line">    <span class="type">float</span> floatValue;</span><br><span class="line">    <span class="type">char</span> stringValue[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为<code>Data</code>的共同体，它有三个成员：<code>intValue</code>（整数类型），<code>floatValue</code>（浮点数类型），和<code>stringValue</code>（字符数组类型）。</p><ol start="2"><li>使用共同体：可以创建共同体的实例，并对其成员进行赋值。共同体的所有成员将共享同一块内存。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Data data;</span><br><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line">data.floatValue = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br><span class="line"><span class="built_in">strcpy</span>(data.stringValue, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String value: &quot;</span> &lt;&lt; data.stringValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个名为<code>data</code>的<code>Data</code>共同体实例，并对其不同的成员赋值。注意，对一个成员的赋值将会影响其他成员的值，因为它们共享同一块内存。</p><ol start="3"><li>访问共同体成员：由于共同体的成员共享同一块内存，只能同时访问一个成员。可以使用点（<code>.</code>）运算符来访问共同体的成员。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">data.floatValue = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(data.stringValue, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;String value: &quot;</span> &lt;&lt; data.stringValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在上面的示例中，每次访问共同体的不同成员之前，先为该成员赋值，以确保正确访问和解释共同体的内容。</p><ol start="4"><li>共同体的应用：共同体常用于在不同类型之间进行类型转换或节省内存。通过为共同体的不同成员赋值，可以将数据以不同类型进行解释和操作。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Data data;</span><br><span class="line">data.intValue = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; data.intValue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">data.floatValue = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(data.intValue);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; data.floatValue &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在上述代码中，通过将整数值赋给共同体的<code>intValue</code>成员，然后将其强制转换为浮点数类型，可以在不改变内存中的值的情况下以不同类型解释该值。</p><p>这些是关于C++</p><p>共同体的基本概念和用法。共同体提供了一种在相同内存空间中存储不同类型数据的方法，但需要小心使用，确保正确解释和访问共同体的成员。</p><h1>[=]</h1><p>在C++中，<code>[=]</code>是一种lambda表达式的捕获列表（Capture List）形式，用于指定lambda表达式中的外部变量的访问方式。</p><p>Lambda表达式是C++11引入的一种匿名函数形式，它可以用于定义一个可调用的函数对象。Lambda表达式可以捕获局部变量，即在定义lambda表达式时，可以访问其所在作用域中的变量。</p><p>捕获列表<code>[=]</code>表示通过值捕获方式来访问外部变量。具体而言，使用<code>[=]</code>捕获列表会导致lambda表达式内部对外部变量进行值拷贝，以便在lambda表达式执行时使用。</p><p>以下是一个使用<code>[=]</code>捕获列表的lambda表达式示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [=]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x + y = &quot;</span> &lt;&lt; x + y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lambda</span>();  <span class="comment">// 输出结果：x + y = 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，lambda表达式使用了<code>[=]</code>捕获列表来捕获外部变量<code>x</code>和<code>y</code>。这意味着lambda表达式内部可以访问并使用这些变量的值。</p><p>当执行lambda表达式时，会输出变量<code>x</code>和<code>y</code>的和，即30。这是因为在lambda表达式定义时，通过值捕获方式将<code>x</code>和<code>y</code>的值拷贝到lambda对象中。</p><p>需要注意的是，通过值捕获方式捕获的外部变量是只读的，即无法在lambda表达式内部修改这些变量的值。如果希望能够修改外部变量，可以使用引用捕获方式（<code>[&amp;]</code>）来捕获外部变量。</p><h1>static_cast</h1><p><code>static_cast</code>是C++中的一种类型转换操作符，用于进行静态类型转换。它用于在编译时进行类型转换，编译器在进行类型转换时进行类型检查。<code>static_cast</code>可以用于以下几种转换：</p><ol><li>相关类型的转换：<code>static_cast</code>可用于相互关联的类型之间的转换，例如数字类型之间的转换（例如，整数到浮点数，浮点数到整数），以及指针和引用之间的转换。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intValue = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> doubleValue = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(intValue);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> intFromFloat = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(floatValue);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;number;</span><br><span class="line"><span class="type">void</span>* voidPtr = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(ptr);</span><br></pre></td></tr></table></figure><ol start="2"><li>基类和派生类之间的转换：<code>static_cast</code>可用于基类指针或引用与派生类指针或引用之间的转换。但是，这种转换只有在确保指针或引用指向的对象实际上是派生类对象时才是安全的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr);</span><br></pre></td></tr></table></figure><ol start="3"><li>隐式类型转换的显式化：<code>static_cast</code>可以将编译器隐式执行的类型转换显式化。这可以增加代码的可读性和明确性。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>static_cast</code>并不会执行运行时检查，因此在进行转换时要确保转换是安全的。如果存在不安全的转换，应该使用更严格的转换操作符（如<code>dynamic_cast</code>）来进行类型检查。</p><p>另外，<code>static_cast</code>也不能用于将底层const转换为非底层const，或者执行与底层const无关的其他转换。对于这些情况，可以使用<code>const_cast</code>和<code>reinterpret_cast</code>进行转换。</p><p>总结来说，<code>static_cast</code>是一种用于静态类型转换的操作符，适用于相关类型之间的转换、基类和派生类之间的转换，以及显式化隐式类型转换。在使用<code>static_cast</code>时，要确保转换是安全的并遵循C++的类型系统规则。</p><h1>goto</h1><p><code>goto</code>是C++中的一个关键字，用于实现无条件的跳转语句。它可以将程序的控制流直接跳转到指定的标签处。<code>goto</code>语句的使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label_name:</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到指定的标签处</span></span><br><span class="line"><span class="keyword">goto</span> label_name;</span><br></pre></td></tr></table></figure><p>下面是一些关于<code>goto</code>使用方法和注意事项的说明：</p><ol><li><code>goto</code>的使用方法：首先，在代码中定义一个标签（label），并在标签后面跟着一个冒号（:）。然后，通过使用<code>goto</code>关键字，将程序的控制流无条件地跳转到标签所在的位置。这种跳转可以在同一个函数内部、跨越多个代码块或函数之间进行。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> jump;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部分代码将被跳过</span></span><br><span class="line"></span><br><span class="line">    jump:</span><br><span class="line">    <span class="comment">// 跳转到这里继续执行</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>goto</code>的注意事项：</p><ul><li><p>避免滥用：<code>goto</code>语句的滥用会导致程序的逻辑变得混乱和难以理解。通常情况下，应该优先使用结构化的控制流语句（如<code>if</code>、<code>while</code>、<code>for</code>等）来实现代码逻辑。</p></li><li><p>防止跨过变量初始化：使用<code>goto</code>语句时要小心，以防止跳过局部变量的初始化过程。如果在跳转前需要对某个变量进行初始化，确保变量的初始化操作位于标签之前。</p></li><li><p>避免跨函数跳转：应避免在不同函数之间使用<code>goto</code>语句进行跳转，因为这会增加代码的复杂性和可读性，并可能导致代码难以维护。</p></li><li><p>保持代码清晰和可读性：使用<code>goto</code>语句时，应该注重代码的清晰性和可读性。给标签和跳转语句起具有描述性的名称，以便于他人理解代码的逻辑。</p></li><li><p>尽量避免使用：由于<code>goto</code>语句可能导致代码难以理解和维护，以及潜在的错误和混乱，建议尽量避免使用<code>goto</code>语句。大多数情况下，结构化的控制流语句可以更好地表达代码的逻辑。</p></li></ul></li></ol><p>需要注意的是，尽管<code>goto</code>语句在某些情况下可以提供方便，但它往往被认为是一种不良的编程实践，应该谨慎使用。在大多数情况下，更好的方法是使用结构化的控制流语句来组</p><p>织代码并保持代码的清晰性和可读性。</p><h1>auto</h1><p>在C++中，<code>auto</code>关键字用于自动推断变量的类型。通过使用<code>auto</code>关键字，编译器可以根据变量的初始化表达式来推断变量的类型，无需显式指定类型。</p><p><code>auto</code>关键字的使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variable = value;</span><br></pre></td></tr></table></figure><p>其中，<code>variable</code>是变量名，<code>value</code>是变量的初始化表达式。</p><p>以下是一些示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;  <span class="comment">// 推断x的类型为int，初始化为10</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>;  <span class="comment">// 推断y的类型为double，初始化为3.14</span></span><br><span class="line"><span class="keyword">auto</span> name = <span class="string">&quot;John&quot;</span>;  <span class="comment">// 推断name的类型为const char*，初始化为指向字符串常量的指针</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">7</span>);  <span class="comment">// 推断result的类型为函数add的返回类型，根据函数定义来推断</span></span><br></pre></td></tr></table></figure><p>通过使用<code>auto</code>关键字，可以简化变量声明的过程，特别是当变量的类型较为复杂或难以确定时。编译器会根据初始化表达式的类型推断出变量的类型，并自动进行类型检查。</p><p>需要注意的是，<code>auto</code>关键字在变量声明时使用，不能用于函数参数、函数返回类型、类的成员变量等场景。此外，由于类型是在编译时推断的，因此在某些情况下可能会导致代码可读性降低，特别是当初始化表达式较为复杂或类型不明显时。</p><p>在C++11之后，引入了更加强大的类型推断功能，例如<code>decltype</code>和<code>auto</code>结合使用，可以更灵活地推断出变量的类型。在C++14中，还引入了<code>decltype(auto)</code>来进行更精确的类型推断。这些功能在一些特定场景下可以提供更灵活和准确的类型推断。</p><h1>typeid</h1><p>在C++中，<code>typeid</code>是一个运算符，用于获取表达式的类型信息。它返回一个<code>type_info</code>对象，该对象包含有关表达式类型的信息。<code>typeid</code>可以用于以下几种情况：</p><ol><li>获取类型信息：使用<code>typeid</code>可以获取表达式的类型信息。它可以用于变量、对象、指针、引用以及类的实例等。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(num);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; objType = <span class="built_in">typeid</span>(obj);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; objType.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol start="2"><li>类型比较：可以使用<code>typeid</code>来比较两个表达式的类型是否相同。如果类型相同，比较结果为<code>true</code>；否则为<code>false</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(a) == <span class="built_in">typeid</span>(b)) &#123;</span><br><span class="line">    <span class="comment">// 类型相同</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>需要包含 <code>&lt;typeinfo&gt;</code> 头文件以使用 <code>typeid</code>。</li><li><code>type_info</code> 类型的对象在不同的编译单元中可能具有不同的地址，因此不能将其地址进行比较。</li><li><code>type_info</code> 对象的 <code>name()</code> 方法返回一个 <code>const char*</code> 指针，表示类型的名称。该名称的具体格式可能因编译器而异。</li><li>由于类型名称的具体格式是由编译器决定的，因此不应依赖于 <code>name()</code> 返回的字符串进行逻辑判断。</li></ul><p>需要注意的是，<code>typeid</code>主要用于运行时的类型信息，因此它在某些情况下可能会有一些限制。例如，对于多态类的基类指针或引用，<code>typeid</code>将返回指向实际对象的类型信息，而不是指向基类的类型信息。为了正确使用<code>typeid</code>，请确保在使用前已经了解了相关类型的特性和使用约束。</p><p>总的来说，<code>typeid</code>运算符可用于获取和比较表达式的类型信息，对于调试、类型检查和运行时多态等方面是非常有用的。</p><h1>type_info</h1><p><code>type_info</code> 是 C++ 标准库 <code>&lt;typeinfo&gt;</code> 中定义的类，它用于提供有关类型的运行时信息。<code>type_info</code> 类主要用于以下几个方面：</p><ol><li>获取类型信息：通过使用 <code>typeid</code> 运算符，可以获得表达式的 <code>type_info</code> 对象，从而获取有关类型的信息。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(num);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ol start="2"><li>类型比较：<code>type_info</code> 对象可以进行类型比较，以检查两个类型是否相同。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(a) == <span class="built_in">typeid</span>(b)) &#123;</span><br><span class="line">    <span class="comment">// 类型相同</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>获取类型名称：<code>type_info</code> 对象的 <code>name()</code> 方法返回一个 <code>const char*</code> 指针，表示类型的名称。请注意，返回的名称可能具有平台和编译器特定的格式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::type_info&amp; type = <span class="built_in">typeid</span>(<span class="type">int</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Type name: &quot;</span> &lt;&lt; type.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li><code>type_info</code> 类在头文件 <code>&lt;typeinfo&gt;</code> 中定义，因此需要包含该头文件才能使用它。</li><li><code>type_info</code> 对象的 <code>name()</code> 方法返回的类型名称不一定是人类可读的，因为它可能是编译器特定的标识符。</li><li><code>type_info</code> 的 <code>==</code> 操作符用于比较两个 <code>type_info</code> 对象是否代表相同的类型，而不是比较类型名称。</li></ul><p>由于 <code>type_info</code> 类提供的信息是在运行时获得的，因此它在某些情况下可能具有一些限制。例如，对于多态类的基类指针或引用，<code>type_info</code> 返回的类型信息将是指向实际对象的类型信息，而不是指向基类的类型信息。</p><p>总结来说，<code>type_info</code> 类提供了获取运行时类型信息的功能，并支持类型比较。它对于实现运行时类型检查、多态和其他需要类型信息的场景非常有用。然而，由于类型名称的具体格式是由编译器决定的，因此在使用 <code>type_info</code> 返回的名称时应谨慎对待。</p><h1>nullptr</h1><p><code>nullptr</code> 是 C++11 引入的关键字，用于表示空指针常量。它是用来明确表示一个指针不指向任何有效对象或函数的特殊值。在之前的 C++ 标准中，通常使用宏定义 <code>NULL</code> 或整数常量 <code>0</code> 来表示空指针。</p><p>使用 <code>nullptr</code> 的好处包括：</p><ol><li>清晰明确：<code>nullptr</code> 显式地表达了指针为空的含义，避免了与整数零的混淆。</li><li>类型安全：<code>nullptr</code> 是一个特殊的空指针类型，它不能隐式转换为其他类型，从而避免了类型错误。</li><li>减少重载歧义：当存在多个函数重载时，传递 <code>nullptr</code> 可以帮助编译器正确地选择函数重载版本。</li></ol><p>以下是一些使用 <code>nullptr</code> 的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);  <span class="comment">// 调用 foo(char*) 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 指针为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了两个重载的 <code>foo</code> 函数，一个接受 <code>char*</code> 类型的指针，另一个接受 <code>int*</code> 类型的指针。当我们传递 <code>nullptr</code> 给 <code>foo</code> 函数时，编译器会选择接受 <code>char*</code> 类型的版本。此外，我们还使用 <code>==</code> 运算符将指针 <code>ptr</code> 与 <code>nullptr</code> 进行比较，以检查指针是否为空。</p><p>总结而言，<code>nullptr</code> 是 C++11 引入的关键字，用于表示空指针常量。它提供了更明确的语义、类型安全和减少重载歧义的优点，使得代码更加清晰和健壮。在编写新的 C++ 代码时，推荐使用 <code>nullptr</code> 来表示空指针。</p><h1>简易学生管理系统模板</h1><p>下面是一个简易的学生管理系统的示例代码，它包括了学生类和一个管理系统类，可以添加学生、显示所有学生和查找学生等功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age, <span class="type">const</span> std::string&amp; id)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age), <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getID</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    std::string id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentManagementSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addStudent</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age, <span class="type">const</span> std::string&amp; id)</span> </span>&#123;</span><br><span class="line">        <span class="function">Student <span class="title">student</span><span class="params">(name, age, id)</span></span>;</span><br><span class="line">        students.<span class="built_in">push_back</span>(student);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Student added successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayAllStudents</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (students.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No students found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;All students:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; student : students) &#123;</span><br><span class="line">                student.<span class="built_in">displayInfo</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchStudent</span><span class="params">(<span class="type">const</span> std::string&amp; id)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; student : students) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.<span class="built_in">getID</span>() == id) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Student found:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                student.<span class="built_in">displayInfo</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Student not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Student&gt; students;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StudentManagementSystem system;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加学生</span></span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>, <span class="string">&quot;1001&quot;</span>);</span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">19</span>, <span class="string">&quot;1002&quot;</span>);</span><br><span class="line">    system.<span class="built_in">addStudent</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">21</span>, <span class="string">&quot;1003&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有学生</span></span><br><span class="line">    system.<span class="built_in">displayAllStudents</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找学生</span></span><br><span class="line">    system.<span class="built_in">searchStudent</span>(<span class="string">&quot;1002&quot;</span>);</span><br><span class="line">    system.<span class="built_in">searchStudent</span>(<span class="string">&quot;1004&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>Student</code> 类表示学生，具有姓名、年龄和学号等属性，并提供了获取和显示学生信息的成员函数。</p><p><code>StudentManagementSystem</code> 类表示学生管理系统，它包含一个学生列表（使用 <code>std::vector&lt;Student&gt;</code> 存储学生），提供了添加学生、显示所有学生和查找学生的成员函数。</p><p>在 <code>main()</code> 函数中，我们创建了一个 <code>StudentManagementSystem</code> 对象 <code>system</code>，并使用其成员函数来添加学生、显示所有学生和查找学生。输出结果为添加的学生信息、所有学生信息以及查找到的学生信息（如果存在）。</p><p>请注意，上述代码是一个简易的示例，没有包括错误处理和持久化存储等完整的功能。在实际开发中，可能需要更多的功能和更复杂的设计来满</p>]]></content>
    
    
    <summary type="html">🥧本文汇总C++的数据类型、类、结构体等基础知识</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://momoao.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://momoao.github.io/posts/202308241935.html"/>
    <id>https://momoao.github.io/posts/202308241935.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-25T12:33:31.527Z</updated>
    
    <content type="html"><![CDATA[<h1>Git</h1><h2 id="Git教程">Git教程</h2><h3 id="配置">配置</h3><p>查看所有配置</p><p>-l代表list</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config -l</span><br></pre></td></tr></table></figure><p>查看系统自带的配置</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$ git config</span> <span class="literal">--</span><span class="comment">system</span> <span class="literal">--</span><span class="comment">list</span></span><br></pre></td></tr></table></figure><p>查看全局配置的内容</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$ git config</span> <span class="literal">--</span><span class="comment">global</span> <span class="literal">--</span><span class="comment">list</span></span><br></pre></td></tr></table></figure><p>在C盘的用户/用户名下，有个.gitconfig文件，里面有用户添加的配置</p><p>文件清空以后，使用git config --global --list将看不见用户的配置</p><p><img src="../assets/image/Github_Image/image-20230819160412047.png" alt="image-20230819160412047"></p><p>在GitBash中配置用户数据</p><p><img src="../assets/image/Github_Image/image-20230819160734211.png" alt="image-20230819160734211"></p><h3 id="Git工作原理">Git工作原理</h3><p><img src="../assets/image/Github_Image/640.png" alt="图片"></p><p>初始化仓库</p><p>初始化之后GitData文件夹下会出现一个.git文件夹</p><p>这代表GitData就是一个新的代码库了</p><p><img src="../assets/image/Github_Image/image-20230819175906398.png" alt="image-20230819175906398"></p><p><img src="../assets/image/Github_Image/image-20230819175943115.png" alt="image-20230819175943115"></p><p><img src="../assets/image/Github_Image/image-20230819181112261.png" alt="image-20230819181112261"></p><h3 id="Git文件操作">Git文件操作</h3><h4 id="文件的四种状态">文件的四种状态</h4><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><p>添加新文件后，查看库的状态，发现都是Untracted（未跟踪）的状态</p><p><img src="../assets/image/Github_Image/image-20230819181917008.png" alt="image-20230819181917008"></p><p>需要使用git add将需要的文件添加到暂存区，这些文件到暂存区后就是跟踪状态了</p><p><img src="../assets/image/Github_Image/image-20230819182046827.png" alt="image-20230819182046827"></p><p>然后使用git commit提交所有暂存区的内容到本地库，可以附加上参数-m，后面附加上这次提交的描述信息</p><p><img src="../assets/image/Github_Image/image-20230819182111119.png" alt="image-20230819182111119"></p><h3 id="设置仓库">设置仓库</h3><p>在C:\Users\25463.ssh目录下</p><p>生成公钥和密钥，使用RSA加密算法生成公钥和密钥</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh-keygen -t rsa</span></span><br></pre></td></tr></table></figure><p>之后复制.pub文件中的内容，进入Gitee添加公钥</p><p><img src="../assets/image/Github_Image/image-20230820140730192.png" alt="image-20230820140730192"></p><h4 id="使用HTTPS链接">使用HTTPS链接</h4><p><strong>需要Gitee账号和密码</strong></p><p>创建仓库，复制仓库的HTTPS地址，</p><p>使用指令添加远程仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add <span class="tag">&lt;<span class="name">短名</span>&gt;</span> <span class="tag">&lt;<span class="name">远程仓库URL</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结一下远程仓库的几个操作命令:</p><ul><li>git remote add: 添加远程仓库</li><li>git remote rm: 删除远程仓库</li><li>git remote set-url: 修改远程仓库URL</li><li>git remote -v: 查看远程仓库地址</li></ul><p>查看远程仓库的配置<br><img src="../assets/image/Github_Image/image-20230820142752821.png" alt="image-20230820142752821"></p><p>要设置 fetch 和 push 使用不同的 URL,可以这样操作:</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 fetch 地址</span></span><br><span class="line"><span class="string">git</span> <span class="string">remote</span> <span class="built_in">set-url</span> <span class="built_in">--push</span> <span class="string">origin</span> <span class="string">https</span>://<span class="string">github</span>.<span class="string">com</span>/<span class="string">user</span>/<span class="string">repo</span>.<span class="string">git</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 push 地址</span></span><br><span class="line"><span class="string">git</span> <span class="string">remote</span> <span class="built_in">set-url</span> <span class="built_in">--push</span> <span class="string">origin</span> <span class="string">https</span>://<span class="string">github</span>.<span class="string">com</span>/<span class="string">user</span>/<span class="string">repo_push</span>.<span class="string">git</span></span><br></pre></td></tr></table></figure><p>之后commit之后的内容就可以使用git push进行提交</p><p>第一次提交会要求输入用户名（不是昵称）和密码，输入之后就可以提交到远程仓库了</p><h4 id="使用SSH链接">使用SSH链接</h4><p>上面在Gitee中添加了我们放在C:\Users\25463\.ssh目录下的公钥，我们在仓库中复制SSH链接git@gitee.com:Chentianao/gitstudy.git</p><p>之后添加远程仓库</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="language-bash"> gitstudy git@gitee.com:Chentianao/gitstudy.git</span></span><br></pre></td></tr></table></figure><p>如果设置了passphrase，每次push都需要输入</p><h2 id="Git分支">Git分支</h2><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge [branch]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h2 id="git-tag">git tag</h2><p>在 Git 中，每个提交都有一个唯一的哈希值作为标识，这个哈希值是根据提交内容和元数据计算出来的，因此不能直接手动指定。不过，你可以通过标签（Tags）来为特定的提交添加一个有意义的标识，类似于版本号。标签可以用来标记重要的里程碑、发布版本等。</p><p>以下是如何在提交时创建一个标签：</p><ol><li><p><strong>创建轻量标签（Lightweight Tag）：</strong><br>轻量标签只是一个指向特定提交的引用，它不包含额外的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tag_name&gt; &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0 abc123</span><br></pre></td></tr></table></figure><p>这将创建一个名为 <code>v1.0.0</code> 的轻量标签，指向哈希值为 <code>abc123</code> 的提交。</p></li><li><p><strong>创建附注标签（Annotated Tag）：</strong><br>附注标签是一个包含额外信息的标签，比如标签的创建者、创建时间、标签消息等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tag_name&gt; -m <span class="string">&quot;&lt;tag_message&gt;&quot;</span> &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0.0 -m <span class="string">&quot;Release version 1.0.0&quot;</span> abc123</span><br></pre></td></tr></table></figure><p>这将创建一个名为 <code>v1.0.0</code> 的附注标签，包含了标签消息和指向哈希值为 <code>abc123</code> 的提交。</p></li><li><p><strong>推送标签到远程仓库：</strong><br>创建标签后，默认情况下它们只会存在于本地仓库。如果想将标签推送到远程仓库，需要使用 <code>git push</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0.0</span><br></pre></td></tr></table></figure><p>这将把名为 <code>v1.0.0</code> 的标签推送到远程仓库。</p></li></ol><p>标签可以让你更好地标识和跟踪特定的提交，用于版本发布或其他重要的里程碑。要注意的是，标签是指向特定提交的指针，它们并不会像提交一样随着新的更改而移动。</p><h2 id="git-diff">git diff</h2><p><code>git diff</code> 是一个用于比较 Git 仓库中不同代码版本之间差异的命令。它可以帮助你查看文件、提交或分支之间的变化，以便更好地理解代码的演变和修改。</p><p>以下是关于 <code>git diff</code> 命令的详细讲解：</p><ol><li><p><strong>比较工作区和暂存区之间的差异：</strong></p><p>如果你在工作区对文件进行了修改，但尚未添加到暂存区，可以使用以下命令查看工作区和暂存区之间的差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>这将显示尚未暂存的更改，让你了解工作区和暂存区之间的不同。</p></li><li><p><strong>比较暂存区和最新提交之间的差异：</strong></p><p>如果你已经将文件添加到暂存区，并想要查看暂存区和最新提交之间的差异，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p>或者使用简写形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><p>这将显示已暂存但尚未提交的更改。</p></li><li><p><strong>比较两个提交之间的差异：</strong></p><p>如果你想要比较两个不同的提交之间的差异，可以运行以下命令，其中 <code>&lt;commit1&gt;</code> 和 <code>&lt;commit2&gt;</code> 是提交的哈希值或引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt;</span><br></pre></td></tr></table></figure><p>这将显示两个提交之间的代码变化。</p></li><li><p><strong>比较不同分支之间的差异：</strong></p><p>要比较两个不同分支之间的差异，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;branch1&gt; &lt;branch2&gt;</span><br></pre></td></tr></table></figure><p>这将显示两个分支之间的差异，包括文件的增删和修改。</p></li><li><p><strong>其他选项：</strong></p><ul><li><p><code>git diff --stat</code>：显示简要的统计信息，例如哪些文件被修改、添加或删除了。</p></li><li><p><code>git diff --color-words</code>：以单词为单位显示差异，使用颜色标识。</p></li><li><p><code>git diff --name-only</code>：仅显示有差异的文件名，而不显示具体的差异内容。</p></li><li><p><code>git diff --check</code>：检查是否有空白错误，例如行尾空格等。</p></li></ul></li></ol><p>总之，<code>git diff</code> 命令是一个强大的工具，可以帮助你查看不同版本之间的代码差异。根据需要，你可以使用不同的选项来查看详细的代码更改、统计信息或其他类型的差异。</p><h2 id="Git中的回退操作">Git中的回退操作</h2><p>要回退到之前的提交版本，你可以使用 <code>git reset</code> 命令。下面是回退的步骤：</p><ol><li><p><strong>找到要回退的提交的哈希值：</strong> 首先，使用 <code>git log</code> 命令找到你想要回退到的提交的哈希值。复制该哈希值，它将用于后续的操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li><li><p><strong>执行回退操作：</strong> 使用 <code>git reset</code> 命令回退到指定的提交。有不同的重置模式，这里介绍两种常用的模式：</p><ul><li><p><strong>软重置 (<code>--soft</code>)：</strong> 这会将 HEAD 指针移动到指定提交，但保留之后的更改在暂存区。这样，你可以重新提交这些更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>混合重置 (<code>--mixed</code>)：</strong> 这是默认的重置模式。它会将 HEAD 指针和暂存区都移动到指定提交，这意味着暂存区中的更改会被取消。但你的工作目录中的文件不会受到影响，你可以选择重新添加需要的更改并提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>硬重置 (<code>--hard</code>)：</strong> 这是最彻底的重置模式。它会将 HEAD 指针、暂存区和工作目录都移动到指定提交，所有未提交的更改都会被丢弃，慎用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>注意安全性：</strong> 请注意，重置操作是不可逆的，会丢失未提交的更改。在执行重置之前，务必确认你了解操作的影响，最好在操作前备份你的重要数据。</p></li></ol><p>总之，通过使用 <code>git reset</code> 命令，你可以回退到之前的提交版本。选择适当的重置模式取决于你希望如何处理暂存区和工作目录中的更改。</p><h3 id="三种重置的区别">三种重置的区别</h3><p>软重置、混合重置和硬重置是 Git 中用于移动 HEAD 指针以及调整暂存区和工作目录状态的重置操作。它们的主要区别在于它们如何处理提交和更改。下面我会详细解释每种重置的区别：</p><ol><li><p><strong>软重置 (<code>--soft</code>)：</strong></p><p>在软重置中，HEAD 指针会被移动到指定的提交，但暂存区和工作目录不会受到影响。这意味着之后你可以重新提交之前提交的更改，或者在原来的基础上继续工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure><ul><li>暂存区：不受影响，保留原来的暂存内容。</li><li>工作目录：不受影响，保留原来的更改。</li><li>HEAD 指针：移动到指定提交。</li></ul></li><li><p><strong>混合重置 (<code>--mixed</code>，默认模式)：</strong></p><p>在混合重置中，HEAD 指针会被移动到指定的提交，同时暂存区会被重置为指定提交的内容，但工作目录不会受影响。这意味着之前的更改将被取消，但工作目录中的文件仍然保留，你可以重新将需要的更改添加到暂存区并提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure><ul><li>暂存区：重置为指定提交的内容。</li><li>工作目录：不受影响，保留原来的更改。</li><li>HEAD 指针：移动到指定提交。</li></ul></li><li><p><strong>硬重置 (<code>--hard</code>)：</strong></p><p>在硬重置中，HEAD 指针、暂存区和工作目录都会被移动到指定的提交，所有未提交的更改都会被丢弃。这是一种非常彻底的操作，会将你的仓库状态恢复到指定提交的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit_hash&gt;</span><br></pre></td></tr></table></figure><ul><li>暂存区：重置为指定提交的内容。</li><li>工作目录：重置为指定提交的内容。</li><li>HEAD 指针：移动到指定提交。</li></ul></li></ol><p>总之，不同的重置模式适用于不同的情况。软重置适用于你想要保留更改并在之前的提交基础上继续工作的情况。混合重置适用于你想要取消暂存的更改，但仍然保留在工作目录中的情况。硬重置用于完全取消提交和更改，返回到指定提交的状态。在使用任何重置模式之前，请确保你了解其影响，并在必要时备份重要的数据。</p>]]></content>
    
    
    <summary type="html">🥧本文汇总Git的使用方法</summary>
    
    
    
    <category term="工具" scheme="https://momoao.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Git" scheme="https://momoao.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="https://momoao.github.io/posts/202308241940.html"/>
    <id>https://momoao.github.io/posts/202308241940.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-25T12:42:54.738Z</updated>
    
    <content type="html"><![CDATA[<h1>Hexo</h1><p>安装node.js</p><p>之后再命令行安装cnpm</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --<span class="keyword">register</span>=https:<span class="comment">//register.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>检测环境是否配置成功</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>安装hexo</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p>检测hexo安装情况</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo -v</span></span><br></pre></td></tr></table></figure><p>创建一个博客文件夹</p><p>在文件夹中初始化hexo</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">init</span></span><br></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure><p>想要连接远程仓库，配置_config.yml</p><p>在文件最后添加</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repo: https:<span class="regexp">//gi</span>thub.com<span class="regexp">/MoMoAo/</span>MoMoAo.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>注意这里的仓库地址必须是&quot;<a href="http://xn--eqr924avxo.github.io">用户名.github.io</a>&quot;</p><p>创建新的博客,指定博客的主题</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="built_in">n</span> <span class="string">&quot;我的第一篇博客&quot;</span></span><br></pre></td></tr></table></figure><p>创建完后会在source/_posts/下生成对应的.md文件</p><p>清理缓存</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br></pre></td></tr></table></figure><p>根据md文件生成对应的文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure><p>在本目录装一个用于部署到git的插件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure><p>推送到远程库</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧本文汇总Hexo博客框架的安装和使用方法</summary>
    
    
    
    <category term="框架" scheme="https://momoao.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Hexo" scheme="https://momoao.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>CentOS</title>
    <link href="https://momoao.github.io/posts/202308241933.html"/>
    <id>https://momoao.github.io/posts/202308241933.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-30T02:05:24.637Z</updated>
    
    <content type="html"><![CDATA[<h1>CentOS</h1><h1>系统的安装</h1><h2 id="Minimal版本的配置">Minimal版本的配置</h2><p>磁盘分区会有感叹号提醒，点进去后点击左上角的Done退出即可</p><p>安装中设置root密码外不用设置别的</p><p>配置网络文件</p><p>将最后的ONBOOT改为yes</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-ens33 </span><br></pre></td></tr></table></figure><p>之后重启网络服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl restart network</span></span><br></pre></td></tr></table></figure><p>使用指令就可以查询到ens33网卡的地址了</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ip addr</span></span><br></pre></td></tr></table></figure><p>如果ping不通，可以查看虚拟机的网卡配置是否有问题，或者本机的网络适配器是否开启</p><p>如果怕改错了，可以提前备份</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/etc/yum</span>.repos.d<span class="regexp">/CentOS-Base.repo /</span>etc<span class="regexp">/yum.repos.d/</span>CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure><h3 id="更改下载的镜像">更改下载的镜像</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/yum</span>.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>更改[base]下的mirrorlist，改为阿里的镜像源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base - mirrors.aliyun.com</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">        http:<span class="regexp">//mi</span>rrors.aliyuncs.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">        http:<span class="regexp">//mi</span>rrors.cloud.aliyuncs.com<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/centos/</span>RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br></pre></td></tr></table></figure><p>更多阿里镜像查看</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//mi</span>rrors.aliyun.com/</span><br></pre></td></tr></table></figure><p>保存退出，执行指令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yum makecache</span></span><br></pre></td></tr></table></figure><p>之后就可以流程下载插件了</p><h3 id="CentOS-Base-repo中不同的仓库">CentOS-Base.repo中不同的仓库</h3><p>在 CentOS 系统中，镜像源配置通常包括几个不同的仓库，如 base、updates、extras 和 centosplus。每个仓库都提供了不同类型的软件包，以满足系统更新、安装软件等需求。</p><ol><li><p><strong>Base</strong>：<br><code>base</code> 仓库包含了 CentOS 系统的核心组件和基本软件包，这些软件包是系统正常运行所必需的。它包含了操作系统的核心部分，以及一些基本的实用工具。在安装 CentOS 时，<code>base</code> 仓库中的软件包会默认被安装。</p></li><li><p><strong>Updates</strong>：<br><code>updates</code> 仓库包含了操作系统的安全补丁、错误修复以及一些更新的软件包。通过更新仓库，您可以保持系统的安全性和稳定性，获取最新的修复和改进。</p></li><li><p><strong>Extras</strong>：<br><code>extras</code> 仓库包含一些与操作系统直接相关的额外软件包，但不是系统的核心部分。这些软件包通常提供了一些实用的工具、驱动程序、附加的库等，以满足特定的需求。</p></li><li><p><strong>CentOSPlus</strong>：<br><code>centosplus</code> 仓库是一个额外的仓库，它提供了一些额外的软件包，包括一些新功能、改进和测试软件。这些软件包可能在某些情况下很有用，但不是必需的。<code>centosplus</code> 仓库可能包含一些新版本的软件，以及一些社区贡献的软件。</p></li></ol><p>通常情况下，<code>base</code>、<code>updates</code> 和 <code>extras</code> 是大多数用户所需的核心仓库，可以满足大部分的系统更新和安装软件的需求。<code>centosplus</code> 则更适合一些特定需求，比如测试新功能或使用社区贡献的软件。</p><p>在配置镜像源时，确保您的系统可以访问这些不同的仓库，以获取所需的软件包和更新。</p><h3 id="常用工具列表">常用工具列表</h3><p>“CentOS Minimal” 版本是 CentOS 发行版的一个精简版本，它通常只包含最基本的软件包，以减小系统的大小和潜在的攻击面。因此，在安装 CentOS Minimal 版本后，您可能需要手动安装一些常用的工具，以满足系统管理和日常操作的需求。以下是一些常用工具的示例：</p><ol><li><p><strong>网络工具</strong>：</p><ul><li><code>wget</code>：用于从网络下载文件。</li><li><code>curl</code>：用于发送 HTTP 请求并获取响应，支持多种协议。</li></ul></li><li><p><strong>文本编辑器</strong>：</p><ul><li><code>vim</code> 或 <code>nano</code>：常用的命令行文本编辑器。</li></ul></li><li><p><strong>包管理工具</strong>：</p><ul><li><code>yum</code>：虽然 CentOS Minimal 版本已经预装了 YUM，但您可能需要确保其更新并配置好软件源，以便后续安装软件包。</li></ul></li><li><p><strong>系统工具</strong>：</p><ul><li><code>ssh</code>：用于远程登录和管理服务器。</li><li><code>htop</code> 或 <code>top</code>：用于查看系统资源使用情况和进程信息。</li><li><code>iftop</code>：用于监控网络流量。</li><li><code>iostat</code>：用于监控磁盘 I/O 性能。</li></ul></li><li><p><strong>文件管理工具</strong>：</p><ul><li><code>ls</code>、<code>cp</code>、<code>mv</code>、<code>rm</code> 等：基本的文件和目录操作命令。</li><li><code>tree</code>：以树状结构显示目录内容。</li></ul></li><li><p><strong>用户和权限管理</strong>：</p><ul><li><code>useradd</code>、<code>usermod</code>、<code>passwd</code>：用于管理用户账户和密码。</li><li><code>sudo</code>：用于授权普通用户执行特定命令的权限。</li></ul></li><li><p><strong>安全工具</strong>：</p><ul><li><code>firewalld</code>：用于管理防火墙规则。</li><li><code>fail2ban</code>：用于防范暴力破解等攻击。</li></ul></li><li><p><strong>时间和日期工具</strong>：</p><ul><li><code>date</code>：用于查看和设置系统时间和日期。</li><li><code>timedatectl</code>：用于系统时间和日期的管理。</li></ul></li><li><p><strong>日志查看工具</strong>：</p><ul><li><code>journalctl</code>：用于查看系统日志。</li></ul></li></ol><p>这只是一个基本的示例列表，您可以根据您的具体需求和用途来决定需要安装哪些工具。记得在安装新工具之前，使用 <code>yum</code> 确保您的系统已经更新并且软件源已经配置好。</p><h1>基础操作</h1><h2 id="用户和组的操作">用户和组的操作</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>1、创建组的目录</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>2、创建组</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>3、将组放到对应目录下</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>4、创建用户，放在对应的组下</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>5、更改组所在目录的权限</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>6、使用  ls  -l  查看包含所有组所在目录的内容，可以看见权限是否设置成功</span><br></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@CTA2102</span> ~]<span class="meta"># cd /</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> /]<span class="meta"># cd home</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> home]<span class="meta"># mkdir DemoCompany</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> home]<span class="meta"># cd DemoCompany/</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> DemoCompany]<span class="meta"># mkdir PublicResource</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> DemoCompany]<span class="meta"># mkdir market</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> DemoCompany]<span class="meta"># mkdir manage</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> DemoCompany]<span class="meta"># mkdir training</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> DemoCompany]<span class="meta"># groupadd -g 3000 D_PublicResource</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> DemoCompany]<span class="meta"># chown :D_PublicResource /home/DemoCompany/PublicResource/</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> home]<span class="meta"># chmod -R 777 /home/DemoCompany/PublicResource/</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> home]<span class="meta"># useradd -g D_PublicResource -d /home/DemoCompany/PublicResource/p1 p1</span></span><br><span class="line">   [root<span class="symbol">@CTA2102</span> home]<span class="meta"># ls -l DemoCompany/</span></span><br><span class="line">   总用量 <span class="number">0</span></span><br><span class="line">   drwxr-x---. <span class="number">2</span> root D_Manage          <span class="number">6</span> <span class="number">4</span>月   <span class="number">6</span> <span class="number">10</span>:<span class="number">05</span> DemoManage</span><br><span class="line">   drwxr-x---. <span class="number">2</span> root D_Market          <span class="number">6</span> <span class="number">4</span>月   <span class="number">6</span> <span class="number">10</span>:<span class="number">05</span> DemoMarket</span><br><span class="line">   drwxr-x---. <span class="number">2</span> root D_Training        <span class="number">6</span> <span class="number">4</span>月   <span class="number">6</span> <span class="number">10</span>:<span class="number">05</span> DemoTraining</span><br><span class="line">   drwxrwxrwx. <span class="number">3</span> root D_PublicResource <span class="number">16</span> <span class="number">4</span>月   <span class="number">6</span> <span class="number">10</span>:<span class="number">14</span> PublicResource</span><br></pre></td></tr></table></figure><h3 id="批量添加用户">批量添加用户</h3><h4 id="简易方法">简易方法</h4><p><img src="../assets/image/CentOS_Image/image-20230828103723768.png" alt="image-20230828103723768"></p><ul><li><p>切换用户出现-bash-4.1$</p><ul><li><p>因为用户家目录中的配置文件不足</p></li><li><p>使用cp  -a  /etc/skel/.  /home/net2103</p><ul><li>.是为了把隐藏文件也都复制过去</li></ul></li></ul></li></ul><h2 id="查看目录操作">查看目录操作</h2><p>查看目录的操作通常是通过终端（命令行）来完成的。在 Linux 系统中，有许多命令可用于查看目录内容、文件列表和文件属性。以下是一些常用的命令：</p><ol><li><p><strong>列出目录内容</strong>：使用 <code>ls</code> 命令来列出指定目录中的文件和子目录。</p><ul><li><p>列出当前目录内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li><p>列出指定目录内容（例如 <code>/path/to/directory</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /path/to/directory</span><br></pre></td></tr></table></figure></li><li><p>列出详细信息，包括权限、所有者、大小等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure></li><li><p>列出所有，包括隐藏文件（以<code>.</code>开头的文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure></li><li><p>列出详细信息并包括隐藏文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -la</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查看文件和目录属性</strong>：使用 <code>stat</code> 命令来查看文件或目录的详细属性。</p><ul><li><p>查看文件或目录属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> filename_or_directory</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查找文件和目录</strong>：使用 <code>find</code> 命令来查找文件和目录，可以根据不同的条件进行搜索。</p><ul><li><p>在当前目录及其子目录中查找特定文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;filename&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>在指定路径下查找所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure></li><li><p>在指定路径下查找所有目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -<span class="built_in">type</span> d</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查看当前工作目录</strong>：使用 <code>pwd</code> 命令查看当前所在的工作目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></li><li><p><strong>切换工作目录</strong>：使用 <code>cd</code> 命令切换当前工作目录到指定路径。</p><ul><li><p>进入指定目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/directory</span><br></pre></td></tr></table></figure></li><li><p>返回上级目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure></li><li><p>返回用户主目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure></li><li><p>返回之前的工作目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>这些命令可以帮助您在终端中查看和操作目录内容。根据您的需求，您可以根据不同的选项和参数来调整这些命令的行为。要了解更多详细信息，请查阅相关命令的手册页（使用 <code>man</code> 命令，例如 <code>man ls</code>、<code>man find</code>）。</p><h2 id="rpm">rpm</h2><p><code>rpm</code>（Red Hat Package Manager）是用于在基于 RPM（Red Hat Package Manager）软件包管理系统的 Linux 发行版中管理软件包的命令行工具。它允许用户安装、卸载、查询、验证和管理软件包。以下是一些常用的 <code>rpm</code> 命令及其用法：</p><ol><li><p><strong>安装软件包</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i package.rpm</span><br></pre></td></tr></table></figure><p>例如，要安装名为 <code>package.rpm</code> 的软件包，可以使用上述命令。</p><p><strong>注意：</strong> <code>rpm</code> 安装过程中可能会提示依赖关系问题，您需要手动解决这些问题或者考虑使用 <code>yum</code> 或 <code>dnf</code> 来处理依赖关系。</p></li><li><p><strong>卸载软件包</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e package_name</span><br></pre></td></tr></table></figure><p>使用上述命令来卸载指定的软件包。</p></li><li><p><strong>查询已安装的软件包</strong>：</p><ul><li><p>列出所有已安装的软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa</span><br></pre></td></tr></table></figure></li><li><p>查询特定软件包是否已安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q package_name</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>显示软件包信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi package_name</span><br></pre></td></tr></table></figure><p>使用上述命令来显示有关特定软件包的详细信息，如版本、作者、描述等。</p></li><li><p><strong>显示软件包文件列表</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql package_name</span><br></pre></td></tr></table></figure><p>使用上述命令来显示特定软件包安装后的文件列表。</p></li><li><p><strong>验证软件包完整性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -V package_name</span><br></pre></td></tr></table></figure><p>使用上述命令来验证特定软件包的文件是否被修改。</p></li><li><p><strong>寻找拥有特定文件的软件包</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf /path/to/file</span><br></pre></td></tr></table></figure><p>使用上述命令来找出拥有指定文件的软件包。</p></li><li><p><strong>安装已下载的软件包及其依赖</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh package.rpm</span><br></pre></td></tr></table></figure><p>使用上述命令来安装软件包并自动解决依赖关系。</p></li><li><p><strong>从软件包中提取文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm2cpio package.rpm | cpio -idmv</span><br></pre></td></tr></table></figure><p>使用上述命令可以从软件包中提取文件。这在某些情况下可能很有用。</p></li></ol><p>这些是一些常见的 <code>rpm</code> 命令及其用法。请注意，使用 <code>rpm</code> 命令需要小心，尤其是在解决依赖关系时。在大多数情况下，推荐使用更高级的软件包管理工具，如 <code>yum</code>（适用于 CentOS 6 及更早版本）或 <code>dnf</code>（适用于CentOS 7及以后版本），以便更好地处理软件包之间的依赖性。</p><h3 id="下载镜像更改">下载镜像更改</h3><p>要更改 RPM 软件包的下载镜像，你需要编辑相应的配置文件。在大多数基于 Red Hat 的 Linux 发行版中，RPM 使用 <code>yum</code> 或 <code>dnf</code> 作为前端工具，这些工具会使用配置文件来指定软件包下载的镜像源。下面是一些常见的步骤来更改 RPM 下载镜像：</p><ol><li><p>打开终端并以管理员权限登录，或者使用 <code>sudo</code> 权限执行以下步骤。</p></li><li><p><strong>备份原有配置文件（可选）</strong>：<br>在修改配置文件之前，最好先备份原有的配置文件，以防意外问题。</p></li><li><p><strong>编辑镜像源配置文件</strong>：<br>打开 <code>/etc/yum.repos.d</code> 目录，这个目录中包含了系统中已配置的不同软件源的 <code>.repo</code> 配置文件。你可以选择编辑现有的 <code>.repo</code> 文件，或者创建一个新的文件。</p><p>例如，如果你想编辑 CentOS 的官方镜像源，你可以编辑 <code>CentOS-Base.repo</code> 文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi <span class="regexp">/etc/yum</span>.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure></li><li><p><strong>修改镜像源地址</strong>：<br>在 <code>.repo</code> 文件中，你会看到类似以下的配置段落：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line">baseurl=http:<span class="regexp">//mi</span>rror.centos.org<span class="regexp">/centos/</span><span class="variable">$releasever</span><span class="regexp">/os/</span><span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=file:<span class="regexp">//</span><span class="regexp">/etc/</span>pki<span class="regexp">/rpm-gpg/</span>RPM-GPG-KEY-CentOS-<span class="number">7</span></span><br></pre></td></tr></table></figure><p>修改 <code>baseurl</code> 行中的地址，将其指向你想要的镜像源。可以在 CentOS 官网或其他可靠的源网站上找到可用的镜像源地址。如果你在国内，也可以选择使用国内的镜像源地址。</p></li><li><p><strong>保存并退出编辑器</strong>：<br>在 vi 编辑器中，你可以按下 <code>Esc</code> 键，然后输入 <code>:wq</code> 并按下回车，保存文件并退出编辑器。</p></li><li><p><strong>清除缓存并更新软件包列表</strong>：<br>运行以下命令来清除缓存并获取更新的软件包列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf clean <span class="keyword">all</span>   # 或者使用 yum clean <span class="keyword">all</span>（根据发行版选择）</span><br><span class="line">sudo dnf <span class="keyword">update</span>      # 或者使用 yum <span class="keyword">update</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用新镜像源下载软件包</strong>：<br>之后，你可以使用 <code>dnf</code>（或 <code>yum</code>）命令来安装、更新、卸载软件包，它们会使用你所配置的新镜像源地址。</p></li></ol><p>请注意，根据你使用的 Linux 发行版以及发行版的版本，配置文件的位置、格式和细节可能会有所不同。务必在修改配置文件之前做好备份，并确保使用可靠的镜像源地址。</p><h4 id="国内常用镜像">国内常用镜像</h4><p>在中国，由于国际网络访问受到限制，许多开发者和用户选择使用国内的软件镜像来加速软件包的下载和更新。以下是一些常用的中国境内的软件镜像：</p><ol><li><p><strong>清华大学开源软件镜像站</strong>：</p><ul><li>镜像地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></li><li>清华大学镜像站是中国最大的开源软件镜像站之一，提供了各种常见的开源软件的镜像，包括 Linux 发行版、开发工具等。</li></ul></li><li><p><strong>阿里云开源镜像站</strong>：</p><ul><li>镜像地址：<a href="https://mirrors.aliyun.com/">https://mirrors.aliyun.com/</a></li><li>阿里云提供了广泛的开源软件的镜像，速度一般较快，也包含了许多国际软件源。</li></ul></li><li><p><strong>华为开源镜像站</strong>：</p><ul><li>镜像地址：<a href="https://mirrors.huaweicloud.com/">https://mirrors.huaweicloud.com/</a></li><li>华为云提供了开源软件的镜像，速度也相对较快，同时也支持一些云服务。</li></ul></li><li><p><strong>中科大开源镜像站</strong>：</p><ul><li>镜像地址：<a href="https://mirrors.ustc.edu.cn/">https://mirrors.ustc.edu.cn/</a></li><li>中国科学技术大学镜像站提供了各种开源软件的镜像，适合科技教育界的需求。</li></ul></li><li><p><strong>网易开源镜像站</strong>：</p><ul><li>镜像地址：<a href="http://mirrors.163.com/">http://mirrors.163.com/</a></li><li>网易提供了开源软件的镜像，覆盖范围较广。</li></ul></li></ol><p>这些镜像站都提供了各种开源软件的下载镜像，你可以根据自己的需求选择其中一个或多个来加速软件包的下载和更新。在使用这些镜像站之前，最好先查看它们的使用规则和说明，以确保正确使用。</p><h2 id="yum">yum</h2><p><code>yum</code> 是在基于 Red Hat 的 Linux 发行版上用于管理软件包的命令行工具。它可以用于安装、升级、查询和卸载软件包，同时还可以管理软件包的依赖关系。以下是一些常见的 <code>yum</code> 命令及其说明：</p><ol><li><p><strong>更新软件包列表</strong>：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo yum update</span></span><br></pre></td></tr></table></figure><p>此命令将检查可用的软件包更新，并根据配置文件中的设置进行更新。</p></li><li><p><strong>安装软件包</strong>：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install &lt;<span class="keyword">package</span>-name&gt;</span><br></pre></td></tr></table></figure><p>通过此命令安装指定的软件包及其依赖项。</p></li><li><p><strong>升级软件包</strong>：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo yum upgrade</span></span><br></pre></td></tr></table></figure><p>使用此命令升级系统上已安装的所有软件包，包括依赖关系。</p></li><li><p><strong>查询软件包信息</strong>：</p><ul><li>查询软件包是否已安装：<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum list installed &lt;<span class="keyword">package</span>-name&gt;</span><br></pre></td></tr></table></figure></li><li>显示软件包详细信息：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> yum <span class="literal">info</span> &lt;package-name&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>搜索软件包</strong>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="built_in">search</span> <span class="symbol">&lt;keyword&gt;</span></span><br></pre></td></tr></table></figure><p>此命令将搜索包含指定关键字的软件包。</p></li><li><p><strong>卸载软件包</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="built_in">remove</span> &lt;<span class="built_in">package</span>-name&gt;</span><br></pre></td></tr></table></figure><p>通过此命令卸载已安装的软件包。注意，这只会删除软件包本身，不会删除其依赖项。</p></li><li><p><strong>清理缓存</strong>：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum clean <span class="keyword">all</span></span><br></pre></td></tr></table></figure><p>此命令将清除 YUM 缓存，删除已下载的软件包文件。</p></li><li><p><strong>列出已安装软件包</strong>：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo yum list installed</span></span><br></pre></td></tr></table></figure><p>此命令将列出所有已安装的软件包。</p></li><li><p><strong>显示软件包提供的文件</strong>：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum provides &lt;<span class="keyword">file</span>-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure><p>此命令将显示提供指定文件的软件包。</p></li><li><p><strong>启用/禁用软件源</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-<span class="built_in">config</span>-manager <span class="comment">--enable &lt;repository&gt;</span></span><br><span class="line">sudo yum-<span class="built_in">config</span>-manager <span class="comment">--disable &lt;repository&gt;</span></span><br></pre></td></tr></table></figure><p>使用这些命令可以启用或禁用特定的软件源。</p></li></ol><p>这些是 <code>yum</code> 命令的一些基本示例。请注意，实际使用中可能需要根据你的需求和情况进行适当的调整。你可以在终端上输入 <code>yum --help</code> 或 <code>man yum</code> 来查看完整的帮助文档，了解更多详细信息和选项。</p><h2 id="vim">vim</h2><p>Vim（Vi IMproved）是一种强大的文本编辑器，常用于终端环境下编辑文本文件。Vim 提供了许多命令和功能，使其成为程序员和系统管理员的首选工具之一。以下是一些常用的 Vim 指令及其用法：</p><p><strong>注意：在 Vim 中，许多指令都需要在不同的模式下使用。Vim 有普通模式、插入模式和命令行模式。请确保您在正确的模式下使用相应的指令。</strong></p><ol><li><p><strong>打开文件</strong>：</p><p>打开文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim filename</span></span><br></pre></td></tr></table></figure><p>打开多个文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim</span> file1 file2</span><br></pre></td></tr></table></figure></li><li><p><strong>保存和退出</strong>：</p><ul><li><p>保存文件并退出：</p><p>在普通模式下，按下 <code>:</code> 进入命令行模式，然后输入 <code>wq</code> 并按回车键。</p></li><li><p>保存文件但不退出：</p><p>在普通模式下，按下 <code>:</code> 进入命令行模式，然后输入 <code>w</code> 并按回车键。</p></li><li><p>不保存文件并退出：</p><p>在普通模式下，按下 <code>:</code> 进入命令行模式，然后输入 <code>q!</code> 并按回车键。</p></li></ul></li><li><p><strong>插入文本</strong>：</p><ul><li><p>进入插入模式：</p><p>在普通模式下，按下 <code>i</code> 进入插入模式。在光标前插入文本。</p></li><li><p>在行首插入：</p><p>在普通模式下，按下 <code>I</code> 进入插入模式，在行首插入文本。</p></li><li><p>在行尾插入：</p><p>在普通模式下，按下 <code>A</code> 进入插入模式，在行尾插入文本。</p></li><li><p>在下一行插入：</p><p>在普通模式下，按下 <code>o</code> 进入插入模式，在当前行的下一行插入新行。</p></li><li><p>在上一行插入：</p><p>在普通模式下，按下 <code>O</code> 进入插入模式，在当前行的上一行插入新行。</p></li></ul></li><li><p><strong>普通模式操作</strong>：</p><ul><li><p>删除当前字符：</p><p>在普通模式下，按下 <code>x</code> 删除光标所在位置的字符。</p></li><li><p>删除整行：</p><p>在普通模式下，按下 <code>dd</code> 删除光标所在行。</p></li><li><p>复制当前行：</p><p>在普通模式下，按下 <code>yy</code> 复制光标所在行。</p></li><li><p>粘贴复制的内容：</p><p>在普通模式下，按下 <code>p</code> 将复制的内容粘贴到光标后。</p></li><li><p>撤销上一步操作：</p><p>在普通模式下，按下 <code>u</code> 进行撤销。</p></li></ul></li><li><p><strong>移动光标</strong>：</p><ul><li><p>向左移动一个字符：</p><p>在普通模式下，按下 <code>h</code>。</p></li><li><p>向右移动一个字符：</p><p>在普通模式下，按下 <code>l</code>。</p></li><li><p>向上移动一行：</p><p>在普通模式下，按下 <code>k</code>。</p></li><li><p>向下移动一行：</p><p>在普通模式下，按下 <code>j</code>。</p></li><li><p>移动到行首：</p><p>在普通模式下，按下 <code>0</code>。</p></li><li><p>移动到行尾：</p><p>在普通模式下，按下 <code>$</code>。</p></li></ul></li><li><p><strong>搜索和替换</strong>：</p><ul><li><p>搜索关键词：</p><p>在普通模式下，按下 <code>/</code>，然后输入要搜索的关键词并按回车。</p></li><li><p>向前搜索下一个匹配：</p><p>在普通模式下，按下 <code>n</code>。</p></li><li><p>向后搜索上一个匹配：</p><p>在普通模式下，按下 <code>N</code>。</p></li><li><p>替换字符串：</p><p>在普通模式下，按下 <code>:</code> 进入命令行模式，然后输入 <code>s/old/new/g</code>，将每个匹配的 “old” 替换为 “new”。</p></li></ul></li></ol><p>这只是 Vim 功能的冰山一角。Vim 具有许多高级功能，例如宏录制、分割窗口、插件支持等。如果您想深入学习 Vim，建议查阅相关的教程和文档。在 Vim 中，您可以随时按下 <code>Esc</code> 键返回普通模式，并在该模式下输入 <code>:help</code> 来查阅 Vim 的内置帮助。</p><h2 id="who">who</h2><p><code>who</code> 是一个用于显示当前登录到系统的用户信息的命令。当您在终端中运行 <code>who</code> 命令时，它将显示登录到系统的用户列表以及一些相关的信息。以下是关于 <code>who</code> 命令的详细信息：</p><ol><li><p><strong>基本用法</strong>：</p><p>运行以下命令来显示当前登录用户的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span></span><br></pre></td></tr></table></figure><p>或者您可以使用 <code>who -u</code> 命令以详细模式显示用户信息，包括登录终端、登录时间、用户 ID 等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -u</span><br></pre></td></tr></table></figure></li><li><p><strong>输出格式</strong>：</p><p><code>who</code> 命令的输出通常包括以下信息：</p><ul><li>登录用户名</li><li>登录终端</li><li>登录时间</li><li>登录 IP 地址（如果适用）</li></ul><p>示例输出可能如下所示：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">username terminal_name login_time ip_address</span></span><br></pre></td></tr></table></figure></li><li><p><strong>选项和参数</strong>：</p><ul><li><p><code>-q</code>：仅显示登录用户数量，不显示详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -q</span><br></pre></td></tr></table></figure></li><li><p><code>-H</code>：以表格格式显示用户信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -H</span><br></pre></td></tr></table></figure></li><li><p><code>-b</code>：显示系统启动时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -b</span><br></pre></td></tr></table></figure></li><li><p><code>-r</code>：显示系统运行时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -r</span><br></pre></td></tr></table></figure></li><li><p><code>-T</code>：显示最后一次输入事件（activity）的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -T</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>示例</strong>：</p><ul><li><p>显示登录用户列表和终端信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span></span><br></pre></td></tr></table></figure></li><li><p>显示登录用户数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -q</span><br></pre></td></tr></table></figure></li><li><p>以表格格式显示用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -H</span><br></pre></td></tr></table></figure></li><li><p>显示系统启动时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -b</span><br></pre></td></tr></table></figure></li><li><p>显示系统运行时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -r</span><br></pre></td></tr></table></figure></li><li><p>显示最后一次输入事件的时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> -T</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><code>who</code> 命令通常用于查看当前登录的用户信息，以及系统的运行和活动状态。要了解更多关于 <code>who</code> 命令的详细信息，请查看命令的手册页（使用 <code>man</code> 命令，例如 <code>man who</code>）。</p><h2 id="mount">mount</h2><p><code>mount</code> 是一个用于挂载文件系统的命令，在 Linux 系统中非常常用。通过 <code>mount</code> 命令，您可以将存储设备（如硬盘、分区、USB 设备）上的文件系统连接到指定的挂载点，使得文件系统中的内容在挂载点下可访问。以下是关于 <code>mount</code> 命令的详细使用说明：</p><p><strong>基本语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount <span class="selector-attr">[-t 文件系统类型]</span> <span class="selector-attr">[-o 选项]</span> 设备文件 挂载点</span><br></pre></td></tr></table></figure><p><strong>常用选项：</strong></p><ul><li><code>-t 文件系统类型</code>：指定要挂载的文件系统的类型，如 ext4、ntfs、vfat 等。如果未指定，则系统会尝试自动检测。</li><li><code>-o 选项</code>：指定挂载选项，如读写权限、权限设置等。</li></ul><p><strong>常见用法示例：</strong></p><ol><li><p><strong>挂载设备</strong>：<br>要挂载一个设备，您需要知道设备的名称和挂载点。例如，将 <code>/dev/sdb1</code> 设备（第二个硬盘的第一个分区）挂载到 <code>/mnt/usb</code> 挂载点：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount <span class="regexp">/dev/</span>sdb1 <span class="regexp">/mnt/u</span>sb</span><br></pre></td></tr></table></figure></li><li><p><strong>指定文件系统类型和挂载选项</strong>：<br>如果您需要指定文件系统类型和挂载选项，可以使用 <code>-t</code> 和 <code>-o</code> 选项。例如，挂载一个 NTFS 分区并设置为只读：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t ntfs -o ro <span class="regexp">/dev/</span>sdb2 <span class="regexp">/mnt/</span>ntfs</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载 CD/DVD</strong>：<br>挂载光盘设备（如 CD/DVD）通常与 ISO 文件一起使用。将 <code>/dev/cdrom</code> 设备挂载到 <code>/mnt/cdrom</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount <span class="regexp">/dev/</span>cdrom <span class="regexp">/mnt/</span>cdrom</span><br></pre></td></tr></table></figure></li><li><p><strong>卸载文件系统</strong>：<br>使用 <code>umount</code> 命令来卸载文件系统。例如，卸载之前挂载的 <code>/mnt/usb</code> 设备：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount <span class="regexp">/mnt/u</span>sb</span><br></pre></td></tr></table></figure></li><li><p><strong>显示已挂载的文件系统</strong>：<br>使用 <code>mount</code> 命令而不带参数，可以显示当前已挂载的文件系统列表：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mount</span></span><br></pre></td></tr></table></figure></li><li><p><strong>永久挂载</strong>：<br>若要实现开机时自动挂载设备，需要将挂载信息添加到 <code>/etc/fstab</code> 文件中。这样，系统会在启动时自动执行挂载操作。请务必小心修改此文件，以免出现问题。</p></li></ol><p>请注意，挂载文件系统需要超级用户权限，因此在使用 <code>mount</code> 命令时需要使用 <code>sudo</code> 或者以超级用户身份登录。</p><p><code>mount</code> 命令是 Linux 系统中管理文件系统挂载的重要工具。在进行文件操作和存储管理时，它是必不可少的命令之一。</p><h2 id="df">df</h2><p><code>df</code>（Disk Free）是一个在 Linux 和 Unix 操作系统中用于显示文件系统磁盘空间使用情况的命令。它可以告诉您有关已挂载文件系统的磁盘使用、可用空间、已使用空间等信息。以下是关于 <code>df</code> 命令的详细使用说明：</p><p><strong>基本语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df <span class="selector-attr">[选项]</span> <span class="selector-attr">[文件或目录]</span></span><br></pre></td></tr></table></figure><p><strong>常见选项：</strong></p><ul><li><code>-h</code>：以人类可读的方式显示磁盘空间，使用 KB、MB、GB 等单位。</li><li><code>-T</code>：显示文件系统类型。</li><li><code>-i</code>：显示inode（索引节点）的使用情况。</li><li><code>-a</code>：显示所有文件系统，包括虚拟文件系统（如 <code>/proc</code>、<code>/sys</code>）。</li><li><code>-x</code> 文件系统类型：排除指定类型的文件系统。</li></ul><p><strong>常见用法示例：</strong></p><ol><li><p><strong>显示所有已挂载文件系统的磁盘使用情况</strong>：<br>输入以下命令，可以查看所有已挂载文件系统的磁盘使用情况，以 KB、MB、GB 为单位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure></li><li><p><strong>显示指定目录的磁盘使用情况</strong>：<br>如果您只关心某个特定目录的磁盘使用情况，可以在命令后面指定目录的路径。例如，查看 <code>/home</code> 目录的磁盘使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h /home</span><br></pre></td></tr></table></figure></li><li><p><strong>显示文件系统类型</strong>：<br>使用 <code>-T</code> 选项可以同时显示文件系统类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -Th</span><br></pre></td></tr></table></figure></li><li><p><strong>显示inode 使用情况</strong>：<br>使用 <code>-i</code> 选项可以查看文件系统的inode 使用情况，这对于一些特殊情况很有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -i</span><br></pre></td></tr></table></figure></li><li><p><strong>排除指定文件系统类型</strong>：<br>使用 <code>-x</code> 选项可以排除特定类型的文件系统。例如，要排除虚拟文件系统，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -hx tmpfs</span><br></pre></td></tr></table></figure></li></ol><p><code>df</code> 命令是一个用于查看文件系统磁盘空间使用情况的实用工具。它可以帮助您了解系统中文件系统的容量和可用空间，从而更好地进行存储管理和监控。在使用时，您可以根据自己的需求选择不同的选项和参数。</p><h2 id="lsblk">lsblk</h2><p>sr0是系统镜像的占用空间，不占用磁盘空间</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0   <span class="number"> 0 </span>  20G <span class="number"> 0 </span>disk </span><br><span class="line">├─sda1            8:1   <span class="number"> 0 </span>   1G <span class="number"> 0 </span>part /boot</span><br><span class="line">└─sda2            8:2   <span class="number"> 0 </span>  19G <span class="number"> 0 </span>part </span><br><span class="line">  ├─centos-root 253:0   <span class="number"> 0 </span>  17G <span class="number"> 0 </span>lvm  /</span><br><span class="line">  └─centos-swap 253:1   <span class="number"> 0 </span>   2G <span class="number"> 0 </span>lvm  [SWAP]</span><br><span class="line">sr0              11:0   <span class="number"> 1 </span>1024M <span class="number"> 0 </span>rom  </span><br></pre></td></tr></table></figure><p><code>lsblk</code> 是一个在 CentOS（以及其他基于 Linux 的操作系统）中用于列出块设备信息的命令。块设备通常是硬盘、固态硬盘（SSD）、USB 设备等，它们以块（数据块）为单位进行数据的读写。以下是关于 <code>lsblk</code> 命令的详细使用说明：</p><ol><li><p><strong>基本用法</strong>：<br>在终端中输入以下命令来运行 <code>lsblk</code>，它将列出系统中所有的块设备及其相关信息。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsblk</span></span><br></pre></td></tr></table></figure></li><li><p><strong>列出块设备信息</strong>：<br><code>lsblk</code> 列出的信息包括每个块设备的名称、大小、类型、挂载点（如果已挂载）、分区信息等。</p></li><li><p><strong>显示分区信息</strong>：<br>默认情况下，<code>lsblk</code> 只显示设备级别的信息，如果您想要查看每个设备的分区信息，可以使用 <code>-p</code> 或 <code>--part</code> 选项。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure></li><li><p><strong>树状视图</strong>：<br>使用 <code>-t</code> 或 <code>--tree</code> 选项，可以以树状视图的形式显示块设备和分区的层次结构。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsblk -t</span></span><br></pre></td></tr></table></figure></li><li><p><strong>只显示特定设备类型</strong>：<br>使用 <code>-d</code> 或 <code>--nodeps</code> 选项，可以只显示块设备而不包括分区。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsblk -d</span></span><br></pre></td></tr></table></figure></li><li><p><strong>以 JSON 格式输出</strong>：<br>使用 <code>-J</code> 或 <code>--json</code> 选项，可以将块设备信息以 JSON 格式输出，便于后续处理。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsblk -J</span></span><br></pre></td></tr></table></figure></li><li><p><strong>只显示特定列</strong>：<br>使用 <code>-o</code> 或 <code>--output</code> 选项，可以指定要显示的列。例如，要只显示设备名称和挂载点，可以使用以下命令：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -o <span class="keyword">NAME</span>,MOUNTPOINT</span><br></pre></td></tr></table></figure></li><li><p><strong>显示虚拟设备</strong>：<br>有些设备可能是虚拟设备，如 LVM 逻辑卷、RAID 设备等。使用 <code>-i</code> 或 <code>--inverse</code> 选项，可以显示虚拟设备而隐藏物理设备。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -<span class="selector-tag">i</span></span><br></pre></td></tr></table></figure></li><li><p><strong>显示设备大小单位</strong>：<br>默认情况下，设备大小以字节显示。使用 <code>-b</code>、<code>-k</code>、<code>-m</code> 或 <code>-h</code> 选项，可以选择以不同单位（字节、KB、MB、GB、TB 等）显示大小。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsblk -h</span></span><br></pre></td></tr></table></figure></li><li><p><strong>显示更多帮助信息</strong>：<br>如果您想了解更多选项和用法，可以查看 <code>lsblk</code> 的帮助文档。</p></li></ol>   <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">man lsblk</span></span><br></pre></td></tr></table></figure><p><code>lsblk</code> 命令是一个非常有用的工具，可以帮助您快速了解系统中的块设备和分区信息，从而更好地进行存储管理和系统维护。</p><h1>指令图表</h1><h2 id="进程管理">进程管理</h2><p>以下是一些常见的进程管理命令和它们的功能，以表格形式列出：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>ps</code></td><td>显示当前正在运行的进程列表</td></tr><tr><td><code>top</code></td><td>实时显示系统中的进程和系统资源使用情况</td></tr><tr><td><code>htop</code></td><td>交互式的进程查看器，显示系统资源使用情况和进程信息</td></tr><tr><td><code>pgrep</code></td><td>根据进程名称查找匹配的进程 ID</td></tr><tr><td><code>kill</code></td><td>终止指定进程</td></tr><tr><td><code>killall</code></td><td>终止所有匹配进程</td></tr><tr><td><code>pkill</code></td><td>根据进程名称终止匹配的进程</td></tr><tr><td><code>nohup</code></td><td>启动一个命令，使其在后台运行并忽略挂断信号（SIGHUP）</td></tr><tr><td><code>jobs</code></td><td>显示当前会话的作业列表</td></tr><tr><td><code>bg</code></td><td>将一个作业放到后台运行</td></tr><tr><td><code>fg</code></td><td>将一个作业放到前台运行</td></tr><tr><td><code>nice</code></td><td>在运行命令时设置较低的优先级</td></tr><tr><td><code>renice</code></td><td>更改正在运行进程的优先级</td></tr><tr><td><code>systemctl</code></td><td>系统服务管理工具，用于启动、停止、重启和管理系统服务</td></tr><tr><td><code>service</code></td><td>启动、停止、重启和管理系统服务（在 CentOS 7 之前的版本中使用）</td></tr></tbody></table><p>这些命令可以帮助你管理和控制 CentOS 中的进程。请注意，某些命令可能需要使用超级用户权限（通过 <code>sudo</code> 前缀）来执行特定操作。你可以在终端中使用命令的帮助选项（如 <code>man &lt;command&gt;</code>）来获取更多关于每个命令的详细信息和用法示例。</p><h2 id="文件管理">文件管理</h2><p>以下是一些常见的文件管理命令以及它们的功能，整理成表格形式：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出目录中的文件和子目录</td></tr><tr><td><code>pwd</code></td><td>显示当前工作目录的路径</td></tr><tr><td><code>cd</code></td><td>切换当前工作目录</td></tr><tr><td><code>mkdir</code></td><td>创建一个新的目录</td></tr><tr><td><code>rm</code></td><td>删除文件或目录</td></tr><tr><td><code>cp</code></td><td>复制文件或目录</td></tr><tr><td><code>mv</code></td><td>移动或重命名文件或目录</td></tr><tr><td><code>touch</code></td><td>创建新文件或更新文件的访问和修改时间戳</td></tr><tr><td><code>cat</code></td><td>查看文件内容</td></tr><tr><td><code>less</code></td><td>分页查看文件内容</td></tr><tr><td><code>head</code></td><td>显示文件的开头几行</td></tr><tr><td><code>tail</code></td><td>显示文件的末尾几行</td></tr><tr><td><code>grep</code></td><td>在文件中搜索指定的字符串</td></tr><tr><td><code>find</code></td><td>根据条件搜索文件或目录</td></tr><tr><td><code>chmod</code></td><td>修改文件或目录的权限</td></tr><tr><td><code>chown</code></td><td>更改文件或目录的所有者</td></tr><tr><td><code>chgrp</code></td><td>更改文件或目录的所属组</td></tr><tr><td><code>ln</code></td><td>创建文件或目录的硬链接或符号链接</td></tr><tr><td><code>stat</code></td><td>显示文件的详细信息，如大小、权限和修改时间等</td></tr><tr><td><code>du</code></td><td>估算文件或目录的磁盘使用量</td></tr><tr><td><code>df</code></td><td>显示文件系统的磁盘使用情况</td></tr><tr><td><code>tar</code></td><td>创建、查看或提取 tar 压缩文件</td></tr><tr><td><code>zip</code></td><td>创建、解压或列出 zip 压缩文件</td></tr><tr><td><code>unzip</code></td><td>解压 zip 压缩文件</td></tr></tbody></table><p>这些是一些常用的文件管理命令。使用这些命令，你可以浏览目录、创建、复制、移动和删除文件，以及修改文件的权限和属性等。每个命令都有一些选项和参数，可根据需要进行进一步的自定义和配置。你可以在终端中使用命令的帮助选项（如 <code>man &lt;command&gt;</code>）来查阅详细的命令用法和示例。</p><h1>服务搭建</h1><h2 id="安装MySQL8-0">安装MySQL8.0</h2><p>先更新密钥</p><p>密钥更新的主要目的是确保软件包在传输过程中没有被篡改或植入恶意代码。这是非常重要的，因为恶意软件可能会伪装成合法软件并被安装在你的系统上，从而危害系统的安全和稳定性。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --<span class="keyword">import</span> https:<span class="comment">//repo.mysql.com/RPM-GPG-KEY-mysql-2022</span></span><br></pre></td></tr></table></figure><p>安装mysql8.x版本  yum库</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">CTA2102</span> ~]<span class="meta"># rpm -Uvh https:<span class="comment">//dev.mysql.com/get/mysql80-community-release-el7-2.noarch.rpm</span></span></span><br></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取https:<span class="comment">//dev.mysql.com/get/mysql80-community-release-el7-2.noarch.rpm</span></span><br><span class="line">警告：/var/tmp/rpm-tmp<span class="number">.9</span>ZxUTu: 头V3 DSA/SHA1 Signature, 密钥 ID <span class="number">5072e1</span>f5: NOKEY</span><br><span class="line">准备中...                          ################################# [<span class="number">100</span>%]</span><br><span class="line">正在升级/安装...</span><br><span class="line">   <span class="number">1</span>:mysql80-community-release-el7<span class="number">-2</span>  ################################# [<span class="number">100</span>%]</span><br></pre></td></tr></table></figure><p>使用yum安装mysql</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mysql-community-<span class="keyword">server</span></span><br></pre></td></tr></table></figure><p>打开mysql服务</p><p>设置自启动</p><p>查看状态</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@CTA2102</span> ~]<span class="meta"># systemctl start mysqld</span></span><br><span class="line">[root<span class="symbol">@CTA2102</span> ~]<span class="meta"># systemctl enable mysqld</span></span><br><span class="line">[root<span class="symbol">@CTA2102</span> ~]<span class="meta"># systemctl status mysqld</span></span><br></pre></td></tr></table></figure><p>查看root用户的初始密码</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /<span class="keyword">var</span>/<span class="built_in">log</span>/mysqld.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>使用初试密码登录mysql的root用户</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><p>修改密码</p><p>密码需要包含大、小写和字符</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果觉得密码复杂可以降低安全检测等级</p><p>将密码最短字符调整为4</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global validate_password.<span class="attribute">policy</span>=0;</span><br><span class="line"><span class="built_in">set</span> global validate_password.<span class="attribute">length</span>=4;</span><br></pre></td></tr></table></figure><p>开启root远程登录权限</p><p>注意：这里密码可以和localhost的不一样</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line">更改密码</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看3306端口，是否有mysql在运行</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@CTA2102</span> ~]<span class="comment"># netstat -anp | grep 3306</span></span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ::<span class="symbol">:</span><span class="number">3306</span>                 ::<span class="symbol">:*</span>                    <span class="title class_">LISTEN</span>      <span class="number">6285</span>/mysqld         </span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ::<span class="symbol">:</span><span class="number">33060</span>                ::<span class="symbol">:*</span>                    <span class="title class_">LISTEN</span>      <span class="number">6285</span>/mysqld    </span><br></pre></td></tr></table></figure><h2 id="安装Tomcat">安装Tomcat</h2><h3 id="安装JDK">安装JDK</h3><p>在下面会有最常用的版本，选择下载</p><p><a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p><p><img src="image/CentOS_Image/image-20230716094359495.png" alt="image-20230716094359495"></p><p>通过windterm中的上传当前文件夹，上传.tar.gz文件到linux的root目录中</p><p><img src="image/CentOS_Image/image-20230716094442030.png" alt="image-20230716094442030"></p><p>创建一个目录</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /<span class="keyword">export</span>/server</span><br></pre></td></tr></table></figure><p>使用tar指令解压文件到刚才创建的目录中</p><p><code>tar</code> 是一个在 Unix 和类 Unix 操作系统中广泛使用的命令行工具，用于创建和管理归档文件，通常称为 “tarball”。它允许将多个文件和目录组合成单个归档文件，并且可以使用不同的压缩算法进行压缩。</p><ul><li><code>-z</code>: 使用 gzip 算法解压缩归档文件。通常，压缩后的归档文件的扩展名为 <code>.tar.gz</code> 或 <code>.tgz</code>，表示使用 gzip 压缩的 tar 归档文件。</li><li><code>-x</code>: 解压缩归档文件。它会从归档文件中提取出文件和目录。</li><li><code>-v</code>: 显示解压缩过程中的详细信息（verbose）。将输出每个被解压缩的文件名。</li><li><code>-f</code> 选项用于指定归档文件的名称，它必须紧随其后，并且归档文件名应该位于该选项之后。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-<span class="number">8</span>u371-linux-x64.tar.gz -C <span class="regexp">/export/</span>server</span><br></pre></td></tr></table></figure><p>创建软链接</p><p>软链接类似windows中的快捷方式，访问 /export/server/jdk的时候可以跳转到/export/server/jdk1.8.0_371</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="regexp">/export/</span>server<span class="regexp">/jdk1.8.0_371 /</span>export<span class="regexp">/server/</span>jdk</span><br></pre></td></tr></table></figure><p><img src="image/CentOS_Image/image-20230716095618436.png" alt="image-20230716095618436"></p><p>编写环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc<span class="built_in">/profile</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line">文件最后添加两行</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">JAVA_HOME</span>=/export/server/jdk</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>加载配置文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><p>查看路径是否加入成功</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@CTA2102 bin]<span class="comment"># echo $PATH</span></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/sbin:/u</span>sr<span class="regexp">/local/</span>bin:<span class="regexp">/usr/</span>sbin:<span class="regexp">/usr/</span>bin:<span class="regexp">/root/</span>.local<span class="regexp">/bin:/</span>root<span class="regexp">/bin:/</span>export<span class="regexp">/server/</span>jdk/bin</span><br></pre></td></tr></table></figure><p>运行java -version发现，版本和自己装的不一样</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@CTA2102 <span class="keyword">bin]# </span><span class="keyword">java </span>-version</span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_242&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (<span class="keyword">build </span><span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>_242-<span class="keyword">b08)</span></span><br><span class="line"><span class="keyword"></span>OpenJDK <span class="number">64</span>-<span class="keyword">Bit </span>Server VM (<span class="keyword">build </span><span class="number">25</span>.<span class="number">242</span>-<span class="keyword">b08, </span>mixed mode)</span><br></pre></td></tr></table></figure><p>使用which查看java命令本体</p><p>发现并不是自己装的</p><p>因为在echo $PATH时，/usr/bin路径在自己添加的路径前面，所以先使用了/usr/bin路径下的java</p><p>解决方法两个：</p><ul><li>将自己的java路径放在前面</li><li>用自己的java替代系统自带的</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@CTA2102 bin]<span class="comment"># which java</span></span><br><span class="line"><span class="regexp">/usr/</span>bin/java</span><br></pre></td></tr></table></figure><p>方法一：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -f <span class="regexp">/usr/</span>bin/java</span><br><span class="line">软链接</span><br><span class="line">ln -s <span class="regexp">/export/</span>bin<span class="regexp">/jdk/</span>bin<span class="regexp">/java /u</span>sr<span class="regexp">/bin/</span>java</span><br></pre></td></tr></table></figure><h3 id="安装Tomcat-2">安装Tomcat</h3><p>注意：将以下tomcat版本都换成apache-tomcat-9.0.78.tar.gz。因为java8和tomcat10不兼容</p><p>安装tomcat时要用非root用户，因为如果tomcat被黑了，还是用root用户创建tomcat的话，那么整个机器都被黑了</p><p>可以用linux下载压缩包，也可以在Windows中下载后传输</p><p>这里使用–no-check-certificate，是不检测网络安全证书，如果不添加会有以下提示</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wget</span> --no-check-certificate https://dlcdn.apache.org/tomcat/tomcat-<span class="number">10</span>/v10.<span class="number">1</span>.<span class="number">10</span>/bin/apache-tomcat-<span class="number">10</span>.<span class="number">1</span>.<span class="number">10</span>.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">--2023-07-16</span> 14<span class="function">:54</span><span class="function">:51--</span>  https:<span class="string">//dlcdn.apache.org/tomcat/tomcat-10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz</span></span><br><span class="line">正在解析主机 dlcdn.apache.org <span class="params">(dlcdn.apache.org)</span><span class="string">...</span> 2a04<span class="function">:4e42</span>:<span class="function">:644</span>, 151.101.2.132</span><br><span class="line">正在连接 dlcdn.apache.org <span class="params">(dlcdn.apache.org)</span>|2a04<span class="function">:4e42</span>:<span class="function">:644</span>|<span class="function">:443...</span> 已连接。</span><br><span class="line">错误: 无法验证 dlcdn.apache.org 的由 “<span class="string">/C=US/O=Let</span>&#x27;s Encrypt/CN=R3” 颁发的证书:</span><br><span class="line">  颁发的证书已经过期。</span><br><span class="line">要以不安全的方式连接至 dlcdn.apache.org，使用“<span class="params">--no-check-certificate</span>”。</span><br></pre></td></tr></table></figure><p>将放在python的家目录下的tgz文件解压到/export/server下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -zxvf apache-tomcat-<span class="number">10</span>.<span class="number">1</span>.<span class="number">10</span>.tar.gz -C /export/server/</span><br></pre></td></tr></table></figure><p>软链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="regexp">/export/</span>server<span class="regexp">/apache-tomcat-10.1.10/</span> <span class="regexp">/export/</span>server/tomcat</span><br></pre></td></tr></table></figure><p>启动tomcat</p><p>在目录/export/server/tomcat/bin下</p><p>启动startup.sh文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[python@CTA2102 bin]$ startup.sh</span><br><span class="line">bash: startup.sh: 未找到命令...</span><br><span class="line">[python@CTA2102 bin]$ ./startup.sh </span><br><span class="line">Using CATALINA_BASE:   <span class="regexp">/export/</span>server/tomcat</span><br><span class="line">Using CATALINA_HOME:   <span class="regexp">/export/</span>server/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: <span class="regexp">/export/</span>server<span class="regexp">/tomcat/</span>temp</span><br><span class="line">Using JRE_HOME:        <span class="regexp">/export/</span>server/jdk</span><br><span class="line">Using <span class="keyword">CLASSPATH</span>:       <span class="regexp">/export/</span>server<span class="regexp">/tomcat/</span>bin<span class="regexp">/bootstrap.jar:/</span>export<span class="regexp">/server/</span>tomcat<span class="regexp">/bin/</span>tomcat-juli.jar</span><br><span class="line">Using CATALINA_OPTS:   </span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure><p>如果启动成功，但是检测端口依据看不见tomcat，可能因为java环境和tomcat版本不匹配</p><p>防火墙问题</p><p>这将允许TCP流量通过 8080 端口，并且 <code>--permanent</code> 选项会将该规则保存到永久规则集中，以便在系统重启后仍然生效。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">--</span><span class="comment">add</span><span class="literal">-</span><span class="comment">port=8080/tcp</span> <span class="literal">--</span><span class="comment">permanent</span></span><br></pre></td></tr></table></figure><p>重新加载防火墙</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd <span class="comment">--reload</span></span><br></pre></td></tr></table></figure><h2 id="安装Nginx">安装Nginx</h2><p>安装yum的拓展工具</p><p><code>yum-utils</code> 是一个在 CentOS 和 Red Hat Enterprise Linux (RHEL) 等系统上非常有用的软件包，提供了一系列方便的 YUM 包管理工具。<code>yum-utils</code> 包含了许多实用程序，可帮助您管理软件包、查找问题、清理缓存、调试等操作。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> -y yum-utils</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下面是 yum-utils 包含的一些常用工具：</span><br><span class="line"></span><br><span class="line"><span class="built_in">package</span>-cleanup：清理旧版本的软件包和无用的依赖关系。</span><br><span class="line"><span class="built_in">package</span>-cleanup <span class="comment">--dupes：查找并删除系统中的重复软件包。</span></span><br><span class="line"><span class="built_in">package</span>-cleanup <span class="comment">--cleandupes：删除系统中的重复软件包。</span></span><br><span class="line">yum-<span class="built_in">config</span>-manager：管理 YUM 软件仓库的配置。</span><br><span class="line">yum-builddep：安装构建特定软件包所需的所有依赖关系。</span><br><span class="line">debuginfo-install：安装调试信息的软件包，用于调试应用程序。</span><br><span class="line">yumdownloader：下载软件包而不安装它们。</span><br><span class="line">needs-restarting：检查系统中是否有需要重新启动的进程，通常在升级内核后使用。</span><br></pre></td></tr></table></figure><p><code>repo</code> 文件是用于配置 YUM 软件包管理系统中软件仓库（repository）的配置文件。这些文件通常位于 <code>/etc/yum.repos.d/</code> 目录下，每个仓库都有一个独立的 <code>.repo</code> 文件。</p><p>在etc目录下创建新的repo文件，在里面添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[nginx-stable]</span></span><br><span class="line"><span class="attr">name</span>=nqinx stable repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">qpqkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Inqinx-mainline]</span></span><br><span class="line"><span class="attr">name</span>=nginx mainline repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/mainline/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>开启Nginx</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> nginx</span><br></pre></td></tr></table></figure><p>检查端口</p><p>发现Nginx已经在80端口运行通过浏览器可以访问到</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp <span class="string">| grep 80</span></span><br></pre></td></tr></table></figure><h2 id="安装RabbitMQ">安装RabbitMQ</h2><p>准备gpgkey密钥</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:<span class="regexp">//</span>packagecloud.io<span class="regexp">/rabbitmq/</span>erlang/gpgkey</span><br><span class="line">rpm --import https:<span class="regexp">//gi</span>thub.com<span class="regexp">/rabbitmq/</span>signing-keys<span class="regexp">/releases/</span>download<span class="regexp">/2.0/</span>rabbitmq-release-signing-key.asc</span><br><span class="line">rpm --import https:<span class="regexp">//</span>packagecloud.io<span class="regexp">/rabbitmq/</span>rabbitmq-server/gpgkey</span><br></pre></td></tr></table></figure><p>编辑文件/etc/yum.repos.d/rabbitmq.repo</p><p>配置仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">填入如下内容</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Zero dependency Erlang</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq_erlang</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/7/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PackageCloud<span class="string">&#x27;s repository key and RabbitMQ package signing key</span></span></span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang-source]</span><br><span class="line">name=rabbitmq_erlang-source</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/7/SRPMS</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">PackageCloud&#x27;</span>s repository key and RabbitMQ package signing key</span></span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br></pre></td></tr></table></figure><h2 id="安装Redis">安装Redis</h2><p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。</p><p>redis的特点就是：<code>快</code>，可以基于内存存储数据并提供超低延迟、超快的检索速度</p><p>一般用于在系统中提供快速缓存的能力。</p><p>安装EPEL仓库</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><p>安装Redis</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> -y redis</span><br></pre></td></tr></table></figure><p>启动Redis</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl status redis</span></span><br></pre></td></tr></table></figure><p>查看端口使用</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp <span class="string">| grep 6379</span></span><br></pre></td></tr></table></figure><p>防火墙开放6379端口的TCP流量</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@CTA2102 yum.repos.d]# firewall-cmd --add-port=6379/tcp --permanent</span><br><span class="line"><span class="keyword">success</span></span><br><span class="line"><span class="keyword"></span>[root@CTA2102 yum.repos.d]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure><p>进入redis</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p>使用redis</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@CTA2102 yum.repos.d]</span># redis-cli</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; set mykey hello</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; get mykey</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h2 id="搭建Samba">搭建Samba</h2><p>安装samba</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> samba</span><br></pre></td></tr></table></figure><p>创建一个组，用于归类samba用户的组</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> /]<span class="meta"># cd home</span></span><br><span class="line">[root<span class="symbol">@localhost</span> home]<span class="meta"># mkdir momoteam</span></span><br><span class="line">[root<span class="symbol">@localhost</span> home]<span class="meta"># groupadd -g 3000 momoteam</span></span><br><span class="line">[root<span class="symbol">@localhost</span> home]<span class="meta"># chown :momoteam /home/momoteam/</span></span><br></pre></td></tr></table></figure><p>创建samba用户，并为他创建一个samba密码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]<span class="meta"># useradd -g momoteam -d /home/momoteam/sambauser01 sambauser01</span></span><br><span class="line">[root@localhost home]<span class="meta"># smbpasswd -a sambauser01</span></span><br><span class="line">New SMB password:</span><br><span class="line">Retype <span class="keyword">new</span> SMB password:</span><br><span class="line">Added user sambauser01.</span><br></pre></td></tr></table></figure><p>配置防火墙</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">sudo firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">--</span><span class="comment">add</span><span class="literal">-</span><span class="comment">service=samba</span> <span class="literal">--</span><span class="comment">permanent</span></span><br><span class="line"><span class="comment">sudo firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">--</span><span class="comment">reload</span></span><br></pre></td></tr></table></figure><p>配置samba的配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>samba/smb.conf</span><br></pre></td></tr></table></figure><p>在文件末尾增加以下配置</p><p>valid users表示允许哪些用户访问</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[share01]</span><br><span class="line">        <span class="keyword">comment</span> = <span class="keyword">share</span> <span class="keyword">of</span> sambauser01</span><br><span class="line">        <span class="type">path</span> = /home/momoteam/sambauser01</span><br><span class="line">        <span class="keyword">valid</span> users = sambauser01</span><br><span class="line">        browseable = yes</span><br><span class="line">        <span class="keyword">read</span> <span class="keyword">only</span> = <span class="keyword">no</span></span><br><span class="line">        <span class="built_in">public</span> = yes</span><br></pre></td></tr></table></figure><p>关闭SELinux</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">setenforce</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>修改共享文件的权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R <span class="number">766</span> <span class="regexp">/home/m</span>omoteam<span class="regexp">/sambauser01/</span></span><br></pre></td></tr></table></figure><p>启动samba服务</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start<span class="built_in"> smb</span></span><br><span class="line"><span class="built_in"></span>systemctl <span class="built_in">enable</span> smb</span><br></pre></td></tr></table></figure><p>在主机就可以通过文件管理器访问</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\<span class="number">192.168.99.135</span>\share01</span><br></pre></td></tr></table></figure><p>如果重启后访问被拒绝，可以在手动关闭一次SELinux</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">setenforce</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>也可以通过配置文件永久关闭SELinux</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>selinux/config</span><br></pre></td></tr></table></figure><p>将其中的一个值改为以下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SELINUX</span><span class="operator">=</span>disabled</span><br></pre></td></tr></table></figure><p>重启系统生效</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">reboot</span></span><br></pre></td></tr></table></figure><h3 id="本地测试Samba服务">本地测试Samba服务</h3><p>安装samba客户端</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install samba-<span class="keyword">client</span></span><br></pre></td></tr></table></figure><p>使用指令在本机访问samba服务</p><p>使用q退出</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># smbclient //127.0.0.1/share01 -U sambauser01</span></span><br><span class="line">Enter SAMBA<span class="string">\sambauser01&#x27;s</span> password: </span><br><span class="line">Try <span class="string">&quot;help&quot;</span> <span class="keyword">to</span> get a <span class="keyword">list</span> <span class="keyword">of</span> possible commands.</span><br><span class="line">smb: <span class="string">\&gt;</span> q</span><br></pre></td></tr></table></figure><h3 id="smb-conf详解">smb.conf详解</h3><p><code>smb.conf</code> 是 Samba 服务器配置文件，用于配置 Samba 服务器，使其能够提供文件和打印服务，与 Windows 客户端共享文件。下面是 <code>smb.conf</code> 配置文件中一些常见选项的详细解释：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line">   <span class="attr">workgroup</span> = WORKGROUP           <span class="comment">; 工作组或域名</span></span><br><span class="line">   server <span class="attr">string</span> = Samba Server    <span class="comment">; 服务器描述</span></span><br><span class="line">   <span class="attr">security</span> = user                <span class="comment">; 安全设置（user、share、domain、ads 等）</span></span><br><span class="line">   map to <span class="attr">guest</span> = bad user        <span class="comment">; 定义访客的映射行为</span></span><br><span class="line">   guest <span class="attr">account</span> = nobody         <span class="comment">; 访客用户</span></span><br><span class="line">   log <span class="attr">file</span> = /var/log/samba/log.%m <span class="comment">; 日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="section">[share]</span></span><br><span class="line">   <span class="attr">comment</span> = Shared Directory     <span class="comment">; 共享描述</span></span><br><span class="line">   <span class="attr">path</span> = /path/to/shared/directory <span class="comment">; 共享路径</span></span><br><span class="line">   valid <span class="attr">users</span> = user1 user2      <span class="comment">; 允许访问共享的用户</span></span><br><span class="line">   read <span class="attr">only</span> = <span class="literal">no</span>                 <span class="comment">; 是否只读</span></span><br><span class="line">   <span class="attr">browseable</span> = <span class="literal">yes</span>               <span class="comment">; 是否可浏览</span></span><br><span class="line">   <span class="attr">public</span> = <span class="literal">yes</span>                   <span class="comment">; 是否公开访问</span></span><br></pre></td></tr></table></figure><p>上面的示例 <code>smb.conf</code> 文件中包含了全局设置和一个共享的配置。以下是一些关键选项的详细解释：</p><ul><li><p><strong><code>workgroup</code>：</strong> 定义工作组或域名。这是 Samba 服务器在网络上标识自己的名称。</p></li><li><p><strong><code>server string</code>：</strong> 这是 Samba 服务器的描述，将在网络中显示。</p></li><li><p><strong><code>security</code>：</strong> 定义访问控制的安全级别。<code>user</code> 表示基于用户身份验证的安全设置。其他选项包括 <code>share</code>、<code>domain</code> 和 <code>ads</code>。</p></li><li><p><strong><code>map to guest</code>：</strong> 定义当访问共享失败时如何映射到访客。<code>bad user</code> 表示映射到访客，其他选项包括 <code>never</code>、<code>bad password</code> 等。</p></li><li><p><strong><code>guest account</code>：</strong> 定义访客用户的账户。在默认情况下，Samba 会使用 “nobody” 用户。</p></li><li><p><strong><code>log file</code>：</strong> 定义 Samba 日志文件的路径。<code>%m</code> 会被客户端的 NetBIOS 名称替换。</p></li><li><p><strong><code>comment</code>：</strong> 共享的描述或注释，将在客户端显示。</p></li><li><p><strong><code>path</code>：</strong> 共享目录的路径。</p></li><li><p><strong><code>valid users</code>：</strong> 允许访问共享的用户列表。</p></li><li><p><strong><code>read only</code>：</strong> 指定共享是否只读。</p></li><li><p><strong><code>browseable</code>：</strong> 指定共享是否可浏览，如果设置为 <code>no</code>，则无法在网络上看到这个共享。</p></li><li><p><strong><code>public</code>：</strong> 指定共享是否对公共用户开放。</p></li></ul><p>这只是 <code>smb.conf</code> 文件中一些常见选项的示例。<code>smb.conf</code> 文件支持许多其他选项，可以根据实际需求进行配置。更复杂的配置可能涉及到用户身份验证、访问权限、打印服务等方面的设置。在进行配置时，建议查阅 Samba 官方文档以获取更详细的信息和说明。</p><h1>零碎问题</h1><h2 id="指令">指令</h2><h3 id="ln指令的软链接和硬链接区别">ln指令的软链接和硬链接区别</h3><p>硬链接（Hard Link）和软链接（Symbolic Link）是两种不同类型的文件链接方式，它们有一些重要的区别：</p><ol><li><p>数据块关联：</p><ul><li>硬链接：硬链接是在文件系统中创建的额外链接，使得多个文件名指向同一个数据块。硬链接的所有链接都共享相同的数据块和 inode（索引节点），因此它们在文件系统上是等价的。删除任何一个硬链接不会影响其他链接，只有当所有链接都被删除时，数据块才会被释放。</li><li>软链接：软链接是一个特殊类型的文件，它包含指向目标文件或目录的路径。软链接本身是一个独立的文件，拥有自己的 inode 和数据块，它指向目标的路径。因此，软链接与目标之间是独立的，删除软链接不会影响目标，也可以链接到不存在的目标。</li></ul></li><li><p>跨文件系统：</p><ul><li>硬链接：硬链接只能链接到同一个文件系统上的文件，不能链接到不同文件系统上的文件。</li><li>软链接：软链接可以链接跨越文件系统和目录，因为它们只是一个指向目标的路径引用。</li></ul></li><li><p>对目录的链接：</p><ul><li>硬链接：硬链接不能链接到目录，只能链接到文件。</li><li>软链接：软链接可以链接到目录，允许你创建链接到整个目录的快捷方式。</li></ul></li><li><p>大小：</p><ul><li>硬链接：硬链接不会占用额外的磁盘空间，因为它们共享相同的数据块和 inode。</li><li>软链接：软链接本身占用少量磁盘空间，但指向的目标文件或目录会占用磁盘空间。</li></ul></li><li><p>修改目标和链接：</p><ul><li>硬链接：修改目标文件或链接文件的内容会影响所有硬链接，因为它们共享相同的数据块。</li><li>软链接：修改目标文件或链接文件的内容只会影响被修改的对象，软链接和目标之间没有数据关联。</li></ul></li></ol><p>总结：</p><ul><li>硬链接是文件系统级别的链接，共享相同的数据块和 inode，不能链接到目录，不能跨文件系统链接。</li><li>软链接是一个特殊的文件，包含指向目标的路径引用，可以链接跨文件系统和目录，也可以链接到不存在的目标，允许链接到目录。</li></ul><h3 id="tar指令">tar指令</h3><p>当前已经介绍了 <code>tar</code> 命令，但我可以提供更多关于 <code>tar</code> 指令的信息。</p><p><code>tar</code> 是一个在 Unix 和类 Unix 操作系统中广泛使用的命令行工具，用于创建和管理归档文件，通常称为 “tarball”。它允许将多个文件和目录组合成单个归档文件，并且可以使用不同的压缩算法进行压缩。</p><p><code>tar</code> 的名称来源于 “tape archive”（磁带归档），最初设计用于将文件和目录保存到磁带备份中。现在，它被广泛用于将文件和目录组合成一个归档文件，并进行压缩以便于传输或备份。</p><p>以下是 <code>tar</code> 命令的一些常用选项和用法：</p><ol><li>创建归档文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf archive.tar file1 file2 dir1 dir2</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>: 创建归档文件</li><li><code>-v</code>: 显示归档过程中的详细信息（verbose）</li><li><code>-f</code>: 指定归档文件名，必须紧随其后，否则可能会将文件内容输出到终端。</li></ul><ol start="2"><li>解压归档文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf archive.tar</span><br></pre></td></tr></table></figure><ul><li><code>-x</code>: 解压缩归档文件</li><li><code>-v</code>: 显示解压缩过程中的详细信息（verbose）</li><li><code>-f</code>: 指定归档文件名，必须紧随其后，否则可能会从终端读取输入。</li></ul><ol start="3"><li>压缩归档文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz file1 file2 dir1 dir2</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>: 创建归档文件</li><li><code>-z</code>: 使用 gzip 算法压缩归档文件</li><li><code>-v</code>: 显示压缩过程中的详细信息（verbose）</li><li><code>-f</code>: 指定归档文件名，必须紧随其后，否则可能会将文件内容输出到终端。</li></ul><ol start="4"><li>解压缩压缩的归档文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf archive.tar.gz</span><br></pre></td></tr></table></figure><ul><li><code>-x</code>: 解压缩归档文件</li><li><code>-z</code>: 使用 gzip 算法解压缩归档文件</li><li><code>-v</code>: 显示解压缩过程中的详细信息（verbose）</li><li><code>-f</code>: 指定归档文件名，必须紧随其后，否则可能会从终端读取输入。</li></ul><ol start="5"><li>查看归档文件内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tvf archive.tar</span><br></pre></td></tr></table></figure><ul><li><code>-t</code>: 列出归档文件中的内容</li><li><code>-v</code>: 显示详细信息</li><li><code>-f</code>: 指定归档文件名，必须紧随其后。</li></ul><p>以上只是 <code>tar</code> 命令的一些基本用法，<code>tar</code> 还有其他更多的选项和用法，你可以通过查阅 <code>tar</code> 命令的帮助文档（<code>man tar</code>）来了解更多信息。</p><h3 id="netstat指令">netstat指令</h3><p><code>netstat</code>（网络统计）是一个用于查看网络连接、路由表和网络接口等信息的命令行工具，常用于诊断网络问题和监控网络活动。它在多种操作系统中都可用，包括 Linux、macOS、Windows 等。</p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项：</strong></p><ul><li><code>-a</code>：显示所有连接和监听中的套接字。</li><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-n</code>：以数字格式显示地址和端口号，而不进行主机和端口的反向解析。</li><li><code>-p</code>：显示正在使用的进程的 PID 和进程名。</li><li><code>-r</code>：显示路由表信息。</li><li><code>-s</code>：显示统计信息，如网络接口统计和 TCP/UDP 协议统计。</li><li><code>-l</code>：仅显示监听中的套接字。</li></ul><p><strong>示例：</strong></p><ol><li>显示所有活动的 TCP 和 UDP 连接：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a</span><br></pre></td></tr></table></figure><ol start="2"><li>显示所有 TCP 连接：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -t</span><br></pre></td></tr></table></figure><ol start="3"><li>显示所有 UDP 连接：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -u</span><br></pre></td></tr></table></figure><ol start="4"><li>显示网络接口统计信息：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s</span><br></pre></td></tr></table></figure><ol start="5"><li>显示监听中的套接字：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -l</span><br></pre></td></tr></table></figure><ol start="6"><li>显示正在使用的进程的 PID 和进程名：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -p</span><br></pre></td></tr></table></figure><ol start="7"><li>以数字格式显示所有连接和监听中的套接字：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><p><code>netstat</code> 命令对于查看当前系统的网络连接情况、确认端口是否处于监听状态、检查网络接口的传输统计等非常有用。在 Linux 系统中，需要以超级用户（root）权限运行 <code>netstat</code> 命令，以查看完整的连接和进程信息。在 Windows 系统中，可以在命令提示符下直接运行 <code>netstat</code> 命令。</p><h3 id="find指令">find指令</h3><p><code>find</code> 是一个在 Linux 和类Unix系统中非常有用的命令，用于在指定目录下递归地搜索文件和目录。它可以通过多种条件来查找文件，例如文件名、文件类型、文件大小、修改时间等。<code>find</code> 命令非常强大，可以帮助用户快速定位所需的文件和目录。</p><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;搜索路径&gt; &lt;选项&gt; &lt;匹配条件&gt;</span><br></pre></td></tr></table></figure><p><strong>搜索路径：</strong><br>指定要搜索的目录路径。您可以在此处指定单个目录，也可以使用通配符来指定多个目录。</p><p><strong>选项：</strong></p><ul><li><code>-name</code>：按文件名进行匹配搜索。可以使用通配符进行模糊匹配。</li><li><code>-type</code>：按文件类型进行匹配搜索。例如，<code>f</code> 表示普通文件，<code>d</code> 表示目录。</li><li><code>-size</code>：按文件大小进行匹配搜索。可以使用 <code>+</code> 或 <code>-</code> 表示大于或小于指定大小，例如 <code>+10M</code> 表示大于 10MB。</li><li><code>-mtime</code>：按文件修改时间进行匹配搜索。可以使用 <code>+</code> 或 <code>-</code> 表示在指定天数前或后，例如 <code>-7</code> 表示七天前的文件。</li><li><code>-user</code>：按文件所有者进行匹配搜索。</li></ul><p><strong>匹配条件：</strong><br>指定要匹配的文件或目录名称。</p><p><strong>示例：</strong></p><ol><li>按文件名查找文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -name <span class="string">&quot;filename.txt&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>/path/to/search</code> 目录下查找名为 <code>filename.txt</code> 的文件。</p><ol start="2"><li>按文件类型查找目录：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -<span class="built_in">type</span> d</span><br></pre></td></tr></table></figure><p>在 <code>/path/to/search</code> 目录下查找所有目录。</p><ol start="3"><li>按文件大小查找文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -size +1M</span><br></pre></td></tr></table></figure><p>在 <code>/path/to/search</code> 目录下查找大于 1MB 的文件。</p><ol start="4"><li>按修改时间查找文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -mtime -7</span><br></pre></td></tr></table></figure><p>在 <code>/path/to/search</code> 目录下查找最近 7 天内修改过的文件。</p><ol start="5"><li>按文件所有者查找文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -user alice</span><br></pre></td></tr></table></figure><p>在 <code>/path/to/search</code> 目录下查找所有属于 <code>alice</code> 用户的文件。</p><p><code>find</code> 命令还有更多选项和用法，您可以通过 <code>man find</code> 命令查看更详细的帮助文档。由于 <code>find</code> 命令可以递归搜索整个文件系统，使用时请谨慎并确保使用正确的选项和路径来避免意外操作。</p><h3 id="ps指令">ps指令</h3><p><code>ps</code> 是一个用于查看当前系统中正在运行的进程信息的命令。它用于显示系统中运行的进程的状态、资源使用情况和其他相关信息。<code>ps</code> 命令在 Linux/Unix 系统中非常常用，用于监控和管理系统进程。</p><p><code>ps</code> 命令的基本用法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options]</span><br></pre></td></tr></table></figure><p>默认情况下，<code>ps</code> 命令会显示当前终端会话下正在运行的属于当前用户的进程信息。以下是一些常用的 <code>ps</code> 命令选项：</p><ul><li><strong><code>-e</code> 或 <code>--everyone</code></strong>：显示所有进程信息，不仅限于当前用户。</li><li><strong><code>-f</code> 或 <code>--full</code></strong>：显示完整格式的进程信息，包括更多详细信息。</li><li><strong><code>-l</code> 或 <code>--long</code></strong>：显示详细格式的进程信息，与 <code>-f</code> 类似。</li><li><strong><code>-u</code> 或 <code>--user</code></strong>：显示指定用户的进程信息。</li><li><strong><code>-p</code> 或 <code>--pid</code></strong>：显示指定进程号（PID）的进程信息。</li><li><strong><code>-g</code> 或 <code>--group</code></strong>：显示指定进程组的进程信息。</li><li><strong><code>-t</code> 或 <code>--terminal</code></strong>：显示指定终端会话的进程信息。</li><li><strong><code>-H</code> 或 <code>--forest</code></strong>：以树状结构显示进程信息，显示进程之间的父子关系。</li></ul><p>例如，要查看当前用户的所有进程信息，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e</span><br></pre></td></tr></table></figure><p>要查看完整格式的进程信息，包括命令行参数等信息，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -f</span><br></pre></td></tr></table></figure><p><code>ps</code> 命令还可以和其他命令结合使用，例如 <code>grep</code> 命令，以过滤显示特定进程信息。例如，查找所有包含 “chrome” 的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep chrome</span><br></pre></td></tr></table></figure><p>请注意，<code>ps</code> 命令显示的进程信息可能因系统而异，不同的系统可能有不同的选项和输出格式。你可以查阅系统文档或 <code>ps</code> 命令的帮助文档（使用 <code>man ps</code>）来了解更多细节。</p><p>总结起来，<code>ps</code> 命令是一个非常有用的工具，用于查看当前系统中运行的进程信息，它可以帮助你监控和管理系统进程。</p><h2 id="工具介绍">工具介绍</h2><h3 id="Tomcat">Tomcat</h3><p>Tomcat是一种开源的Web服务器和Servlet容器，由Apache软件基金会开发和维护。它是Java Servlet和JavaServer Pages（JSP）的实现，允许Java代码在Web服务器上运行。</p><p>具体来说，Tomcat是一个用于处理HTTP请求的Web服务器，它支持Java Servlet和JSP技术，这使得开发人员能够创建动态的、基于Java的Web应用程序。当用户访问Web应用程序时，Tomcat会处理HTTP请求并将其交给适当的Servlet或JSP进行处理，然后返回相应的HTML内容给客户端浏览器。</p><p>Tomcat非常流行，广泛用于Java Web应用程序的部署。它可以作为独立的Web服务器使用，也可以与其他HTTP服务器（如Apache HTTP Server）结合使用，通过调用适当的连接器实现更强大的功能。</p><p>总结而言，Tomcat是一个用于运行Java Servlet和JSP的Web容器，它提供了一个执行Java Web应用程序的运行时环境。</p><h3 id="Nginx">Nginx</h3><p>当谈到Nginx时，通常是指Nginx（发音为&quot;engine-x&quot;），它是一个高性能、轻量级的开源Web服务器和反向代理服务器。Nginx最初由俄罗斯的程序员Igor Sysoev开发，第一个公开版本发布于2004年。Nginx的目标是提供出色的性能、稳定性和低系统资源消耗，特别适用于高并发的Web服务和负载均衡。</p><p>主要特点：</p><ol><li><p>高性能：Nginx以其优秀的性能而闻名，它能够处理大量并发连接，高效地响应客户端请求。</p></li><li><p>轻量级：相对于其他Web服务器，Nginx的内存占用和资源消耗较低，这使其适合部署在资源有限的环境中。</p></li><li><p>反向代理：Nginx可以作为反向代理服务器，将客户端请求转发给后端应用服务器，并将响应返回给客户端，从而隐藏后端服务器的细节，增加了系统的安全性。</p></li><li><p>负载均衡：Nginx支持负载均衡，可以将客户端请求均匀地分发给多个后端服务器，从而提高系统的性能和可靠性。</p></li><li><p>静态文件服务：Nginx能够高效地处理静态文件，如图片、CSS和JavaScript文件等，可以提供快速的静态内容访问。</p></li><li><p>高度可扩展：由于其轻量级和高性能的特性，Nginx非常适合用于构建大规模、高并发的Web应用和服务。</p></li><li><p>可以作为HTTP缓存：Nginx能够缓存静态内容和反向代理的响应，减轻后端服务器的负担，提高访问速度。</p></li></ol><p>Nginx通常用于搭建静态内容服务、反向代理服务器、负载均衡器以及缓存服务器等。它在互联网上广泛使用，包括一些大型的网站和服务都在使用Nginx来处理用户请求。</p><p>值得注意的是，尽管Nginx能够处理静态内容，但它不能像传统的Web服务器（如Apache）那样直接解析动态内容，因此通常需要与后端应用服务器（如Node.js、PHP-FPM或uWSGI等）配合使用，以处理动态内容并将结果返回给Nginx。这种组合架构通常被称为LAMP（Linux + Apache + MySQL + PHP）或LEMP（Linux + Nginx + MySQL + PHP）等。</p><h3 id="RabbitMQ">RabbitMQ</h3><p>RabbitMQ是一种开源的消息队列中间件，它实现了高级消息队列协议（AMQP：Advanced Message Queuing Protocol）。由Pivotal Software（现已被VMware收购）开发和维护，RabbitMQ提供了一个强大的消息传递系统，用于在分布式应用程序之间传递消息。</p><p>在现代的分布式应用程序中，不同的组件或服务可能运行在不同的服务器或容器中，并且它们需要进行通信和协调。这时候，消息队列成为一个非常有用的工具。消息队列充当了中间人的角色，它接收来自一个组件的消息，并将其传递给另一个组件，从而实现了异步通信，降低了系统之间的耦合性，并提高了可伸缩性和可靠性。</p><p>RabbitMQ的基本工作原理如下：</p><ol><li>生产者（Producer）：发送消息的应用程序称为生产者，它将消息发送到RabbitMQ的交换机（Exchange）。</li><li>交换机（Exchange）：交换机接收来自生产者的消息，并根据一定的路由规则将消息发送到一个或多个消息队列中。</li><li>队列（Queue）：队列是消息的容器，在消息到达交换机后，根据交换机的路由规则，被路由到一个或多个队列中等待消费。</li><li>消费者（Consumer）：消费者是接收消息的应用程序，它从队列中获取消息并进行处理。</li></ol><p>RabbitMQ支持多种消息传递模式，如点对点（P2P）和发布-订阅（Pub-Sub）模式，可以根据应用程序的需求灵活地配置。</p><p>由于RabbitMQ是一个健壮、可靠且高性能的消息队列系统，它在很多场景中被广泛使用，包括微服务架构、任务队列、事件处理、日志聚合等。</p><h3 id="EPEL仓库">EPEL仓库</h3><p>EPEL（Extra Packages for Enterprise Linux）是为企业级Linux发行版提供额外软件包的一个社区项目。它为Red Hat Enterprise Linux (RHEL)、CentOS和其他RHEL兼容的Linux发行版提供了大量的高质量、可靠的额外软件包。这些软件包通常不包含在官方发行版的软件仓库中，但它们是很多用户需要的常用和流行软件的补充。</p><p>EPEL项目由Fedora社区维护，Fedora是Red Hat支持的一个开源Linux发行版。EPEL旨在为企业级Linux用户提供更多的软件选择，以满足不同需求。它提供了许多社区贡献的软件包，这些软件包经过测试，并且与官方发行版保持兼容性。</p><p>EPEL仓库的特点包括：</p><ol><li><p><strong>额外软件包</strong>：EPEL提供了很多额外的软件包，包括各种开发工具、网络服务、系统工具、数据库、编程语言的解释器和库等。</p></li><li><p><strong>高质量和安全性</strong>：EPEL中的软件包经过审核和测试，以确保其质量和安全性。这有助于降低用户在使用这些软件包时的风险。</p></li><li><p><strong>长期支持</strong>：EPEL支持长期发行版（如RHEL）的版本，这意味着即使发行版更新，用户也可以继续使用相同版本的EPEL仓库。</p></li></ol><p>在大多数情况下，要在Linux系统中启用EPEL仓库，只需安装EPEL的软件包即可。对于RHEL和CentOS用户，可以通过以下命令安装EPEL仓库：</p><p>对于RHEL 7和CentOS 7：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure><p>对于RHEL 8和CentOS 8：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install epel-release</span><br></pre></td></tr></table></figure><p>安装完成后，你就可以使用EPEL仓库中的软件包了。例如，要安装EPEL仓库中的软件包，可以使用<code>yum</code>或<code>dnf</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install package_name</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo dnf install package_name</span><br></pre></td></tr></table></figure><p>请注意，EPEL仓库虽然提供了很多额外的软件包，但在安装时仍要注意软件包的来源和信任度，以确保系统的安全性和稳定性。尽量选择官方支持的软件包，并定期更新系统和软件包，以获取最新的安全补丁和功能更新。</p><h3 id="iptables和firewall">iptables和firewall</h3><p>iptables和firewalld都是用于配置Linux防火墙的工具，但它们在设计和使用上有一些区别：</p><ol><li><p><strong>iptables</strong>:</p><ul><li>iptables是Linux上传统的防火墙工具，它是一个内核空间的工具，直接与Linux内核交互。</li><li>iptables使用规则链（Rules Chains）和表（Tables）来管理防火墙规则。主要有三个表：<code>filter</code>表（用于过滤数据包）、<code>nat</code>表（用于网络地址转换）、<code>mangle</code>表（用于特殊修改数据包）。</li><li>iptables规则是静态的，一旦设置后，除非重新启动防火墙或手动更改规则，否则规则不会动态改变。</li><li>iptables配置较为复杂，需要手动编写规则，对于复杂的防火墙策略，管理和维护相对繁琐。</li></ul></li><li><p><strong>firewalld</strong>:</p><ul><li>firewalld是一个动态防火墙管理器，它是iptables的高级接口，旨在简化防火墙配置和管理。</li><li>firewalld使用基于Zone的概念，将网络接口归类到不同的Zone中，并为每个Zone设置防火墙规则。Zone可以根据网络环境的不同，自动调整防火墙规则。</li><li>firewalld支持运行时的规则动态更新，即使在配置防火墙时也可以实时生效，不需要重新启动防火墙。</li><li>firewalld还支持D-Bus和NetworkManager集成，方便在图形界面中配置和管理防火墙。</li></ul></li></ol><p>总的来说，iptables是传统的、静态的防火墙工具，需要手动编写规则，并且一旦设置后，规则不会自动调整。而firewalld是一个动态的防火墙管理器，使用Zone和运行时动态更新的特性，使得配置和管理防火墙变得更加简单和灵活。对于新的Linux发行版，推荐使用firewalld来管理防火墙，而在一些旧的系统上，iptables可能仍然是常见的工具。</p><h2 id="文件或目录一共有哪些类型">文件或目录一共有哪些类型</h2><p>对的，我之前的回答有误。文件或目录权限表示的第一个字符确实可能是其他值，不仅仅限于 <code>-</code> 和 <code>d</code>。</p><p>在文件或目录权限表示中，第一个字符代表了文件类型和权限的信息。除了普通文件和目录，还有其他一些可能的类型：</p><ol><li><code>-</code>：表示这是一个普通文件。</li><li><code>d</code>：表示这是一个目录。</li><li><code>l</code>：表示这是一个符号链接（软链接）。</li><li><code>b</code>：表示这是一个块设备文件。</li><li><code>c</code>：表示这是一个字符设备文件。</li><li><code>s</code>：表示这是一个套接字文件。</li><li><code>p</code>：表示这是一个命名管道（FIFO）。</li></ol><p>这些字符描述了文件类型，并且后面的九个字符仍然代表文件的权限信息，分为所有者、同组用户和其他用户的权限。</p><p>所以，完整的文件或目录权限表示由十个字符组成，其中第一个字符表示文件类型，接下来的九个字符表示文件的访问权限。例如，<code>-rw-r--r--</code> 表示一个普通文件，所有者有读写权限，同组用户和其他用户只有读取权限。</p><p>如果还有其他问题，请随时向我询问。</p><h2 id="SELinux是什么">SELinux是什么</h2><p>SELinux（Security-Enhanced Linux）是一个在 Linux 操作系统上实施强制访问控制（MAC）的安全子系统。它在内核级别提供了一套强大的安全策略机制，用于限制进程、用户和系统服务之间的访问权限。SELinux 的设计目标是加强操作系统的安全性，通过细粒度的权限控制来防止恶意活动和攻击。</p><p>与传统的自由访问控制（DAC）系统不同，SELinux 强调在操作系统内核级别实施安全策略，不仅依赖于用户和文件的权限设置。它使用了标签（Label）来标识对象（如文件、进程、端口等），并基于这些标签来强制执行访问控制。这种方式可以限制应用程序和用户只能进行特定的操作，从而降低了攻击的潜在风险。</p><p>SELinux 提供了以下几种安全上下文：</p><ol><li><p><strong>用户安全上下文（User Context）：</strong> 标识用户和用户组。类似于 Linux 中的用户和组标识。</p></li><li><p><strong>对象安全上下文（Object Context）：</strong> 标识文件、进程和其他系统资源。对象的安全上下文可以根据标签指定的安全策略来限制对它们的访问。</p></li><li><p><strong>角色安全上下文（Role Context）：</strong> 标识用户的角色。角色可以用来定义一组允许的操作和权限。</p></li><li><p><strong>类型安全上下文（Type Context）：</strong> 标识对象的类型。类型定义了对象可以执行的操作和被访问的资源。</p></li></ol><p>SELinux 的工作原理是基于策略规则，这些规则定义了哪些安全上下文可以访问特定类型的资源，以及可以执行哪些操作。SELinux 提供了不同的策略，如&quot;targeted&quot;（针对性策略）和&quot;strict&quot;（严格策略），用户可以根据实际需求选择适当的策略。</p><p>总之，SELinux 增强了 Linux 系统的安全性，通过强制性的访问控制机制，有助于防止潜在的恶意活动和提高系统的抵抗力。</p>]]></content>
    
    
    <summary type="html">🥧本文汇总CentOS的安装、常用指令、常用第三方软件</summary>
    
    
    
    <category term="操作系统" scheme="https://momoao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://momoao.github.io/tags/Linux/"/>
    
    <category term="CentOS" scheme="https://momoao.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>C++核心编程</title>
    <link href="https://momoao.github.io/posts/202308241921.html"/>
    <id>https://momoao.github.io/posts/202308241921.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-25T12:42:27.557Z</updated>
    
    <content type="html"><![CDATA[<h1>C++核心编程</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><h2 id="1-内存分区模型">1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放<strong>全局变量</strong>和<strong>静态变量</strong>以及<strong>常量</strong>（字符串常量、const修饰的常量(const修饰的全局常量在全局区，修饰的局部常量不在全局区)）</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前">1.1 程序运行前</h3><p>​在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​<strong>代码区：</strong></p><p>​存放 CPU 执行的机器指令</p><p>​代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​<strong>全局区：</strong></p><p>​全局变量和静态变量存放在此.</p><p>​全局区还包含了常量区, <strong>字符串常量</strong>和<strong>其他常量</strong>也存放在此.</p><p>​==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="assets/1545017602518.png" alt="1545017602518"></p><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后">1.2 程序运行后</h3><p>​<strong>栈区：</strong></p><p>​由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>堆区：</strong></p><p>​由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="1-3-new操作符">1.3 new操作符</h3><p>​C++中利用==new==操作符在堆区开辟数据</p><p>​堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p>​语法：<code> new 数据类型</code></p><p>​利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用delete释放堆区数据</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-引用">2 引用</h2><h3 id="2-1-引用的基本使用">2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引用注意事项">2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变引用</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数">2.3 引用做函数参数</h3><p>**作用：**函数传参时，可以利用引用的技术让形参修饰实参</p><p>**优点：**可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值">2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line"><span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line"><span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="2-5-引用的本质">2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; </span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用">2.6 常量引用</h3><p>**作用：**常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line"><span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-函数提高">3 函数提高</h2><h3 id="3-1-函数默认参数">3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数占位参数">3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载">3.3 函数重载</h3><h4 id="3-3-1-函数重载概述">3.3.1 函数重载概述</h4><p>**作用：**函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项">3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类和对象"><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>​人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h3 id="4-1-封装">4.1 封装</h3><h4 id="4-1-1-封装的意义">4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p>**示例1：**设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为</span></span><br><span class="line"><span class="comment">//获取到圆的周长</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">m_id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu;</span><br><span class="line">stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限</li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别">4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有">4.1.3 成员属性设置为私有</h4><p>**优点1：**将所有成员属性设置为私有，可以自己控制读写权限</p><p>**优点2：**对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//姓名设置可读可写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取年龄 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置为只写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">m_Lover = lover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">//姓名设置</span></span><br><span class="line">p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄设置</span></span><br><span class="line">p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置</span></span><br><span class="line">p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习案例1：设计立方体类</strong></p><p>设计立方体类(Cube)</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等。</p><p><img src="assets/1545533548532.png" alt="1545533548532"></p><p><strong>练习案例2：点和圆的关系</strong></p><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p><p><img src="assets/1545533829184.png" alt="1545533829184"></p><h3 id="4-2-对象的初始化和清理">4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数">4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用">4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​按参数分为： 有参构造和无参构造</p><p>​按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line"><span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 显式法</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"><span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line"><span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则">4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝">4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">m_age = p.m_age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表">4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员">4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-静态成员">4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>**示例1 ：**静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**示例2：**静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针">4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储">4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念">4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数">4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数">4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-友元">4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元">4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Building b;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元">4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元">4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运算符重载">4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载">4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p2.m_A + val;</span><br><span class="line">temp.m_B = p2.m_B + val;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数方式</span></span><br><span class="line">Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载">4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载">4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="comment">//先++</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="comment">//再返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">//先返回</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载">4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-5-关系运算符重载">4.5.5 关系运算符重载</h4><p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"><span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载">4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">MyPrint myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-继承">4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="assets/1544861202252.png" alt="1544861202252"></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法">4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式">4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="assets/clip_image002.png" alt="img"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型">4.6.3 继承中的对象模型</h4><p>**问题：**从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p><img src="assets/1545881904150.png" alt="1545881904150"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="assets/1545882158050.png" alt="1545882158050"></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序">4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式">4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式">4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法">4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承">4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​两个派生类继承同一个基类</p><p>​又有某个类同时继承者两个派生类</p><p>​这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="assets/clip_image002.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态">4.7  多态</h3><h4 id="4-7-1-多态的基本概念">4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类">4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//普通实现测试</span></span><br><span class="line">Calculator c;</span><br><span class="line">c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建加法计算器</span></span><br><span class="line">AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建减法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建乘法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类">4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品">4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="assets/1545985945198.png" alt="1545985945198"></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">Boil</span>();</span><br><span class="line"><span class="built_in">Brew</span>();</span><br><span class="line"><span class="built_in">PourInCup</span>();</span><br><span class="line"><span class="built_in">PutSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line"><span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构">4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装">4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-文件操作">5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件">5.1文本文件</h3><h4 id="5-1-1写文件">5.1.1写文件</h4><p>写文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p>**例如：**用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件">5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//string buf;</span></span><br><span class="line"><span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h3 id="5-2-二进制文件">5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件">5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建输出流对象</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、打开文件</span></span><br><span class="line"><span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、写文件</span></span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件">5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul><h1>C++提高编程</h1><ul><li>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</li></ul><h2 id="1-模板">1 模板</h2><h3 id="1-1-模板的概念">1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p><p>例如生活中的模板</p><p>模板的特点：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h3 id="1-2-函数模板">1.2 函数模板</h3><ul><li><p>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</p></li><li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p></li></ul><h4 id="1-2-1-函数模板语法">1.2.1 函数模板语法</h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板实现交换</span></span><br><span class="line"><span class="comment">//1、自动类型推导</span></span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line"><span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="1-2-2-函数模板注意事项">1.2.2 函数模板注意事项</h4><p>注意事项：</p><ul><li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p></li><li><p>模板必须要确定出T的数据类型，才可以使用</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line"><span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="1-2-3-函数模板案例">1.2.3 函数模板案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试char数组</span></span><br><span class="line"><span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line"><span class="built_in">mySort</span>(charArr, num);</span><br><span class="line"><span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试int数组</span></span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">mySort</span>(intArr, num);</span><br><span class="line"><span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：模板可以提高代码复用，需要熟练掌握</p><h4 id="1-2-4-普通函数与函数模板的区别">1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p><h4 id="1-2-5-普通函数与函数模板的调用规则">1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，<strong>优先调用普通函数</strong></li><li><strong>可以通过空模板参数列表来强制调用函数模板</strong></li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line"><span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4 id="1-2-6-模板的局限性">1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><p><strong>例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line"><span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li><strong>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</strong></li></ul><h3 id="1-3-类模板">1.3 类模板</h3><h4 id="1-3-1-类模板语法">1.3.1 类模板语法</h4><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4 id="1-3-2-类模板与函数模板区别">1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中<strong>可以有默认参数</strong></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><strong>类模板使用只能用显示指定类型方式</strong></li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4 id="1-3-3-类模板中成员函数创建时机">1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass&lt;Person1&gt; m;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4 id="1-3-4-类模板对象做函数参数">1.3.4 类模板对象做函数参数</h4><p>学习目标：</p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ol><li>指定传入的类型   — 直接显示对象的数据类型</li><li>参数模板化           — 将对象中的参数变为模板进行传递</li><li>整个类模板化       — 将这个对象类型 模板化进行传递</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4 id="1-3-5-类模板与继承">1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son2</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4 id="1-3-6-类模板成员函数类外实现">1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//成员函数类内声明</span></span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p><h4 id="1-3-7-类模板分文件编写">1.3.7 类模板分文件编写</h4><p>学习目标：</p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><strong>示例：</strong></p><p>person.hpp中代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板分文件编写.cpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p><h4 id="1-3-8-类模板与友元">1.3.8 类模板与友元</h4><p>学习目标：</p><ul><li>掌握类模板配合友元函数的类内和类外实现</li></ul><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h4 id="1-3-9-类模板案例">1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><strong>示例：</strong></p><p>myArray.hpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line"><span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组容量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="function"><span class="type">int</span><span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"><span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"><span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板案例—数组类封装.cpp中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printIntArray</span>(array1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">array2.<span class="built_in">Pop_back</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printIntArray</span>(array2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>能够利用所学知识点实现通用的数组</p><h3 id="1-4-类模板和函数模板的区别">1.4 类模板和函数模板的区别</h3><p>类模板和函数模板是C++中的两种不同类型的模板，它们在使用方式和应用领域上有一些区别。</p><ol><li><p>使用方式：</p><ul><li>函数模板：函数模板用于定义通用函数，可以在函数内部使用泛型类型参数。函数模板的定义以 <code>template&lt;typename T&gt;</code> 开始，后面跟着函数的定义。函数模板可以根据函数参数的类型进行自动推导。</li><li>类模板：类模板用于定义通用类，可以在类的成员函数和成员变量中使用泛型类型参数。类模板的定义以 <code>template&lt;typename T&gt;</code> 开始，后面跟着类的定义。类模板需要在实例化时显式指定模板参数的类型。</li></ul></li><li><p>应用领域：</p><ul><li>函数模板：函数模板通常用于定义通用的算法或操作，可以适用于多种数据类型。例如，你可以编写一个通用的排序函数模板，用于对整数数组、浮点数数组或字符串数组进行排序。</li><li>类模板：类模板通常用于定义通用的数据结构或容器，可以存储和操作多种数据类型。例如，你可以编写一个通用的链表类模板，用于存储整数、浮点数或自定义类型的节点。</li></ul></li><li><p>实例化：</p><ul><li>函数模板：函数模板在调用时可以根据函数参数的类型进行自动推导，并生成相应的具体函数。例如，<code>getMax(5, 10)</code> 可以自动推导出 <code>getMax&lt;int&gt;(5, 10)</code>，并调用具体的整数类型函数。</li><li>类模板：类模板需要在实例化时显式指定模板参数的类型，以创建具体的类实例。例如，<code>Stack&lt;int&gt;</code> 实例化一个整数类型的栈类，<code>Stack&lt;double&gt;</code> 实例化一个双精度浮点数类型的栈类。</li></ul></li></ol><p>总结起来，函数模板用于定义通用函数，函数参数的类型可以自动推导；类模板用于定义通用类，需要在实例化时显式指定模板参数的类型。函数模板通常用于通用算法，类模板通常用于通用数据结构或容器。</p><h2 id="2-STL初识">2 STL初识</h2><h3 id="2-1-STL的诞生">2.1 STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="2-2-STL基本概念">2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3-STL六大组件">2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4-STL中容器、算法、迭代器">2.4  STL中容器、算法、迭代器</h3><p>**容器：**置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​<strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>**算法：**问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p>**迭代器：**容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="2-5-容器算法迭代器初识">2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="2-5-1-vector存放内置数据类型">2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型">2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string mName;</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-Vector容器嵌套容器">2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-STL-常用容器">3 STL- 常用容器</h2><h3 id="3-1-string容器">3.1 string容器</h3><h4 id="3-1-1-string基本概念">3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2-string构造函数">3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>          //创建一个空的字符串 例如: string str;<br><code>string(const char* s);</code>        //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3-string赋值操作">3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str1;</span><br><span class="line">str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3;</span><br><span class="line">str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str4;</span><br><span class="line">str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str5;</span><br><span class="line">str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string str6;</span><br><span class="line">str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str7;</span><br><span class="line">str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p><h4 id="3-1-4-string字符串拼接">3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//str3.append(str2);</span></span><br><span class="line">str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="3-1-5-string查找和替换">3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6-string字符串比较">3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1</p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7-string字符存取">3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="3-1-8-string插入和删除">3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**插入和删除的起始下标都是从0开始</p><h4 id="3-1-9-string子串">3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line"><span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3 id="3-2-vector容器">3.2 vector容器</h3><h4 id="3-2-1-vector基本概念">3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li><strong>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</strong></li></ul><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/clip_image002.jpg" alt="说明: 2015-11-10_151152"></p><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="3-2-2-vector构造函数">3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                    //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-2-3-vector赋值操作">3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p></li><li><p><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="3-2-4-vector容量和大小">3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​      //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​              //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="3-2-5-vector插入和删除">3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear</li></ul><h4 id="3-2-6-vector数据存取">3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>       //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器">3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间">3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h3 id="3-3-deque容器">3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念">3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/clip_image002-1547547642923.jpg" alt="说明: 2015-11-19_204101"></p><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/clip_image002-1547547896341.jpg" alt="clip_image002-1547547896341"></p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数">3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line"><span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d4 = d3;</span><br><span class="line"><span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作">3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</p></li><li><p><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line"><span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d3;</span><br><span class="line">d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d4;</span><br><span class="line">d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作">3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                             //如果容器变短，则<strong>末尾超出容器长度的元素被删除</strong>。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//统计大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-3-5-deque-插入和删除">3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">d.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">d.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">d.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —  push_back</li><li>尾删   —  pop_back</li><li>头插   —  push_front</li><li>头删   —  pop_front</li></ul><h4 id="3-3-6-deque-数据存取">3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>      //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序">3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"><span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><h3 id="3-4-案例-评委打分">3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述">3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4 id="3-4-2-实现步骤">3.4.2 实现步骤</h4><ol><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name; <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createPerson</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">name += nameSeed[i];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">d.<span class="built_in">push_back</span>(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除最高和最低分</span></span><br><span class="line">d.<span class="built_in">pop_back</span>();</span><br><span class="line">d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取平均分</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">&#123;</span><br><span class="line">sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">it-&gt;m_Score = avg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数种子</span></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建5名选手</span></span><br><span class="line">vector&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line"><span class="built_in">createPerson</span>(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、给5名选手打分</span></span><br><span class="line"><span class="built_in">setScore</span>(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示最后得分</span></span><br><span class="line"><span class="built_in">showScore</span>(v);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p><h3 id="3-5-stack容器">3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念">3.5.1 stack 基本概念</h4><p><strong>概念：<strong>stack是一种</strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/clip_image002-1547604555425.jpg" alt="说明: 2015-11-15_195707"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p><p>生活中的栈：</p><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/clip_image002.png" alt="img"></p><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/clip_image002-1547605111510.jpg" alt="img"></p><h4 id="3-5-2-stack-常用接口">3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top(); </code>                //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈   — push</li><li>出栈   — pop</li><li>返回栈顶   — top</li><li>判断栈是否为空   — empty</li><li>返回栈大小   — size</li></ul><h3 id="3-6-queue-容器">3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念">3.6.1 queue 基本概念</h4><p><strong>概念：<strong>Queue是一种</strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/clip_image002-1547606475892.jpg" alt="说明: 2015-11-15_214429"></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><p>生活中的队列：</p><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/1547606785041.png" alt="1547606785041"></p><h4 id="3-6-2-queue-常用接口">3.6.2 queue 常用接口</h4><p>功能描述：<strong>栈容器常用的对外接口</strong></p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front(); </code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">q.<span class="built_in">push</span>(p1);</span><br><span class="line">q.<span class="built_in">push</span>(p2);</span><br><span class="line">q.<span class="built_in">push</span>(p3);</span><br><span class="line">q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//输出队头元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出队头元素</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队   — push</li><li>出队   — pop</li><li>返回队头元素   — front</li><li>返回队尾元素   — back</li><li>判断队是否为空   — empty</li><li>返回队列大小   — size</li></ul><h3 id="3-7-list容器">3.7 list容器</h3><h4 id="3-7-1-list基本概念">3.7.1 list基本概念</h4><p>**功能：**将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p><strong>STL中的链表是一个双向循环链表</strong></p><p><img src="image/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B_Image/clip_image002-1547608564071.jpg" alt="说明: 2015-11-15_225145"></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="3-7-2-list构造函数">3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line"><span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="3-7-3-list-赋值和交换">3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list赋值和交换操作能够灵活运用即可</p><h4 id="3-7-4-list-大小操作">3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size(); </code>                             //返回容器中元素的个数</p></li><li><p><code>empty(); </code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​    //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>//如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-7-5-list-插入和删除">3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">L.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">L.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">it = L.<span class="built_in">begin</span>();</span><br><span class="line">L.<span class="built_in">erase</span>(++it);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">L.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插   — push_back</li><li>尾删   — pop_back</li><li>头插   — push_front</li><li>头删   — pop_front</li><li>插入   — insert</li><li>删除   — erase</li><li>移除   — remove</li><li>清空   — clear</li></ul><h4 id="3-7-6-list-数据存取">3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素   — front</li><li>返回最后一个元素   — back</li></ul><h4 id="3-7-7-list-反转和排序">3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转容器的元素</span></span><br><span class="line">L.<span class="built_in">reverse</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转   — reverse</li><li>排序   — sort （成员函数）</li></ul><h4 id="3-7-8-排序案例">3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age , <span class="type">int</span> height) &#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p></li><li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p></li></ul><h3 id="3-8-set-multiset-容器">3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念">3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="3-8-2-set构造和赋值">3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line"><span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-8-3-set大小和交换">3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">swap</span>(s2);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-8-4-set插入和删除">3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">s1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-8-5-set查找和统计">3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="type">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于set，结果为0或者1）</li></ul><h4 id="3-8-6-set和multiset区别">3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//multiset</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-8-7-pair对组创建">3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="3-8-8-set容器排序">3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>   set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序规则</span></span><br><span class="line">set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(p1);</span><br><span class="line">s.<span class="built_in">insert</span>(p2);</span><br><span class="line">s.<span class="built_in">insert</span>(p3);</span><br><span class="line">s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="3-9-map-multimap容器">3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念">3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="3-9-2-map构造和赋值">3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数:</li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">m3 = m2; <span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-9-3-map大小和交换">3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">m.<span class="built_in">swap</span>(m2);</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-9-4-map插入和删除">3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//第一种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种插入方式</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">m.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-9-5-map查找和统计">3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于map，结果为0或者1）</li></ul><h4 id="3-9-6-map容器排序">3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="3-10-案例-员工分组">3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述">3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="3-10-2-实现步骤">3.10.2 实现步骤</h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Worker worker;</span><br><span class="line">worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line"><span class="comment">//将员工放入到容器中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//产生随机部门编号</span></span><br><span class="line"><span class="type">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将员工插入到分组中</span></span><br><span class="line"><span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">multimap&lt;<span class="type">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line"><span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建员工</span></span><br><span class="line">vector&lt;Worker&gt;vWorker;</span><br><span class="line"><span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、员工分组</span></span><br><span class="line">multimap&lt;<span class="type">int</span>, Worker&gt;mWorker;</span><br><span class="line"><span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、分组显示员工</span></span><br><span class="line"><span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">////测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul><h2 id="4-STL-函数对象">4 STL- 函数对象</h2><h3 id="4-1-函数对象">4.1 函数对象</h3><h4 id="4-1-1-函数对象概念">4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="4-1-2-函数对象使用">4.1.2  函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd myAdd;</span><br><span class="line">cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyPrint</span>()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">count++; <span class="comment">//统计使用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line"><span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><strong>仿函数写法非常灵活，可以作为参数进行传递。</strong></li></ul><h3 id="4-2-谓词">4.2  谓词</h3><h4 id="4-2-1-谓词概念">4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词">4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="4-2-3-二元谓词">4.2.3 二元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><h3 id="4-3-内建函数对象">4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义">4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="4-3-2-算术仿函数">4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="4-3-3-关系仿函数">4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现仿函数</span></span><br><span class="line"><span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"><span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="4-3-4-逻辑仿函数">4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：逻辑仿函数实际应用较少，了解即可</p><h2 id="5-STL-常用算法">5 STL- 常用算法</h2><p><strong>概述</strong>:</p><ul><li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p></li><li><p><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p></li><li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p></li><li><p><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</p></li></ul><h3 id="5-1-常用遍历算法">5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     //遍历容器</li><li><code>transform</code>   //搬运容器到另一个容器中</li></ul><h4 id="5-1-1-for-each">5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);  </code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="5-1-2-transform">5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【v.begin()到v.end()之间的元素经过TransForm()仿函数处理后返回，传给vTarget.begin()】</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="5-2-常用查找算法">5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="5-2-1-find">5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="5-2-2-find-if">5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find">5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);  </code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相邻重复元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search">5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count">5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);  </code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="5-2-6-count-if">5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**按值统计用count，按条件统计用count_if</p><h3 id="5-3-常用排序算法">5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             //对容器内元素进行排序</li><li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       // 反转指定范围的元素</li></ul><h4 id="5-3-1-sort">5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort默认从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle">5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);  </code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打乱顺序</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="5-3-3-merge">5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line"><span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//合并  需要两个有序序列</span></span><br><span class="line"><span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse">5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);  </code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法">5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     // 互换两个容器的元素</li></ul><h4 id="5-4-1-copy">5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace">5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if">5.4.3 replace_if</h4><p><strong>功能描述:</strong></p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap">5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);  </code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">swap</span>(v1, v2);</span><br><span class="line">for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**swap交换容器时，注意交换的容器要同种类型</p><h3 id="5-5-常用算术生成算法">5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      // 计算容器元素累计总和</p></li><li><p><code>fill</code>                 // 向容器中添加元素</p></li></ul><h4 id="5-5-1-accumulate">5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);  </code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill">5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);  </code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**利用fill可以将容器区间内元素填充为 指定的值</p><h3 id="5-6-常用集合算法">5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          // 求两个容器的交集</p></li><li><p><code>set_union</code>                       // 求两个容器的并集</p></li><li><p><code>set_difference </code>              // 求两个容器的差集</p></li></ul><h4 id="5-6-1-set-intersection">5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="5-6-2-set-union">5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference">5.6.3  set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul><h1>STL常用容器</h1><h2 id="概述">概述</h2><p>在STL（标准模板库）中，常用的容器有以下几种：</p><ol><li><p><code>vector</code>（向量）：动态数组，支持快速的随机访问和尾部插入/删除操作。</p></li><li><p><code>list</code>（链表）：双向链表，支持在任意位置高效地插入和删除元素。</p></li><li><p><code>deque</code>（双端队列）：双端队列，支持在两端高效地插入和删除元素。</p></li><li><p><code>stack</code>（栈）：后进先出（LIFO）的数据结构，只能在栈顶进行插入和删除操作。</p></li><li><p><code>queue</code>（队列）：先进先出（FIFO）的数据结构，只能在队列的前端进行插入，后端进行删除操作。</p></li><li><p><code>priority_queue</code>（优先队列）：基于堆的数据结构，每次删除操作都会删除最大或最小元素。</p></li><li><p><code>set</code>（集合）：有序集合，不允许重复元素的存在，支持高效的插入、查找和删除操作。</p></li><li><p><code>map</code>（映射）：键值对的集合，每个键唯一，支持高效的插入、查找和删除操作。</p></li><li><p><code>unordered_set</code>（无序集合）：无序集合，不允许重复元素的存在，支持高效的插入、查找和删除操作。</p></li><li><p><code>unordered_map</code>（无序映射）：无序的键值对集合，每个键唯一，支持高效的插入、查找和删除操作。</p></li></ol><p>以上是STL中的一些常用容器，每种容器都有其特定的用途和适用场景。根据具体的需求，选择合适的容器可以提高代码的效率和可维护性。</p><h2 id="vector">vector</h2><p>下面是<code>std::vector</code>的常用方法列表及其简要描述：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>push_back(value)</code></td><td>在向量末尾插入元素</td></tr><tr><td><code>pop_back()</code></td><td>删除向量末尾的元素</td></tr><tr><td><code>insert(pos, value)</code></td><td>在指定位置插入元素</td></tr><tr><td><code>erase(pos)</code></td><td>删除指定位置的元素</td></tr><tr><td><code>clear()</code></td><td>清空向量中的所有元素</td></tr><tr><td><code>size()</code></td><td>返回向量中元素的数量</td></tr><tr><td><code>empty()</code></td><td>检查向量是否为空</td></tr><tr><td><code>at(index)</code></td><td>访问指定索引处的元素</td></tr><tr><td><code>front()</code></td><td>返回向量的第一个元素</td></tr><tr><td><code>back()</code></td><td>返回向量的最后一个元素</td></tr><tr><td><code>resize(newSize)</code></td><td>改变向量的大小</td></tr><tr><td><code>reserve(newCapacity)</code></td><td>改变向量的容量</td></tr><tr><td><code>swap(otherVector)</code></td><td>交换两个向量的内容</td></tr><tr><td><code>begin()</code></td><td>返回指向向量起始位置的迭代器</td></tr><tr><td><code>end()</code></td><td>返回指向向量末尾位置的迭代器</td></tr><tr><td><code>rbegin()</code></td><td>返回指向向量末尾的逆向迭代器</td></tr><tr><td><code>rend()</code></td><td>返回指向向量起始位置的逆向迭代器</td></tr><tr><td><code>operator[]</code></td><td>访问指定索引处的元素</td></tr></tbody></table><p>下面是使用这些方法的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back() 插入元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert() 在指定位置插入元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(numbers.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase() 删除指定位置的元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(numbers.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size() 获取元素数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;元素数量：&quot;</span> &lt;&lt; numbers.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 range-based for 循环遍历元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素：&quot;</span> &lt;&lt; numbers.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最后一个元素：&quot;</span> &lt;&lt; numbers.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty() 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vector为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vector不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    numbers.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty() 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vector为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例代码演示了<code>std::vector</code>的一些常用方法的用法，包括插入</p><p>、删除、访问、遍历、大小检查和清空操作。你可以根据需要使用这些方法进行向量的操作。</p><h2 id="list">list</h2><p>下面是<code>std::list</code>的常用方法列表及其简要描述：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>push_back(value)</code></td><td>在列表末尾插入元素</td></tr><tr><td><code>push_front(value)</code></td><td>在列表头部插入元素</td></tr><tr><td><code>pop_back()</code></td><td>删除列表末尾的元素</td></tr><tr><td><code>pop_front()</code></td><td>删除列表头部的元素</td></tr><tr><td><code>insert(pos, value)</code></td><td>在指定位置插入元素</td></tr><tr><td><code>erase(pos)</code></td><td>删除指定位置的元素</td></tr><tr><td><code>clear()</code></td><td>清空列表中的所有元素</td></tr><tr><td><code>size()</code></td><td>返回列表中元素的数量</td></tr><tr><td><code>empty()</code></td><td>检查列表是否为空</td></tr><tr><td><code>front()</code></td><td>返回列表的第一个元素</td></tr><tr><td><code>back()</code></td><td>返回列表的最后一个元素</td></tr><tr><td><code>resize(newSize)</code></td><td>改变列表的大小</td></tr><tr><td><code>reverse()</code></td><td>反转列表中的元素顺序</td></tr><tr><td><code>sort()</code></td><td>对列表中的元素进行排序</td></tr><tr><td><code>splice(pos, other)</code></td><td>将另一个列表的元素插入到指定位置</td></tr><tr><td><code>merge(other)</code></td><td>将另一个已排序的列表合并到当前列表中</td></tr><tr><td><code>unique()</code></td><td>移除列表中的连续重复元素</td></tr><tr><td><code>remove(value)</code></td><td>移除列表中所有匹配给定值的元素</td></tr><tr><td><code>begin()</code></td><td>返回指向列表起始位置的迭代器</td></tr><tr><td><code>end()</code></td><td>返回指向列表末尾位置的迭代器</td></tr><tr><td><code>rbegin()</code></td><td>返回指向列表末尾的逆向迭代器</td></tr><tr><td><code>rend()</code></td><td>返回指向列表起始位置的逆向迭代器</td></tr><tr><td><code>iterator</code></td><td>双向迭代器，用于访问和操作列表中的元素</td></tr></tbody></table><p>下面是使用这些方法的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back() 插入元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_front() 在头部插入元素</span></span><br><span class="line">    numbers.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert() 在指定位置插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(it, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase() 删除指定位置的元素</span></span><br><span class="line">    it = numbers.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">1</span>);</span><br><span class="line">    numbers.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size() 获取元素数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;元素数量：&quot;</span> &lt;&lt; numbers.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 range-based for 循环遍历元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素：&quot;</span> &lt;&lt; numbers.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最后一个元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">：&quot;</span> &lt;&lt; numbers.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty() 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;list为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;list不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空所有元素</span></span><br><span class="line">    numbers.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty() 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;list为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例代码演示了<code>std::list</code>的一些常用方法的用法，包括插入、删除、访问、遍历、大小检查和清空操作。你可以根据需要使用这些方法进行链表的操作。</p><h2 id="deque">deque</h2><p>deque（双端队列）是C++标准库中的容器之一，它可以在两端进行高效的插入和删除操作。deque的名称是&quot;double-ended queue&quot;的缩写，它允许在队列的前端和后端进行常数时间的操作，因此非常适用于需要频繁在两端进行插入和删除的场景。</p><p>下面是常用的deque方法的图表：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>push_back()</code></td><td>在deque的尾部插入一个元素</td></tr><tr><td><code>push_front()</code></td><td>在deque的头部插入一个元素</td></tr><tr><td><code>pop_back()</code></td><td>删除deque的尾部元素</td></tr><tr><td><code>pop_front()</code></td><td>删除deque的头部元素</td></tr><tr><td><code>front()</code></td><td>返回deque的第一个元素</td></tr><tr><td><code>back()</code></td><td>返回deque的最后一个元素</td></tr><tr><td><code>at()</code></td><td>返回指定位置的元素</td></tr><tr><td><code>size()</code></td><td>返回deque中元素的个数</td></tr><tr><td><code>empty()</code></td><td>检查deque是否为空</td></tr><tr><td><code>clear()</code></td><td>清空deque中的所有元素</td></tr><tr><td><code>erase()</code></td><td>删除指定位置或范围内的元素</td></tr><tr><td><code>insert()</code></td><td>在指定位置插入一个或多个元素</td></tr><tr><td><code>resize()</code></td><td>改变deque的大小</td></tr><tr><td><code>swap()</code></td><td>交换两个deque的内容</td></tr><tr><td><code>begin()</code></td><td>返回指向deque第一个元素的迭代器</td></tr><tr><td><code>end()</code></td><td>返回指向deque最后一个元素之后位置的迭代器</td></tr><tr><td><code>rbegin()</code></td><td>返回指向逆序（末尾）的第一个元素的迭代器</td></tr><tr><td><code>rend()</code></td><td>返回指向逆序（末尾）的最后一个元素之后位置的迭代器</td></tr></tbody></table><p>下面是一个基础使用deque的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; myDeque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到deque的尾部</span></span><br><span class="line">    myDeque.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    myDeque.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    myDeque.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素到deque的头部</span></span><br><span class="line">    myDeque.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">    myDeque.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问deque的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back element: &quot;</span> &lt;&lt; myDeque.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除deque的尾部元素</span></span><br><span class="line">    myDeque.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除deque的头部元素</span></span><br><span class="line">    myDeque.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历deque</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in deque:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myDeque.<span class="built_in">begin</span>(); it != myDeque.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查deque是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (myDeque.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Deque is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Deque is not empty. Size: &quot;</span> &lt;&lt; myDeque.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空deque</span></span><br><span class="line">    myDeque.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码演示了deque的基本用法。通过<code>push_back()</code>和<code>push_front()</code>方法可以在deque的尾部和头部插入元素，通过<code>pop_back()</code>和<code>pop_front()</code>方法可以删除尾部和头部的元素。<code>front()</code>和<code>back()</code>方法分别返回deque的第一个元素和最后一个元素。使用迭代器可以遍历deque中的元素。最后，通过<code>empty()</code>方法可以检查deque是否为空，通过<code>size()</code>方法可以获取deque中元素的个数。<code>clear()</code>方法用于清空deque中的所有元素。</p><h2 id="stack">stack</h2><p>在C++中，<code>std::stack</code> 是一个模板类，用于表示栈数据结构。它是基于一个底层容器实现的，通常使用<code>std::deque</code> 或 <code>std::list</code> 作为默认容器类型。栈遵循后进先出（LIFO）的原则，即最后插入的元素最先被移除。</p><p>下面是<code>std::stack</code> 的常用方法的图表，以及用代码演示的基础使用方式：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>push(const T&amp; value)</code></td><td>在栈顶插入一个元素</td></tr><tr><td><code>pop()</code></td><td>移除栈顶元素</td></tr><tr><td><code>top()</code></td><td>返回栈顶元素的引用</td></tr><tr><td><code>empty()</code></td><td>检查栈是否为空</td></tr><tr><td><code>size()</code></td><td>返回栈中元素的数量</td></tr></tbody></table><p>以下是一个示例代码，展示了如何使用<code>std::stack</code> 进行基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; myStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栈中插入元素</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素并打印</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; myStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除栈顶元素</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (myStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈中元素的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack size: &quot;</span> &lt;&lt; myStack.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Top</span> <span class="variable">element</span><span class="operator">:</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">Stack</span> <span class="variable">is</span> <span class="variable">not</span> <span class="variable">empty</span></span><br><span class="line"><span class="built_in">Stack</span> <span class="variable">size</span><span class="operator">:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个<code>std::stack</code> 对象 <code>myStack</code>，并使用<code>push()</code> 方法将三个元素插入栈中。然后，使用<code>top()</code> 方法获取栈顶元素并打印。接着，使用<code>pop()</code> 方法移除栈顶元素。最后，我们使用<code>empty()</code> 方法检查栈是否为空，并使用<code>size()</code> 方法获取栈中元素的数量。</p><h2 id="queue">queue</h2><p>在C++中，<code>std::queue</code> 是一个模板类，用于表示队列数据结构。它是基于一个底层容器实现的，通常使用<code>std::deque</code> 或 <code>std::list</code> 作为默认容器类型。队列遵循先进先出（FIFO）的原则，即最先插入的元素最先被移除。</p><p>下面是<code>std::queue</code> 的常用方法的图表，以及用代码演示的基础使用方式：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>push(const T&amp; value)</code></td><td>在队列尾部插入一个元素</td></tr><tr><td><code>pop()</code></td><td>移除队列头部元素</td></tr><tr><td><code>front()</code></td><td>返回队列头部元素的引用</td></tr><tr><td><code>back()</code></td><td>返回队列尾部元素的引用</td></tr><tr><td><code>empty()</code></td><td>检查队列是否为空</td></tr><tr><td><code>size()</code></td><td>返回队列中元素的数量</td></tr></tbody></table><p>以下是一个示例代码，展示了如何使用<code>std::queue</code> 进行基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在队列中插入元素</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列头部元素并打印</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Front element: &quot;</span> &lt;&lt; myQueue.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除队列头部元素</span></span><br><span class="line">    myQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列尾部元素并打印</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back element: &quot;</span> &lt;&lt; myQueue.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (myQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Queue is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Queue is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列中元素的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Queue size: &quot;</span> &lt;&lt; myQueue.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Front</span> element: <span class="number">1</span></span><br><span class="line"><span class="attribute">Back</span> element: <span class="number">3</span></span><br><span class="line"><span class="attribute">Queue</span> is not empty</span><br><span class="line"><span class="attribute">Queue</span> size: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个<code>std::queue</code> 对象 <code>myQueue</code>，并使用<code>push()</code> 方法将三个元素插入队列尾部。然后，使用<code>front()</code> 方法获取队列头部元素并打印。接着，使用<code>pop()</code> 方法移除队列头部元素。我们还使用<code>back()</code> 方法获取队列尾部元素并打印。最后，我们使用<code>empty()</code> 方法检查队列是否为空，并使用<code>size()</code> 方法获取队列中元素的数量。</p><h2 id="set">set</h2><p>在C++中，<code>std::set</code> 是一个模板类，用于表示集合数据结构。它是一个有序集合，其中每个元素都是唯一的。<code>std::set</code> 使用红黑树作为底层数据结构，确保元素的快速插入、查找和删除操作。</p><p>下面是<code>std::set</code> 的常用方法的图表，以及用代码演示的基础使用方式：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>insert(const T&amp; value)</code></td><td>在集合中插入一个元素</td></tr><tr><td><code>erase(const T&amp; value)</code></td><td>从集合中移除一个元素</td></tr><tr><td><code>find(const T&amp; value)</code></td><td>查找集合中是否存在指定的元素</td></tr><tr><td><code>empty()</code></td><td>检查集合是否为空</td></tr><tr><td><code>size()</code></td><td>返回集合中元素的数量</td></tr><tr><td><code>clear()</code></td><td>清空集合</td></tr></tbody></table><p>以下是一个示例代码，展示了如何使用<code>std::set</code> 进行基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在集合中插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> target = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; target &lt;&lt; <span class="string">&quot; found in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; target &lt;&lt; <span class="string">&quot; not found in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查集合是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (mySet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合中元素的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Set size: &quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空集合</span></span><br><span class="line">    mySet.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> found <span class="keyword">in</span> the <span class="keyword">set</span>.</span><br><span class="line"><span class="keyword">Set</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">empty</span></span><br><span class="line"><span class="keyword">Set</span> size: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个<code>std::set</code> 对象 <code>mySet</code>，并使用<code>insert()</code> 方法将三个元素插入集合中。然后，使用<code>find()</code> 方法查找指定的元素。接着，使用<code>erase()</code> 方法从集合中移除指定的元素。我们还使用<code>empty()</code> 方法检查集合是否为空，并使用<code>size()</code> 方法获取集合中元素的数量。最后，我们使用<code>clear()</code> 方法清空集合中的所有元素。</p><h2 id="map">map</h2><p>在C++中，<code>std::map</code> 是一个模板类，用于表示键值对的关联容器。它是基于红黑树实现的，其中的每个元素都由一个键和一个值组成。<code>std::map</code> 中的键是唯一的，且按照键的排序顺序进行存储。</p><p>下面是<code>std::map</code> 的常用方法的图表，以及用代码演示的基础使用方式：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>insert(const std::pair&lt;Key, Value&gt;&amp; pair)</code></td><td>在 map 中插入一个键值对</td></tr><tr><td><code>erase(const Key&amp; key)</code></td><td>从 map 中移除指定键的键值对</td></tr><tr><td><code>find(const Key&amp; key)</code></td><td>查找指定键的键值对</td></tr><tr><td><code>at(const Key&amp; key)</code></td><td>返回指定键对应的值</td></tr><tr><td><code>empty()</code></td><td>检查 map 是否为空</td></tr><tr><td><code>size()</code></td><td>返回 map 中键值对的数量</td></tr><tr><td><code>clear()</code></td><td>清空 map</td></tr></tbody></table><p>以下是一个示例代码，展示了如何使用<code>std::map</code> 进行基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 map 中插入键值对</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;John&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键值对</span></span><br><span class="line">    <span class="type">int</span> targetKey = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(targetKey);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value for key &quot;</span> &lt;&lt; targetKey &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key &quot;</span> &lt;&lt; targetKey &lt;&lt; <span class="string">&quot; not found in the map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除键值对</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 map 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (myMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Map is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Map is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 map 中键值对的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Map size: &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 map</span></span><br><span class="line">    myMap.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value <span class="keyword">for</span><span class="built_in"> key</span> <span class="number">2</span>: Alice</span><br><span class="line">Map <span class="literal">is</span><span class="built_in"> not</span><span class="built_in"> empty</span></span><br><span class="line">Map size: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个<code>std::map</code> 对象 <code>myMap</code>，并使用<code>insert()</code> 方法插入三个键值对。然后，使用<code>find()</code> 方法查找指定的键，并获取相应的值。接着，使用<code>erase()</code> 方法从 map 中移除指定的键值对。我们还使用<code>empty()</code> 方法检查 map 是否为空，并使用<code>size()</code> 方法获取 map 中键值对的数量。最后，我们使用<code>clear()</code> 方法清空 map 中的所有键值对。</p><h2 id="priority-queue">priority_queue</h2><p>在C++中，<code>std::priority_queue</code> 是一个模板类，用于表示优先队列数据结构。它是基于一个底层容器实现的，默认情况下使用<code>std::vector</code> 作为容器类型。优先队列根据元素的优先级进行排序，每次弹出的元素都是具有最高优先级的元素。</p><p>下面是<code>std::priority_queue</code> 的常用方法的图表，以及用代码演示的基础使用方式：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>push(const T&amp; value)</code></td><td>向优先队列中插入一个元素</td></tr><tr><td><code>pop()</code></td><td>从优先队列中移除具有最高优先级的元素</td></tr><tr><td><code>top()</code></td><td>返回具有最高优先级的元素的引用</td></tr><tr><td><code>empty()</code></td><td>检查优先队列是否为空</td></tr><tr><td><code>size()</code></td><td>返回优先队列中元素的数量</td></tr></tbody></table><p>以下是一个示例代码，展示了如何使用<code>std::priority_queue</code> 进行基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; myPriorityQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向优先队列中插入元素</span></span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    myPriorityQueue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取具有最高优先级的元素并打印</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; myPriorityQueue.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除具有最高优先级的元素</span></span><br><span class="line">    myPriorityQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查优先队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (myPriorityQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Priority queue is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Priority queue is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取优先队列中元素的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Priority queue size: &quot;</span> &lt;&lt; myPriorityQueue.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Top element: <span class="number">3</span></span><br><span class="line">Priority queue is <span class="keyword">not</span> empty</span><br><span class="line">Priority queue size: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个<code>std::priority_queue</code> 对象 <code>myPriorityQueue</code>，并使用<code>push()</code> 方法向优先队列中插入三个元素。然后，使用<code>top()</code> 方法获取具有最高优先级的元素并打印。接着，使用<code>pop()</code> 方法移除具有最高优先级的元素。我们还使用<code>empty()</code> 方法检查优先队列是否为空，并使用<code>size()</code> 方法获取优先队列中元素的数量。</p><h2 id="unordered-set">unordered_set</h2><p>在C++中，<code>std::unordered_set</code> 是一个模板类，用于表示无序集合数据结构。它基于哈希表实现，可以提供快速的插入、查找和删除操作。<code>std::unordered_set</code> 中的元素是唯一的，且没有特定的顺序。</p><p>下面是<code>std::unordered_set</code> 的常用方法的图表，以及用代码演示的基础使用方式：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>insert(const T&amp; value)</code></td><td>向无序集合中插入一个元素</td></tr><tr><td><code>erase(const T&amp; value)</code></td><td>从无序集合中移除一个元素</td></tr><tr><td><code>find(const T&amp; value)</code></td><td>查找无序集合中是否存在指定的元素</td></tr><tr><td><code>empty()</code></td><td>检查无序集合是否为空</td></tr><tr><td><code>size()</code></td><td>返回无序集合中元素的数量</td></tr><tr><td><code>clear()</code></td><td>清空无序集合</td></tr></tbody></table><p>以下是一个示例代码，展示了如何使用<code>std::unordered_set</code> 进行基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向无序集合中插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="type">int</span> target = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; target &lt;&lt; <span class="string">&quot; found in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; target &lt;&lt; <span class="string">&quot; not found in the set.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查无序集合是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (mySet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Set is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取无序集合中元素的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Set size: &quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空无序集合</span></span><br><span class="line">    mySet.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> found <span class="keyword">in</span> the <span class="keyword">set</span>.</span><br><span class="line"><span class="keyword">Set</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">empty</span></span><br><span class="line"><span class="keyword">Set</span> size: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个<code>std::unordered_set</code> 对象 <code>mySet</code>，并使用<code>insert()</code> 方法插入三个元素。然后，使用<code>find()</code> 方法查找指定的元素。接着，使用<code>erase()</code> 方法从无序集合中移除指定的元素。我们还使用<code>empty()</code> 方法检查无序集合是否为空，并使用<code>size()</code> 方法获取无序集合中元素的数量。最后，我们使用<code>clear()</code> 方法清空无序集合中的所有元素。</p><h2 id="unordered-map">unordered_map</h2><p>在C++中，<code>std::unordered_map</code> 是一个模板类，用于表示无序键值对的关联容器。它基于哈希表实现，可以提供快速的插入、查找和删除操作。<code>std::unordered_map</code> 中的键是唯一的，且没有特定的顺序。</p><p>下面是<code>std::unordered_map</code> 的常用方法的图表，以及用代码演示的基础使用方式：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>insert(const std::pair&lt;Key, Value&gt;&amp; pair)</code></td><td>向无序映射中插入一个键值对</td></tr><tr><td><code>erase(const Key&amp; key)</code></td><td>从无序映射中移除指定键的键值对</td></tr><tr><td><code>find(const Key&amp; key)</code></td><td>查找指定键的键值对</td></tr><tr><td><code>at(const Key&amp; key)</code></td><td>返回指定键对应的值</td></tr><tr><td><code>empty()</code></td><td>检查无序映射是否为空</td></tr><tr><td><code>size()</code></td><td>返回无序映射中键值对的数量</td></tr><tr><td><code>clear()</code></td><td>清空无序映射</td></tr></tbody></table><p>以下是一个示例代码，展示了如何使用<code>std::unordered_map</code> 进行基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向无序映射中插入键值对</span></span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;John&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    myMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键值对</span></span><br><span class="line">    <span class="type">int</span> targetKey = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(targetKey);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value for key &quot;</span> &lt;&lt; targetKey &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key &quot;</span> &lt;&lt; targetKey &lt;&lt; <span class="string">&quot; not found in the map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除键值对</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查无序映射是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (myMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Map is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Map is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取无序映射中键值对的数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Map size: &quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空无序映射</span></span><br><span class="line">    myMap.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value <span class="keyword">for</span><span class="built_in"> key</span> <span class="number">2</span>: Alice</span><br><span class="line">Map <span class="literal">is</span><span class="built_in"> not</span><span class="built_in"> empty</span></span><br><span class="line">Map size: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个<code>std::unordered_map</code> 对象 <code>myMap</code>，并使用<code>insert()</code> 方法插入三个键值对。然后，使用<code>find()</code> 方法查找指定的键，并获取相应的值。接着，使用<code>erase()</code> 方法从无序映射中移除指定的键值对。我们还使用<code>empty()</code> 方法检查无序映射是否为空，并使用</p><h1>多线程</h1><p>当在C++中使用多线程，可以使用标准库中的<code>&lt;thread&gt;</code>头文件和相关类来创建和管理线程。下面是一个简单的示例代码，演示了如何创建和使用多线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程并启动</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程执行其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先包含了<code>&lt;iostream&gt;</code>和<code>&lt;thread&gt;</code>头文件。然后定义了一个名为<code>threadFunction</code>的函数，这将作为我们要在新线程中执行的函数。函数简单地输出一条消息。</p><p>在<code>main</code>函数中，我们创建了一个<code>std::thread</code>对象<code>t</code>，并将其初始化为<code>threadFunction</code>。然后在主线程中输出另一条消息。最后，我们调用<code>join</code>函数等待线程<code>t</code>结束。</p><p>运行上面的代码，你将看到输出中交替出现了来自主线程和新线程的消息，表示两个线程在同时执行。</p><p>除了创建线程，C++标准库还提供了其他功能，如互斥量（<code>std::mutex</code>）、条件变量（<code>std::condition_variable</code>）和原子操作（<code>std::atomic</code>），以支持多线程之间的同步和通信。</p><p>需要注意的是，多线程编程需要仔细处理线程之间的同步和共享资源的访问，以避免竞态条件和数据损坏等问题。使用适当的同步机制来保护共享数据是至关重要的。</p><p>以上是一个简单的示例，展示了在C++中使用多线程的基本概念和代码结构。在实际应用中，多线程编程可能会更加复杂，需要考虑并发访问、线程安全性和性能等因素。</p><h2 id="多线程和锁">多线程和锁</h2><p>在C++中，线程和锁是用于实现并发编程和多线程同步的重要工具。C++标准库提供了<code>&lt;thread&gt;</code>头文件和<code>&lt;mutex&gt;</code>头文件来支持线程和锁的使用。</p><ol><li><p>线程（Thread）：</p><ul><li>创建线程：使用<code>std::thread</code>类来创建新线程。需要提供一个可调用的函数作为线程的入口点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myThreadFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 线程的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(myThreadFunction)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    myThread.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动线程：通过创建线程对象并调用其<code>join()</code>函数来启动线程。<code>join()</code>函数将等待线程执行完成。</li><li>线程同步：在线程间进行同步时，可以使用互斥量和条件变量等机制来确保线程安全和有序访问共享数据。</li></ul></li><li><p>互斥量（Mutex）：</p><ul><li>创建互斥量：使用<code>std::mutex</code>类来创建互斥量对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex myMutex; <span class="comment">// 创建互斥量对象</span></span><br></pre></td></tr></table></figure><ul><li>锁定互斥量：通过调用互斥量对象的<code>lock()</code>函数来锁定互斥量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMutex.<span class="built_in">lock</span>(); <span class="comment">// 锁定互斥量</span></span><br></pre></td></tr></table></figure><ul><li>解锁互斥量：通过调用互斥量对象的<code>unlock()</code>函数来解锁互斥量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myMutex.<span class="built_in">unlock</span>(); <span class="comment">// 解锁互斥量</span></span><br></pre></td></tr></table></figure></li><li><p>条件变量（Condition Variable）：</p><ul><li>创建条件变量：使用<code>std::condition_variable</code>类来创建条件变量对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable myConditionVariable; <span class="comment">// 创建条件变量对象</span></span><br></pre></td></tr></table></figure><ul><li>等待条件：通过调用条件变量对象的<code>wait()</code>函数在条件不满足时等待。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(myMutex)</span></span>;</span><br><span class="line">myConditionVariable.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> condition; &#125;); <span class="comment">// 等待条件满足</span></span><br></pre></td></tr></table></figure><ul><li>唤醒等待线程：通过调用条件变量对象的<code>notify_one()</code>或<code>notify_all()</code>函数来唤醒一个或所有等待线程。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myConditionVariable.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">myConditionVariable.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有等待线程</span></span><br></pre></td></tr></table></figure></li></ol><p>以上是线程和锁在C++中的基本用法示例。需要注意的是，线程编程和多线程同步涉及到复杂的并发编程概念和技术，如死锁、竞态条件等。为了正确且安全地使用线程和锁，在</p><h2 id="互斥量">互斥量</h2><p>互斥量（Mutex）是一种用于线程同步的机制，用于保护共享资源在多线程环境下的互斥访问。互斥量确保同一时间只有一个线程能够访问被保护的代码段或共享数据，从而避免了数据竞争和不一致的结果。</p><p>在C++中，使用<code>std::mutex</code>类来创建互斥量对象，并通过对互斥量的锁定和解锁来实现线程间的同步。</p><p><strong>使用互斥量来给方法加锁</strong></p><p>以下是互斥量的基本用法示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;  <span class="comment">// 创建互斥量对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharedResourceAccess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动锁定互斥量，并在作用域结束时自动解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里进行对共享资源的访问和操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥量会在作用域结束时自动解锁，即使出现异常也能保证解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(sharedResourceAccess)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(sharedResourceAccess)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，两个线程（<code>t1</code>和<code>t2</code>）同时访问<code>sharedResourceAccess()</code>函数中的共享资源。为了保证同时只有一个线程能够访问共享资源，使用了<code>std::mutex</code>对象<code>mtx</code>进行互斥访问的控制。</p><p>通过<code>std::lock_guard</code>类来锁定互斥量<code>mtx</code>，它会在构造时锁定互斥量，在作用域结束时自动解锁互斥量。这样可以确保在任意时刻只有一个线程能够获得互斥量的锁。</p><p>互斥量的使用有助于避免数据竞争和保护共享资源的完整性。当多个线程需要同时访问共享资源时，通过对互斥量的加锁和解锁，可以确保每次只有一个线程在访问共享资源，从而避免了不一致的结果和竞态条件。</p><p>需要注意的是，互斥量应该被合理地使用，避免过多的锁定和长时间的占用，以减少线程之间的竞争和提高并发性能。同时，也需要注意避免死锁的情况，即多个线程互相等待对方释放锁导致无法继续执行的情况。</p><h2 id="不同方法中使用同一个互斥量">不同方法中使用同一个互斥量</h2><p><strong>例如：在对一个数进行加和减的两个方法中，使用同一个互斥量</strong></p><p>是的，可以在不同方法中使用同一个互斥量进行加锁。</p><p>互斥量可以在多个方法（函数）之间共享，并用于实现跨方法的线程同步。通过在多个方法中使用同一个互斥量，可以确保在任意时刻只有一个线程能够访问被保护的共享资源。</p><p>以下是一个示例，展示了在不同方法中使用同一个互斥量进行加锁的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 创建互斥量对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 执行需要保护的代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 执行需要保护的代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建多个线程调用不同的方法</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(method1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(method2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>method1()</code>和<code>method2()</code>方法都使用了同一个互斥量对象<code>mtx</code>进行加锁。无论是在<code>method1()</code>还是<code>method2()</code>中，只有一个线程能够获取互斥量的锁，并执行需要保护的代码块。</p><p>通过在不同方法中使用同一个互斥量，可以实现不同方法之间的线程同步，保护共享资源的访问安全。</p><p>需要注意的是，在使用同一个互斥量进行加锁时，需要注意避免死锁的情况。死锁可能发生在多个线程之间循环等待对方所持有的锁。因此，确保在不同方法中获取锁的顺序保持一致，并避免在持有锁的情况下调用可能会再次获取同一个锁的方法，可以帮助避免死锁的发生。</p><h1>C++补充</h1><h2 id="友元函数">友元函数</h2>]]></content>
    
    
    <summary type="html">🥧本文汇总C++的内存、引用、文件操作、模板、STL、多线程等核心编程部分</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://momoao.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://momoao.github.io/posts/202308310902.html"/>
    <id>https://momoao.github.io/posts/202308310902.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-31T01:05:06.940Z</updated>
    
    <content type="html"><![CDATA[<h1>Java基础</h1><h1>AI整理</h1><h2 id="Java8及之后版本的更新内容">Java8及之后版本的更新内容</h2><p>Java 8 ：</p><p>Java 8于2014年发布,包含了很多重要的新特性:</p><ul><li><p>Lambda表达式 - 允许将函数作为一个方法的参数(函数作为第一类对象)。让代码更加简洁。</p></li><li><p>Stream API - 新添加的流操作,可以对数据进行管道操作。</p></li><li><p>方法引用 - 直接引用已有Java方法或构造器,比Lambda表达式更简洁。</p></li><li><p>Optional类 - 用于避免NullPointerException。</p></li><li><p>Nashorn引擎 - 允许在JVM上运行JS应用。</p></li><li><p>新时间和日期API - 加强对时间、日期、时区的处理。</p></li><li><p>默认接口方法 - 接口可以有默认实现方法。</p></li><li><p>重复注解 - 支持在同一个地方多次使用同一个注解。</p></li><li><p>Type Annotations - 支持编译时注解。</p></li><li><p>Nashorn引擎 - JS运行环境。</p></li><li><p>新的JVM执行参数 - PermGen空间被移除,新的元空间。</p></li><li><p>ParallelArraySort - 多核并行数组排序。</p></li><li><p>批量数据操作 - 接口如Collection批量操作。</p></li><li><p>Base64编码 - java.util.Base64新支持。</p></li><li><p>并发性能改进 - 如直到长时间计算完成才唤醒线程。</p></li></ul><p>Java 8让Java语言表达能力大大增强,编程体验更好,对现代多核CPU架构进行了优化,也改进了在Lambda方面的缺陷。</p><p>Java 9:</p><ul><li>引入模块系统(Jigsaw项目),Java平台内部实现了模块化</li><li>JShell:交互式Java shell</li><li>多版本兼容Jar包</li><li>Try-With-Resources增强</li><li>新HTTP Client API</li></ul><p>Java 10:</p><ul><li>局部变量类型推断(var关键字)</li><li>G1成为默认垃圾收集器</li><li>线程本地握手API</li><li>Unmodifiable集合增加复制支持</li></ul><p>Java 11:</p><ul><li>增强var的使用范围</li><li>标准HTTP Client API</li><li>本地变量语法改进</li><li>ZGC实验性垃圾收集器加入</li></ul><p>Java 12:</p><ul><li>Switch表达式</li><li>文本块 literals</li><li>增强垃圾收集器G1</li><li>JVM常量API</li></ul><p>Java 13:</p><ul><li>Text Blocks第二预览</li><li>Switch表达式增强</li><li>Socket API增强</li></ul><p>Java 14:</p><ul><li>Switch表达式标准化</li><li>查看隐藏类</li><li>records 预览</li><li>NullPointerException信息增强</li></ul><p>Java 15:</p><ul><li>Text Blocks正式发布</li><li>Sealed Classes密封类预览</li><li>Hidden Classes正式发布</li><li>Removal of Nashorn JavaScript Engine</li></ul><p>Java 16:</p><ul><li>Records正式发布</li><li>Pattern Matching预览</li><li>Packaging Tool (jpackage)正式发布</li></ul><p>Java 17:</p><ul><li>Pattern Matching第二预览</li><li>Foreign Memory Access API<br>-移除垃圾收集器ZGC和Shenandoah</li></ul><p>Java 18:</p><ul><li>Pattern Matching for switch正式发布</li><li>Vector API (第二季度)</li><li>数据类正式发布</li></ul><p>Java 19:</p><ul><li>Vector API 正式发布</li><li>文本块3.0</li><li>由val关键字引入的更轻量级记录</li><li>增强式的pattern matching</li></ul><p>总体来看,新版本增加了很多对程序员友好的语言特性,以及模块化、内存访问、垃圾收集器、文本处理等方面的改进。使Java的编程体验更加高效和便捷。</p>]]></content>
    
    
    <summary type="html">🥧本文汇总Java的基础知识</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://momoao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://momoao.github.io/posts/202308241944.html"/>
    <id>https://momoao.github.io/posts/202308241944.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-25T12:43:12.766Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis</h1><p>Remote Dictionary Server</p><h1>GPT</h1><h2 id="基础指令">基础指令</h2><p>Redis是一个开源的高性能键值存储数据库，支持各种数据结构，如字符串、哈希表、列表、集合、有序集合等。它提供了丰富的命令集，用于操作和管理存储在Redis中的数据。以下是一些Redis的基本指令：</p><ol><li><p><strong>字符串操作</strong>：</p><ul><li><code>SET key value</code>: 设置指定键的值。</li><li><code>GET key</code>: 获取指定键的值。</li><li><code>DEL key</code>: 删除指定键及其值。</li><li><code>EXISTS key</code>: 检查键是否存在。</li></ul></li><li><p><strong>哈希表操作</strong>：</p><ul><li><code>HSET key field value</code>: 设置指定哈希表中字段的值。</li><li><code>HGET key field</code>: 获取指定哈希表中字段的值。</li><li><code>HDEL key field [field ...]</code>: 删除指定哈希表中的一个或多个字段。</li><li><code>HGETALL key</code>: 获取指定哈希表的所有字段和值。</li></ul></li><li><p><strong>列表操作</strong>：</p><ul><li><code>LPUSH key value [value ...]</code>: 将一个或多个值插入到列表的头部。</li><li><code>RPUSH key value [value ...]</code>: 将一个或多个值插入到列表的尾部。</li><li><code>LPOP key</code>: 弹出并返回列表的头部元素。</li><li><code>RPOP key</code>: 弹出并返回列表的尾部元素。</li><li><code>LRANGE key start stop</code>: 获取列表指定范围的元素。</li></ul></li><li><p><strong>集合操作</strong>：</p><ul><li><code>SADD key member [member ...]</code>: 将一个或多个元素添加到集合。</li><li><code>SMEMBERS key</code>: 获取集合中的所有元素。</li><li><code>SREM key member [member ...]</code>: 从集合中删除一个或多个元素。</li><li><code>SINTER key [key ...]</code>: 获取多个集合的交集。</li></ul></li><li><p><strong>有序集合操作</strong>：</p><ul><li><code>ZADD key score member [score member ...]</code>: 将一个或多个带有分数的元素添加到有序集合。</li><li><code>ZRANGE key start stop [WITHSCORES]</code>: 获取有序集合指定范围的元素。</li><li><code>ZREM key member [member ...]</code>: 从有序集合中删除一个或多个元素。</li><li><code>ZCOUNT key min max</code>: 获取有序集合指定分数范围内的元素数量。</li></ul></li><li><p><strong>其他常用指令</strong>：</p><ul><li><code>PING</code>: 检测Redis服务器是否运行。</li><li><code>SELECT index</code>: 切换到指定数据库。</li><li><code>FLUSHDB</code>: 清空当前数据库的所有键。</li><li><code>FLUSHALL</code>: 清空所有数据库的所有键。</li></ul></li></ol><p>这只是Redis提供的一小部分基本指令，Redis还有很多其他的高级指令和功能，如事务、发布订阅、持久化、过期时间等。请参考Redis官方文档或相关教程以了解更多详细信息和用法。</p>]]></content>
    
    
    <summary type="html">🥧本文汇总Redis的安装和使用</summary>
    
    
    
    <category term="数据库" scheme="https://momoao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://momoao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>QT飞机大战源码</title>
    <link href="https://momoao.github.io/posts/202308241942.html"/>
    <id>https://momoao.github.io/posts/202308241942.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-25T12:43:05.626Z</updated>
    
    <content type="html"><![CDATA[<h1>QT 飞机大战源码</h1><h2 id="头文件">头文件</h2><h3 id="bomb-h">bomb.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOMB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOMB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bomb</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bomb</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新信息（播放图片下标、播放间隔）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放爆炸资源数组</span></span><br><span class="line">    QVector&lt;QPixmap&gt; m_pixArr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//爆炸位置</span></span><br><span class="line">    <span class="type">int</span> m_X;</span><br><span class="line">    <span class="type">int</span> m_Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//爆炸切图的时间间隔</span></span><br><span class="line">    <span class="type">int</span> m_Recoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//爆炸时加载的图片下标</span></span><br><span class="line">    <span class="type">int</span> m_index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空闲状态记录</span></span><br><span class="line">    <span class="type">bool</span> m_Free;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BOMB_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="bullet-h">bullet.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BULLET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BULLET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bullet</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bullet</span>();</span><br><span class="line">    \</span><br><span class="line">    <span class="comment">//更新子弹坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePosition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹的图片</span></span><br><span class="line">    QPixmap m_Bullet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹的坐标</span></span><br><span class="line">    <span class="type">int</span> m_X;</span><br><span class="line">    <span class="type">int</span> m_Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹的速度</span></span><br><span class="line">    <span class="type">int</span> m_Speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹是否闲置</span></span><br><span class="line">    <span class="type">bool</span> m_Free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹的碰撞体积</span></span><br><span class="line">    QRect m_Rect;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BULLET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="config-h">config.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*          游戏窗口  资源加载          */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GAME_WIDTH 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GAME_HEIGHT 768</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GAME_TITLE <span class="string">&quot;飞机大战 v1.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GAME_RES_PATH <span class="string">&quot;PlaneWar/plane.rcc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GAME_ICON <span class="string">&quot;:/res/Hero1.png&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GAME_RATE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*          地图配置                   */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_PATH <span class="string">&quot;:/res/background.png&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SCROLL_SPEED 2  <span class="comment">//地图滚动速度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*          飞机配置                    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HERO_PATH <span class="string">&quot;:/res/Hero1.png&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*          子弹配置                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BULLET_PATH <span class="string">&quot;:/res/bullet.png&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BULLET_SPEED 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BULLET_NUM 30   <span class="comment">//子弹数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BULLET_INTERVAL 20  <span class="comment">//子弹发射间隔，因为画面重绘间隔是10，所以子弹发射间隔每10毫秒+1，加到20时发射子弹</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*          敌机相关配置          */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEMY_PATH <span class="string">&quot;:/res/airplane.png&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEMY_SPEED 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEMY_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEMY_INTERVAL 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*          爆炸配置                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOMB_PATH <span class="string">&quot;:/res/airplane_ember%1&quot;</span>  <span class="comment">//%1是占位符，可以用 QString(BOMB_PATH).arg(i)进行补位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOMB_NUM 20     <span class="comment">//爆炸数量（需要使用这个爆炸动画的敌机数量）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOMB_MAX 3      <span class="comment">//爆炸动画一共多少图片啊</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOMB_INTERVAL 20    <span class="comment">//爆炸图片切换间隔</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*           音效配置           */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOUND_BACKGROUD <span class="string">&quot;:/res/bk.wav&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOUND_BOMB <span class="string">&quot;:/res/bit.wav&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CONFIG_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="enemyplane-h">enemyplane.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ENEMYPLANE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEMYPLANE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRect&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnemyPlane</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EnemyPlane</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePosition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//敌机图片</span></span><br><span class="line">    QPixmap m_enemy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//位置</span></span><br><span class="line">    <span class="type">int</span> m_X;</span><br><span class="line">    <span class="type">int</span> m_Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌机的矩形边框</span></span><br><span class="line">    QRect m_Rect;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态，是否闲置</span></span><br><span class="line">    <span class="type">bool</span> m_Free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//速度</span></span><br><span class="line">    <span class="type">int</span> m_Speed;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ENEMYPLANE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="heroplane-h">heroplane.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEROPLANE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEROPLANE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bullet.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroPlane</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HeroPlane</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发射子弹</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shoot</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置飞机坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPosition</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//存储英雄飞机图片</span></span><br><span class="line">    QPixmap m_Plane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//射击间隔记录</span></span><br><span class="line">    <span class="type">int</span> m_recorder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹夹</span></span><br><span class="line">    Bullet m_Bullets[BULLET_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//飞机的坐标</span></span><br><span class="line">    <span class="type">int</span> m_X;</span><br><span class="line">    <span class="type">int</span> m_Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//英雄飞机碰撞箱</span></span><br><span class="line">    QRect m_Rect;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEROPLANE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mainscene-h">mainscene.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINSCENE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINSCENE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Bullet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heroplane.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;enemyplane.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bomb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainScene</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainScene</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainScene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化场景</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initScene</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动游戏</span></span><br><span class="line">    <span class="comment">//更新游戏中所有元素的坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制到屏幕中        这个函数名称必须是这个，不能改</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新所有元素坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePosition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写鼠标移动时间  函数名称不能变</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent * event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//地图对象</span></span><br><span class="line">    Map m_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//飞机对象</span></span><br><span class="line">    HeroPlane m_hero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    QTimer m_Timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌机出场</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enemyToScene</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌机数组</span></span><br><span class="line">    EnemyPlane m_enemys[ENEMY_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌机出场间隔</span></span><br><span class="line">    <span class="type">int</span> m_recorder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞检测</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">collisionDetection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//爆炸数组</span></span><br><span class="line">    Bomb m_bombs[BOMB_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试用的子弹对象</span></span><br><span class="line">    <span class="comment">//Bullet temp_Bullet;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINSCENE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map-h">map.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//地图滚动至坐标计算</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mapPosition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//地图图片对象</span></span><br><span class="line">    QPixmap m_map1;</span><br><span class="line">    QPixmap m_map2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//地图Y轴坐标</span></span><br><span class="line">    <span class="type">int</span> m_map1_posY;</span><br><span class="line">    <span class="type">int</span> m_map2_posY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//地图滚动速度</span></span><br><span class="line">    <span class="type">int</span> m_scroll_speed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAP_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="源文件">源文件</h2><h3 id="bomb-cpp">bomb.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bomb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Bomb::<span class="built_in">Bomb</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将所有爆炸的pixmap放在向量中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BOMB_MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QString str= <span class="built_in">QString</span>(BOMB_PATH).<span class="built_in">arg</span>(i);</span><br><span class="line">        m_pixArr.<span class="built_in">push_back</span>(<span class="built_in">QPixmap</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//坐标</span></span><br><span class="line">    m_X=<span class="number">0</span>;</span><br><span class="line">    m_Y=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空闲状态</span></span><br><span class="line">    m_Free=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前播放的图片下标</span></span><br><span class="line">    m_index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//播放爆炸的间隔</span></span><br><span class="line">    m_Recoder=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bomb::updateInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//空闲状态下的直接return</span></span><br><span class="line">    <span class="keyword">if</span>(m_Free)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_Recoder++;</span><br><span class="line">    <span class="keyword">if</span>(m_Recoder &lt; BOMB_INTERVAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果爆炸</span></span><br><span class="line">    m_Recoder=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换爆炸播放图片的下标</span></span><br><span class="line">    m_index++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果爆炸播放完毕</span></span><br><span class="line">    <span class="keyword">if</span>(m_index &gt; BOMB_MAX<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_index=<span class="number">0</span>;</span><br><span class="line">        m_Free=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="bullet-cpp">bullet.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bullet.h&quot;</span>9</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heroplane.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Bullet::<span class="built_in">Bullet</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加载子弹资源</span></span><br><span class="line">    m_Bullet.<span class="built_in">load</span>(BULLET_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹的坐标</span></span><br><span class="line">   <span class="comment">// m_X = ;</span></span><br><span class="line">    m_Y = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹初始是闲置的</span></span><br><span class="line">    m_Free = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从配置文件初始化子弹速度</span></span><br><span class="line">    m_Speed = BULLET_SPEED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化碰撞体积坐标</span></span><br><span class="line">    m_Rect.<span class="built_in">setWidth</span>(m_Bullet.<span class="built_in">width</span>());</span><br><span class="line">    m_Rect.<span class="built_in">setHeight</span>(m_Bullet.<span class="built_in">height</span>());</span><br><span class="line">    m_Rect.<span class="built_in">moveTo</span>(m_X,m_Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bullet::updatePosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果是闲置的就不需要坐标更新</span></span><br><span class="line">    <span class="keyword">if</span>(m_Free)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//坐标更新</span></span><br><span class="line">    m_Y-=m_Speed;</span><br><span class="line">    m_Rect.<span class="built_in">moveTo</span>(m_X,m_Y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹超出屏幕，子弹变为空闲</span></span><br><span class="line">    <span class="keyword">if</span>(m_Y &lt;= - m_Bullet.<span class="built_in">height</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_Free = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="enemyplane-cpp">enemyplane.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;enemyplane.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">EnemyPlane::<span class="built_in">EnemyPlane</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//敌机资源加载</span></span><br><span class="line">    m_enemy.<span class="built_in">load</span>(ENEMY_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌机的位置</span></span><br><span class="line">    m_X=<span class="number">0</span>;</span><br><span class="line">    m_Y=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌机状态</span></span><br><span class="line">    m_Free = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//敌机速度</span></span><br><span class="line">    m_Speed = ENEMY_SPEED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置碰撞箱</span></span><br><span class="line">    m_Rect.<span class="built_in">setWidth</span>(m_enemy.<span class="built_in">width</span>());</span><br><span class="line">    m_Rect.<span class="built_in">setHeight</span>(m_enemy.<span class="built_in">height</span>());</span><br><span class="line">    m_Rect.<span class="built_in">moveTo</span>(m_X,m_Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnemyPlane::updatePosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//空闲状体就不变化</span></span><br><span class="line">    <span class="keyword">if</span>(m_Free)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//坐标变化</span></span><br><span class="line">    m_Y += m_Speed;</span><br><span class="line">    m_Rect.<span class="built_in">moveTo</span>(m_X,m_Y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超出屏幕就变为闲置</span></span><br><span class="line">    <span class="keyword">if</span>(m_Y &gt;= GAME_HEIGHT + m_Rect.<span class="built_in">height</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_Free=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="heroplane-cpp">heroplane.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heroplane.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">HeroPlane::<span class="built_in">HeroPlane</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加载飞机图片资源</span></span><br><span class="line">    m_Plane.<span class="built_in">load</span>(HERO_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化飞机坐标</span></span><br><span class="line">    m_X = (GAME_WIDTH - m_Plane.<span class="built_in">width</span>()) * <span class="number">0.5</span>;</span><br><span class="line">    m_Y = GAME_HEIGHT - m_Plane.<span class="built_in">height</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化矩形边框</span></span><br><span class="line">    m_Rect.<span class="built_in">setWidth</span>(m_Plane.<span class="built_in">width</span>());</span><br><span class="line">    m_Rect.<span class="built_in">setHeight</span>(m_Plane.<span class="built_in">height</span>());</span><br><span class="line">    m_Rect.<span class="built_in">moveTo</span>(m_X,m_Y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeroPlane::shoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//累加时间间隔</span></span><br><span class="line">    m_recorder++;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;m_recorder&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果记录的间隔没达到设置的间隔，不进行发射子弹</span></span><br><span class="line">    <span class="keyword">if</span>(m_recorder&lt;BULLET_INTERVAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发射子弹</span></span><br><span class="line">    m_recorder = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; BULLET_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_Bullets[i].m_Free==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将空闲状态改为 false</span></span><br><span class="line">            m_Bullets[i].m_Free=<span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//设置发射坐标</span></span><br><span class="line">            m_Bullets[i].m_X = m_X+m_Plane.<span class="built_in">width</span>()/<span class="number">2</span>- m_Bullets[i].m_Bullet.<span class="built_in">width</span>()/<span class="number">2</span>;</span><br><span class="line">            m_Bullets[i].m_Y = m_Y+m_Bullets[i].m_Bullet.<span class="built_in">height</span>()/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;&quot;&quot;&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeroPlane::setPosition</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_X=x;</span><br><span class="line">    m_Y=y;</span><br><span class="line">    m_Rect.<span class="built_in">moveTo</span>(m_X,m_Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="main-cpp">main.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainscene.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QResource&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册二进制文件信息</span></span><br><span class="line">    <span class="comment">//QResource::registerResource(GAME_RES_PATH);</span></span><br><span class="line"></span><br><span class="line">    MainScene w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mainscene-cpp">mainscene.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainscene.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QIcon&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMediaPlayer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSoundEffect&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">MainScene::<span class="built_in">MainScene</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化场景</span></span><br><span class="line">    <span class="built_in">initScene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动游戏</span></span><br><span class="line">    <span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainScene::~<span class="built_in">MainScene</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::initScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置窗口固定尺寸</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(GAME_WIDTH,GAME_HEIGHT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(GAME_TITLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载图标</span></span><br><span class="line">    <span class="built_in">setWindowIcon</span>(<span class="built_in">QIcon</span>(GAME_ICON));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器初始化</span></span><br><span class="line">    m_Timer.<span class="built_in">setInterval</span>(GAME_RATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    QSoundEffect * startSound = new QSoundEffect(this);</span></span><br><span class="line"><span class="comment">//    startSound-&gt;setSource(QUrl::fromLocalFile(SOUND_BACKGROUD));</span></span><br><span class="line"><span class="comment">//    startSound-&gt;play();</span></span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    m_Timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听监听器发送的信号</span></span><br><span class="line">    <span class="comment">//（哪个监听器，时间到了发送什么信号，用方法处理）</span></span><br><span class="line">    <span class="built_in">connect</span>(&amp;m_Timer,&amp;QTimer::timeout,[=]()&#123;</span><br><span class="line">        <span class="comment">//敌机出场</span></span><br><span class="line">        <span class="built_in">enemyToScene</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//碰撞检测</span></span><br><span class="line">        <span class="built_in">collisionDetection</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新游戏中所有元素的坐标</span></span><br><span class="line">        <span class="built_in">updatePosition</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制到屏幕上</span></span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个画家，指定在哪个类中</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制地图</span></span><br><span class="line">    <span class="comment">//(x坐标，y坐标，QPixmap对象)</span></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,m_map.m_map1_posY,m_map.m_map1);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,m_map.m_map2_posY,m_map.m_map2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制英雄飞机</span></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(m_hero.m_X,m_hero.m_Y,m_hero.m_Plane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制子弹</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;BULLET_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果非空闲就绘制</span></span><br><span class="line">        <span class="keyword">if</span>(m_hero.m_Bullets[i].m_Free==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPixmap</span>(m_hero.m_Bullets[i].m_X,m_hero.m_Bullets[i].m_Y,m_hero.m_Bullets[i].m_Bullet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制敌机</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;ENEMY_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_enemys[i].m_Free == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPixmap</span>(m_enemys[i].m_X, m_enemys[i].m_Y,m_enemys[i].m_enemy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制爆炸</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BOMB_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_bombs[i].m_Free == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            painter.<span class="built_in">drawPixmap</span>(m_bombs[i].m_X,m_bombs[i].m_Y,m_bombs[i].m_pixArr[m_bombs[i].m_index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制测试子弹</span></span><br><span class="line">    <span class="comment">//painter.drawPixmap(temp_Bullet.m_X,temp_Bullet.m_Y,temp_Bullet.m_Bullet);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::updatePosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//地图坐标更新</span></span><br><span class="line">    m_map.<span class="built_in">mapPosition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发射子弹</span></span><br><span class="line">    m_hero.<span class="built_in">shoot</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算子弹坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;BULLET_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_hero.m_Bullets[i].<span class="built_in">updatePosition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算敌机坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;ENEMY_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        m_enemys[i].<span class="built_in">updatePosition</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算爆炸的播放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;BOMB_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_bombs[i].m_Free == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_bombs[i].<span class="built_in">updateInfo</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试子弹的坐标更新</span></span><br><span class="line">    <span class="comment">//temp_Bullet.m_Free = false;</span></span><br><span class="line">    <span class="comment">//temp_Bullet.updatePosition();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::mouseMoveEvent</span><span class="params">(QMouseEvent * event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x= event-&gt;<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">int</span> y=event-&gt;<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x &lt;=m_hero.m_Plane.<span class="built_in">width</span>()/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=m_hero.m_Plane.<span class="built_in">width</span>()/<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x&gt;=GAME_WIDTH-m_hero.m_Plane.<span class="built_in">width</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x=GAME_WIDTH - m_hero.m_Plane.<span class="built_in">width</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y&lt;=m_hero.m_Plane.<span class="built_in">height</span>()/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y=m_hero.m_Plane.<span class="built_in">height</span>()/<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y&gt;=GAME_HEIGHT-m_hero.m_Plane.<span class="built_in">height</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        y=GAME_HEIGHT-m_hero.m_Plane.<span class="built_in">height</span>()/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m_hero.<span class="built_in">setPosition</span>(x-m_hero.m_Plane.<span class="built_in">width</span>()/<span class="number">2</span>,y-m_hero.m_Plane.<span class="built_in">height</span>()/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::enemyToScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    m_recorder++;</span><br><span class="line">    <span class="comment">//未达到出场间隔，直接return</span></span><br><span class="line">    <span class="keyword">if</span>(m_recorder &lt; ENEMY_INTERVAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_recorder=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ENEMY_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//空闲敌机出场</span></span><br><span class="line">        <span class="keyword">if</span>(m_enemys[i].m_Free == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_enemys[i].m_Free =<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//坐标</span></span><br><span class="line">            m_enemys[i].m_X=<span class="built_in">rand</span>()%(GAME_WIDTH - m_enemys[i].m_enemy.<span class="built_in">width</span>());</span><br><span class="line">            m_enemys[i].m_Y=- m_enemys[i].m_enemy.<span class="built_in">height</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainScene::collisionDetection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历所有非空闲敌机</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ENEMY_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果空闲，就跳过检测下一个</span></span><br><span class="line">        <span class="keyword">if</span>(m_enemys[i].m_Free)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有非空闲子弹</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;BULLET_NUM;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果空闲检测下一个子弹</span></span><br><span class="line">            <span class="keyword">if</span>(m_hero.m_Bullets[j].m_Free)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//检测敌机是否与子弹碰撞</span></span><br><span class="line">            <span class="keyword">if</span>(m_enemys[i].m_Rect.<span class="built_in">intersects</span>(m_hero.m_Bullets[j].m_Rect))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//碰撞了</span></span><br><span class="line">                m_hero.m_Bullets[j].m_Free=<span class="literal">true</span>;</span><br><span class="line">                m_enemys[i].m_Free=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//爆炸效果</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt; BOMB_NUM;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//找一个空闲的爆炸</span></span><br><span class="line">                    <span class="keyword">if</span>(m_bombs[k].m_Free)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//播放爆炸音效</span></span><br><span class="line"><span class="comment">//                        QMediaPlayer mediaPlayer;</span></span><br><span class="line"><span class="comment">//                        mediaPlayer.setSource(QUrl::fromLocalFile(SOUND_BOMB));</span></span><br><span class="line"><span class="comment">//                        mediaPlayer.set</span></span><br><span class="line"><span class="comment">//                        mediaPlayer.play();</span></span><br><span class="line"></span><br><span class="line">                        QSoundEffect * startSound = <span class="keyword">new</span> <span class="built_in">QSoundEffect</span>(<span class="keyword">this</span>);</span><br><span class="line">                        startSound-&gt;<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(SOUND_BOMB));</span><br><span class="line">                        startSound-&gt;<span class="built_in">play</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//改为非空闲</span></span><br><span class="line">                        m_bombs[k].m_Free=<span class="literal">false</span>;</span><br><span class="line">                        <span class="comment">//更新爆炸坐标</span></span><br><span class="line">                        m_bombs[k].m_X=m_enemys[i].m_X;</span><br><span class="line">                        m_bombs[k].m_Y=m_enemys[i].m_Y;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map-cpp">map.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Map::<span class="built_in">Map</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化地图</span></span><br><span class="line">    m_map1.<span class="built_in">load</span>(MAP_PATH);</span><br><span class="line">    m_map2.<span class="built_in">load</span>(MAP_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化Y轴坐标</span></span><br><span class="line">    m_map1_posY = -GAME_HEIGHT;</span><br><span class="line">    m_map2_posY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//地图滚动速度</span></span><br><span class="line">    m_scroll_speed = MAP_SCROLL_SPEED;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Map::mapPosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理第一张图片的滚动位置</span></span><br><span class="line">    m_map1_posY += m_scroll_speed;</span><br><span class="line">    <span class="keyword">if</span>(m_map1_posY &gt;=GAME_HEIGHT)</span><br><span class="line">    &#123;</span><br><span class="line">        m_map1_posY = -GAME_HEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理第二张图片的滚动位置</span></span><br><span class="line">    m_map2_posY += m_scroll_speed;</span><br><span class="line">    <span class="keyword">if</span>(m_map2_posY &gt;=GAME_HEIGHT)</span><br><span class="line">    &#123;</span><br><span class="line">        m_map2_posY = -GAME_HEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧使用QT写的飞机大战的纯源码</summary>
    
    
    
    <category term="源码" scheme="https://momoao.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="C++" scheme="https://momoao.github.io/tags/C/"/>
    
    <category term="QT" scheme="https://momoao.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="https://momoao.github.io/posts/202308241921.html"/>
    <id>https://momoao.github.io/posts/202308241921.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-30T09:46:58.634Z</updated>
    
    <content type="html"><![CDATA[<h1>Shell编程</h1><h1>Shell常见的五种类型</h1><h2 id="五种类型讲解">五种类型讲解</h2><p>在Unix和类Unix系统中，常见的五种Shell类型是Bourne Shell (sh)，Bourne Again Shell (bash)，C Shell (csh)，Korn Shell (ksh)，和 Z Shell (zsh)。这些Shell之间有一些区别，主要涉及以下方面：</p><ol><li><p><strong>功能和语法</strong>：</p><ul><li>Bourne Shell (sh)：是最早的Unix Shell，功能相对较少，语法相对简单，缺乏一些现代Shell的特性。</li><li>Bourne Again Shell (bash)：是Bourne Shell的改进版本，是大多数Linux系统的默认Shell。它保留了Bourne Shell的特性，并添加了许多额外的功能和命令，提供更好的用户体验和编程能力。</li><li>C Shell (csh)：语法与C语言类似，支持用C风格的语法编写Shell脚本。有一些方便的特性，但在脚本编程方面不如bash灵活。</li><li>Korn Shell (ksh)：由David Korn设计，综合了Bourne Shell和C Shell的特性，提供了更多的编程特性和命令。</li><li>Z Shell (zsh)：在功能上扩展了bash和ksh，并引入了许多新特性和改进。它强调交互式使用，提供更好的命令补全、主题和插件支持。</li></ul></li><li><p><strong>交互式使用</strong>：</p><ul><li>zsh在交互式使用方面较其他Shell更强大，提供更多的便利功能和自定义选项。</li></ul></li><li><p><strong>兼容性</strong>：</p><ul><li>bash和sh具有较高的兼容性，几乎在所有Unix系统中都可以找到。</li><li>csh在某些系统上可能不可用，也不太适合编写复杂的脚本。</li><li>zsh在大多数现代系统上都可用，但可能需要单独安装。</li></ul></li><li><p><strong>默认Shell</strong>：</p><ul><li>大多数Linux系统使用bash作为默认Shell。</li><li>macOS使用zsh作为默认Shell。</li></ul></li><li><p><strong>可编程性</strong>：</p><ul><li>bash、ksh和zsh都提供强大的编程功能，可以编写复杂的Shell脚本。</li><li>csh在编程方面相对较弱，更适合作为交互式Shell使用。</li></ul></li></ol><p>总体而言，如果你只是需要一个用于简单任务和交互式使用的Shell，bash或zsh可能是更好的选择。如果你需要更高级的Shell编程功能，可以选择bash、ksh或zsh中的任何一个，具体取决于你对特定功能的需求和个人偏好。</p><h2 id="bash和zsh">bash和zsh</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大多数Linux系统使用bash作为默认<span class="keyword">Shell</span><span class="language-bash">。</span></span><br><span class="line">macOS使用zsh作为默认<span class="keyword">Shell</span><span class="language-bash">。</span></span><br></pre></td></tr></table></figure><p>Zsh（Z Shell）和Bash（Bourne Again Shell）是两种功能强大的Unix Shell，它们在很多方面相似，但也有一些不同之处。下面是它们各自的优缺点：</p><p><strong>Zsh的优点：</strong></p><ol><li><p><strong>更强大的自动补全</strong>：Zsh提供更高级的命令补全功能，可以根据命令历史和路径自动补全命令、文件名和选项，极大地提高了工作效率。</p></li><li><p><strong>更好的主题和外观</strong>：Zsh支持更多的主题和外观定制选项，使Shell界面更具吸引力和个性化。</p></li><li><p><strong>更好的拼写纠正</strong>：Zsh可以自动纠正常见的拼写错误，减少用户输入错误的机会。</p></li><li><p><strong>更强大的别名（alias）功能</strong>：Zsh的别名功能更灵活，可以支持更多的选项和参数。</p></li><li><p><strong>更高级的历史管理</strong>：Zsh允许更复杂的历史记录和管理，包括保存时间戳、删除重复记录等。</p></li><li><p><strong>更好的通配符支持</strong>：Zsh支持更多的通配符选项，使文件匹配更方便。</p></li></ol><p><strong>Zsh的缺点：</strong></p><ol><li><p><strong>安装和默认支持</strong>：虽然Zsh在大多数现代系统上都可以找到，但有些较旧或特殊的系统可能没有预装Zsh，并且可能需要单独安装。</p></li><li><p><strong>资源占用</strong>：Zsh相对于Bash来说，可能占用更多的系统资源，尤其在较旧的硬件上可能会感觉较慢。</p></li></ol><p><strong>Bash的优点：</strong></p><ol><li><p><strong>广泛支持</strong>：Bash是大多数Linux发行版和Unix系统的默认Shell，几乎可以在任何Unix系统上找到。</p></li><li><p><strong>较低的资源占用</strong>：相比于Zsh，Bash可能占用较少的系统资源，特别是在较旧的硬件上运行时更为明显。</p></li><li><p><strong>较少的学习曲线</strong>：由于Bash是默认Shell，更多的教程和资源可用于学习Bash，适合初学者入门学习。</p></li></ol><p><strong>Bash的缺点：</strong></p><ol><li><p><strong>较弱的自动补全</strong>：虽然Bash也支持命令补全，但它在功能和定制选项上比Zsh弱一些。</p></li><li><p><strong>较少的主题和外观选项</strong>：相比Zsh，Bash的外观和主题定制选项较少。</p></li><li><p><strong>较弱的别名（alias）功能</strong>：Bash的别名功能较为简单，不支持一些高级选项。</p></li></ol><p>综合而言，如果你需要一个功能强大且高度可定制的Shell，特别是在日常交互式使用和编程方面，Zsh可能是更好的选择。但如果你只是需要一个简单易用的Shell，并且对于学习Shell编程来说，Bash可能更适合初学者。无论选择哪个Shell，都取决于个人偏好和特定的使用场景。</p><h1>教程</h1><h2 id="编写-Hello-脚本">编写&quot;Hello&quot;脚本</h2><p>没有lp和lpr指令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> cups</span><br></pre></td></tr></table></figure><p>启动cups服务</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> cups</span><br></pre></td></tr></table></figure><p>bin目录下也有了unix-lpr.sh文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less <span class="regexp">/bin/u</span>nix-lpr.sh</span><br></pre></td></tr></table></figure><p>脚本文件以某个解释器开头作为这个文件的解释器</p><p>当不指定解释器的时候，默认用文件开头指示的解释器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure><p>开始创建文件编写脚本</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@192</span> ~]<span class="meta"># mkdir scripts/</span></span><br><span class="line">[root<span class="symbol">@192</span> ~]<span class="meta"># cd scripts/</span></span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># touch hello.sh</span></span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># vim hello.sh </span></span><br></pre></td></tr></table></figure><p>文件中编写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World!!!&quot;</span></span><br></pre></td></tr></table></figure><p>执行脚本</p><p>使用sh [文件名] 或者bash [文件名]的方式执行脚本不需要x权限</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="number">192</span> scripts]# sh hello.sh </span><br><span class="line">Hello World!!!</span><br><span class="line">[root@<span class="number">192</span> scripts]# bash hello.sh </span><br><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure><p>但是直接执行就需要权限./文件名</p><p>Linux/Unix 系统默认不会在当前目录中查找可执行文件。所以，为了确保能够正确执行脚本，我们需要提供脚本的完整路径或使用 <code>./</code> 来指定当前目录。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># ./hello.sh</span></span><br><span class="line">-bash: ./hello.sh: 权限不够</span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># ll</span></span><br><span class="line">总用量 <span class="number">4</span></span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">34</span> <span class="number">7</span>月  <span class="number">18</span> <span class="number">18</span>:<span class="number">15</span> hello.sh</span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># chmod 777 hello.sh </span></span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># ./hello.sh </span></span><br><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure><h2 id="source执行脚本">source执行脚本</h2><p>(也可以用于更新一些配置文件，source代表在当前环境下重载配置文件，而不是子shell下，那样影响不到当前的主环境)</p><p><strong>等价于 . <a href="http://hello.sh">hello.sh</a>  但不等价于./ <a href="http://hello.sh">hello.sh</a></strong></p><p>使用 <code>source</code> 命令执行脚本和直接执行脚本有一些重要的区别。让我们来看看 <code>source</code> 命令的不同之处：</p><ol><li><p><strong>运行环境</strong>：使用 <code>source</code> 命令（或 <code>.</code> 命令，它们等效）执行脚本时，脚本会在当前 Shell 进程中运行，而不是在一个新的子进程中。这意味着脚本中的任何变量、函数和环境变化都会直接影响当前的 Shell 环境。这对于配置环境变量或执行修改当前 Shell 环境的脚本非常有用。</p></li><li><p><strong>路径查找</strong>：使用 <code>source</code> 命令执行脚本时，不需要脚本具有可执行权限或者在 <code>PATH</code> 环境变量所定义的目录中。你可以在任何目录下使用 <code>source</code> 命令执行脚本，只要提供脚本的完整路径或相对路径即可。</p></li><li><p><strong>退出行为</strong>：使用 <code>source</code> 命令执行脚本后，脚本执行结束后不会退出当前的 Shell 环境。脚本中的任何改变仍然会保留在当前的 Shell 中。</p></li></ol><p>下面是使用 <code>source</code> 命令执行脚本的示例：</p><p>假设有一个名为 <code>myscript.sh</code> 的脚本文件，它的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, I am a script!&quot;</span></span><br></pre></td></tr></table></figure><p>要使用 <code>source</code> 命令执行该脚本，只需在当前 Shell 中键入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myscript.sh</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">. myscript.sh</span><br></pre></td></tr></table></figure><p>这样脚本中的 <code>echo</code> 命令将会在当前 Shell 中执行，并显示 “Hello, I am a script!”。而不是在一个新的子进程中执行脚本。</p><p>总结起来，使用 <code>source</code> 命令可以在当前 Shell 环境中执行脚本，使得脚本中的变量和环境设置对当前 Shell 生效。这在需要在当前 Shell 中设置环境变量或执行特定配置脚本时非常有用。</p><h2 id="查看当前运行进程">查看当前运行进程</h2><p><code>ps</code> 是一个用于查看当前系统中正在运行的进程信息的命令。它用于显示系统中运行的进程的状态、资源使用情况和其他相关信息。<code>ps</code> 命令在 Linux/Unix 系统中非常常用，用于监控和管理系统进程。</p><p>执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ps</span> <span class="operator">-f</span></span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">UID</span>         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line"><span class="attribute">root</span>      <span class="number">10507</span>  <span class="number">10503</span>  <span class="number">0</span> <span class="number">19</span>:<span class="number">22</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> -bash</span><br><span class="line"><span class="attribute">root</span>      <span class="number">10533</span>  <span class="number">10507</span>  <span class="number">0</span> <span class="number">19</span>:<span class="number">22</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps -f</span><br></pre></td></tr></table></figure><p>让我们解读上面显示的进程信息：</p><ul><li><strong>UID</strong>：用户标识符（User ID），显示进程的所有者。在这里，两个进程的所有者都是 <code>root</code>，即超级用户。</li><li><strong>PID</strong>：进程标识符（Process ID），是系统为每个进程分配的唯一标识号。它用于标识进程。</li><li><strong>PPID</strong>：父进程标识符（Parent Process ID），显示创建当前进程的父进程的 PID。在这里，第二个进程（PID 10533）的父进程是第一个进程（PID 10507）。</li><li><strong>C</strong>：CPU 占用率（CPU Utilization），表示进程在 CPU 上的占用率。在这里，C 列显示为 0，表示进程当前没有在 CPU 上执行。</li><li><strong>STIME</strong>：进程的启动时间（Start Time），显示进程启动的时间戳。在这里，两个进程的启动时间都是在 19:22。</li><li><strong>TTY</strong>：进程所连接的终端设备（Terminal）。在这里，两个进程都连接到 <code>pts/0</code> 终端。</li><li><strong>TIME</strong>：进程的累计 CPU 时间（CPU Time），显示进程在 CPU 上执行的累计时间。在这里，两个进程的累计 CPU 时间都是 00:00:00，表示它们还没有在 CPU 上执行。</li><li><strong>CMD</strong>：进程的命令行（Command），显示启动进程的完整命令。在这里，第一个进程是一个 <code>-bash</code>，表示一个 Bash Shell 进程，第二个进程是 <code>ps -f</code>，表示一个执行 <code>ps -f</code> 命令的进程。</li></ul><p>总结起来，上面的输出显示了两个进程的信息，它们都是由 <code>root</code> 用户创建的。第一个进程是一个 Bash Shell 进程（PID 10507），它是当前终端会话的 Shell。第二个进程是执行 <code>ps -f</code> 命令的进程（PID 10533），用于显示当前系统中的进程信息。第二个进程的父进程是第一个进程。这是一个 <code>ps</code> 命令的输出示例，用于显示正在运行的进程信息。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bash</span></span><br></pre></td></tr></table></figure><p>在终端中输入 <code>bash</code> 命令，会启动一个新的 Bash Shell。这个新的 Bash Shell 会在当前终端会话中运行，作为当前 Shell 的子 Shell。它会继承当前 Shell 的环境变量、当前目录和其他一些设置，但是在子 Shell 中对这些环境的修改不会影响到父 Shell。</p><p>查看自己是否出去子shell中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="number">192</span> scripts]<span class="comment"># echo $SHLVL</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[root@<span class="number">192</span> scripts]<span class="comment"># bash</span></span><br><span class="line">[root@<span class="number">192</span> scripts]<span class="comment"># echo $SHLVL</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">[root@<span class="number">192</span> scripts]<span class="comment"># bash</span></span><br><span class="line">[root@<span class="number">192</span> scripts]<span class="comment"># echo $SHLVL</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[root@<span class="number">192</span> scripts]<span class="comment"># exit</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">[root@<span class="number">192</span> scripts]<span class="comment"># echo $SHLVL</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>等于1时代表出去最初的shell，大于1时，代表处于第几个shell</p><p>输入bash两次后</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@192 scripts]<span class="comment"># ps -f</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     <span class="number"> 10507 </span><span class="number"> 10503 </span><span class="number"> 0 </span>19:22 pts/0    00:00:00 -bash</span><br><span class="line">root     <span class="number"> 10553 </span><span class="number"> 10507 </span><span class="number"> 0 </span>19:29 pts/0    00:00:00 bash</span><br><span class="line">root     <span class="number"> 10581 </span><span class="number"> 10553 </span><span class="number"> 0 </span>19:31 pts/0    00:00:00 bash</span><br><span class="line">root     <span class="number"> 10592 </span><span class="number"> 10581 </span><span class="number"> 0 </span>19:31 pts/0    00:00:00 ps -f</span><br></pre></td></tr></table></figure><p><strong>全局变量是可以在父 Shell 和子 Shell 之间进行通信的一种方式。在父 Shell 中定义的全局变量，在子 Shell 中也可以访问和使用，但需要注意的是，子 Shell 中对全局变量的修改不会直接影响到父 Shell 中的变量。这是因为子 Shell 在运行时会创建一个独立的进程，它继承了父 Shell 的环境变量，但对变量的更改只会影响到当前子 Shell。</strong></p><h2 id="系统常用变量">系统常用变量</h2><p>在 Linux/Unix 系统中，有许多常用的系统变量，这些变量用于存储有关系统配置、运行环境和用户信息等的信息。以下是一些常见的系统变量：</p><ol><li><p><strong><code>PATH</code></strong>：包含可执行文件的目录列表，用于在终端中查找命令。当你输入一个命令时，系统会在 <code>PATH</code> 中指定的目录中查找该命令的可执行文件。</p></li><li><p><strong><code>HOME</code></strong>：表示当前用户的主目录路径。通常用于指定用户的默认工作目录。</p></li><li><p><strong><code>USER</code></strong> 或 <strong><code>LOGNAME</code></strong>：表示当前登录用户的用户名。</p></li><li><p><strong><code>SHELL</code></strong>：表示当前用户所使用的默认 Shell 解释器的路径。</p></li><li><p><strong><code>PWD</code></strong>：表示当前工作目录的路径。</p></li><li><p><strong><code>PS1</code></strong>：表示命令行提示符的格式。可以通过修改该变量来自定义终端提示符的样式。</p></li><li><p><strong><code>PS2</code></strong>：表示命令行续行提示符的格式。当你输入一行命令太长需要换行时，会显示 <code>PS2</code> 提示符。</p></li><li><p><strong><code>LANG</code></strong> 和 <strong><code>LC_*</code></strong>：用于设置系统的语言和地区设置。<code>LANG</code> 设置整体语言环境，而 <code>LC_*</code> 变量可以设置特定方面的语言和地区，例如时间格式、货币符号等。</p></li><li><p><strong><code>UID</code></strong> 和 <strong><code>EUID</code></strong>：分别表示当前用户的真实用户 ID 和有效用户 ID。通常，<code>UID</code> 是当前用户的真实 ID，而 <code>EUID</code> 可能是不同于 <code>UID</code> 的特殊权限的用户 ID。</p></li><li><p><strong><code>TERM</code></strong>：表示当前终端类型。用于告诉系统如何正确地显示字符和颜色。</p></li><li><p><strong><code>HOSTNAME</code></strong>：表示当前系统的主机名。</p></li><li><p><strong><code>OSTYPE</code></strong>：表示当前操作系统类型，通常是 <code>linux-gnu</code>。</p></li></ol><p>这些是一些常见的系统变量，它们在终端和脚本中经常使用。你可以通过在终端中使用 <code>echo</code> 命令来查看这些变量的值。例如，要查看 <code>PATH</code> 变量的值，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>要查看其他变量的值，将变量名替换为相应的名称即可。</p><p>通过指令查看全局变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">env</span></span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@192</span> scripts]<span class="comment"># env</span></span><br><span class="line"><span class="title class_">XDG_SESSION_ID</span>=<span class="number">38</span></span><br><span class="line"><span class="title class_">HOSTNAME</span>=<span class="number">192.168</span>.<span class="number">1.4</span></span><br><span class="line"><span class="title class_">SELINUX_ROLE_REQUESTED</span>=</span><br><span class="line"><span class="title class_">TERM</span>=xterm<span class="number">-256</span>color</span><br><span class="line"><span class="title class_">SHELL</span>=/bin/bash</span><br><span class="line"><span class="title class_">HISTSIZE</span>=<span class="number">1000</span></span><br><span class="line"></span><br><span class="line">   终端软件的ip地址   软件的端口   远程<span class="title class_">SSH</span>服务的端口</span><br><span class="line"><span class="title class_">SSH_CLIENT</span>=<span class="number">192.168</span>.<span class="number">1.6</span> <span class="number">54200</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">SELINUX_USE_CURRENT_RANGE</span>=</span><br><span class="line"><span class="title class_">SSH_TTY</span>=/dev/pts/<span class="number">0</span></span><br><span class="line"><span class="title class_">USER</span>=root</span><br><span class="line"><span class="title class_">LS_COLORS</span>=rs=<span class="number">0</span><span class="symbol">:di=</span><span class="number">38</span>;<span class="number">5</span>;<span class="number">27</span><span class="symbol">:ln=</span><span class="number">38</span>;<span class="number">5</span>;<span class="number">51</span><span class="symbol">:mh=</span><span class="number">44</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">15</span><span class="symbol">:pi=</span><span class="number">40</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">11</span><span class="symbol">:so=</span><span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:do=</span><span class="number">38</span>;<span class="number">5</span>;<span class="number">5</span><span class="symbol">:bd=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">232</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">11</span><span class="symbol">:cd=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">232</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">3</span><span class="symbol">:or=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">232</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:mi=</span><span class="number">05</span>;<span class="number">48</span>;<span class="number">5</span>;<span class="number">232</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">15</span><span class="symbol">:su=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">196</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">15</span><span class="symbol">:sg=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">11</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">16</span><span class="symbol">:ca=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">196</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">226</span><span class="symbol">:tw=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">10</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">16</span><span class="symbol">:ow=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">10</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">21</span><span class="symbol">:st=</span><span class="number">48</span>;<span class="number">5</span>;<span class="number">21</span>;<span class="number">38</span>;<span class="number">5</span>;<span class="number">15</span><span class="symbol">:ex=</span><span class="number">38</span>;<span class="number">5</span>;<span class="number">34</span><span class="symbol">:*</span>.tar=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.tgz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.arc=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.arj=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.taz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.lha=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.lz4=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.lzh=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.lzma=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.tlz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.txz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.tzo=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.t7z=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.zip=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.z=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.Z=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.dz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.gz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.lrz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.lz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.lzo=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.xz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.bz2=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.bz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.tbz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.tbz2=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.tz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.deb=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.rpm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.jar=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.war=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.ear=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.sar=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.rar=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.alz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.ace=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.zoo=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.cpio=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.<span class="number">7</span>z=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.rz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.cab=<span class="number">38</span>;<span class="number">5</span>;<span class="number">9</span><span class="symbol">:*</span>.jpg=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.jpeg=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.gif=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.bmp=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.pbm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.pgm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.ppm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.tga=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.xbm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.xpm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.tif=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.tiff=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.png=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.svg=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.svgz=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.mng=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.pcx=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.mov=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.mpg=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.mpeg=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.m2v=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.mkv=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.webm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.ogm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.mp4=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.m4v=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.mp4v=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.vob=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.qt=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.nuv=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.wmv=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.asf=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.rm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.rmvb=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.flc=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.avi=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.fli=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.flv=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.gl=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.dl=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.xcf=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.xwd=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.yuv=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.cgm=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.emf=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.axv=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.anx=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.ogv=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.ogx=<span class="number">38</span>;<span class="number">5</span>;<span class="number">13</span><span class="symbol">:*</span>.aac=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.au=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.flac=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.mid=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.midi=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.mka=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.mp3=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.mpc=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.ogg=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.ra=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.wav=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.axa=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.oga=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.spx=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span><span class="symbol">:*</span>.xspf=<span class="number">38</span>;<span class="number">5</span>;<span class="number">45</span>:</span><br><span class="line"><span class="title class_">MAIL</span>=/var/spool/mail/root</span><br><span class="line"><span class="title class_">PATH</span>=/usr/local/<span class="symbol">sbin:</span>/usr/local/<span class="symbol">bin:</span>/usr/<span class="symbol">sbin:</span>/usr/<span class="symbol">bin:</span>/root/bin</span><br><span class="line"><span class="title class_">PWD</span>=/root/scripts</span><br><span class="line"><span class="title class_">LANG</span>=zh_CN.<span class="title class_">UTF</span><span class="number">-8</span></span><br><span class="line"><span class="title class_">SELINUX_LEVEL_REQUESTED</span>=</span><br><span class="line"><span class="title class_">HISTCONTROL</span>=ignoredups</span><br><span class="line"><span class="title class_">SHLVL</span>=<span class="number">1</span></span><br><span class="line"><span class="title class_">HOME</span>=/root</span><br><span class="line"><span class="title class_">LOGNAME</span>=root</span><br><span class="line"><span class="title class_">SSH_CONNECTION</span>=<span class="number">192.168</span>.<span class="number">1.6</span> <span class="number">54200</span> <span class="number">192.168</span>.<span class="number">1.4</span> <span class="number">22</span></span><br><span class="line"><span class="title class_">LESSOPEN</span>=||/usr/bin/lesspipe.sh %s</span><br><span class="line"><span class="title class_">XDG_RUNTIME_DIR</span>=/run/user/<span class="number">0</span></span><br><span class="line">_=/usr/bin/env</span><br><span class="line"><span class="title class_">OLDPWD</span>=/root</span><br></pre></td></tr></table></figure><p>打印某个环境变量信息</p><p>和echo $SHELL差不多</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="number">192</span> scripts]<span class="comment"># printenv SHELL</span></span><br><span class="line"><span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure><p>查看所有变量</p><p>包含全局变量和局部变量</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span></span><br></pre></td></tr></table></figure><h2 id="定义变量基本语法">定义变量基本语法</h2><p>在 Shell 中定义变量的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name=value</span><br></pre></td></tr></table></figure><p>其中，<code>variable_name</code> 是变量的名称，你可以自定义任何合法的变量名称。变量名称通常由字母、数字和下划线组成，不能以数字开头。Shell 变量是区分大小写的，所以 <code>myVariable</code> 和 <code>myvariable</code> 是不同的变量。</p><p><code>value</code> 是要赋给变量的值。这可以是文本、数字、命令输出，或者其他类型的数据。</p><p>例如，要定义一个名为 <code>name</code> 的变量，并将其赋值为 “John”，可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;John&quot;</span></span><br></pre></td></tr></table></figure><p>变量定义时，等号两边不能有空格，否则会被视为命令或其他语法错误。</p><p>定义完变量后，你可以通过在变量名前添加 <code>$</code> 符号来引用变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br></pre></td></tr></table></figure><p>这将输出变量 <code>name</code> 的值，即 “John”。</p><p>注意，在给变量赋值时，等号两边不能有空格，例如 <code>variable_name = value</code> 是错误的写法。另外，在引用变量时，要记得在变量名前面加上 <code>$</code> 符号，否则 Shell 将会把变量名视为普通的字符串。</p><p>值得注意的是，当你在 Shell 中定义的变量只在当前 Shell 环境中有效，即局部变量。如果你希望将变量传递给子 Shell 或其他 Shell 环境，你可以使用 <code>export</code> 命令将变量导出为环境变量。</p><p>赋值时=两侧不要加空格，字符串可以加双引号</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># a=2</span></span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># echo a</span></span><br><span class="line">a</span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># echo $a</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># a=hghg</span></span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># echo $a</span></span><br><span class="line">hghg</span><br></pre></td></tr></table></figure><p>如果变量中间有空格，可以使用单引号或双引号进行</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># my_var=<span class="string">&quot;Hello World&quot;</span></span></span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># echo $my_var </span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>检测发现这种定义方法定义的是局部变量</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[root@192 scripts]</span><span class="comment"># set | grep my_var</span></span><br><span class="line"><span class="attr">my_var</span>=<span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="section">[root@192 scripts]</span><span class="comment"># env | grep my_var</span></span><br></pre></td></tr></table></figure><p>使用export导出就可以将局部变量变为全局变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@192 scripts]# export my_var</span><br><span class="line">[root@192 scripts]# env | grep my_var</span><br><span class="line">my_var=Hello World</span><br><span class="line">[root@192 scripts]# bash</span><br><span class="line">[root@192 scripts]# echo $my_var</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>将计算结果赋值给变量</p><p>在 Shell 中使用了算术展开（arithmetic expansion）的语法，将 <code>a</code> 变量赋值为 <code>1+5</code> 表达式的结果。在 Shell 中，算术展开可以通过 <code>$(())</code> 或者 <code>$[ ]</code> 来执行算术运算，用于计算表达式的结果并将其赋值给变量。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># b=$[2+5]</span></span><br><span class="line">[root<span class="symbol">@192</span> scripts]<span class="meta"># echo $b</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>只读变量</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="number">192</span> <span class="keyword">scripts]# </span>readonly <span class="keyword">b=56</span></span><br><span class="line"><span class="keyword"></span>[root@<span class="number">192</span> <span class="keyword">scripts]# </span><span class="keyword">b=10</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bash: </span><span class="keyword">b: </span>只读变量</span><br></pre></td></tr></table></figure><p>撤销变量</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="subst">@192</span> scripts]<span class="meta"># unset b</span></span><br><span class="line"><span class="symbol">bash:</span> unset: b: 无法反设定: 只读 variable</span><br><span class="line">[root<span class="subst">@192</span> scripts]<span class="meta"># unset a</span></span><br></pre></td></tr></table></figure><p>将sh文件放在/bin下后可以直接输入文件名来运行，可以不加./</p><p>特殊变量</p><h1>GPT回答基础</h1><p>Shell编程是在Linux和其他类Unix操作系统上进行脚本编程的一种方法。Shell是一个命令行解释器，可以执行用户输入的命令，并且也可以用来编写脚本，用于自动化任务和批处理。下面是Shell编程的基础知识：</p><ol><li><p><strong>Shell脚本文件</strong>：Shell脚本是一个纯文本文件，通常以<code>.sh</code>为扩展名。你可以使用任何文本编辑器（如vi、nano、gedit等）来创建Shell脚本文件。</p></li><li><p><strong>Shebang</strong>：在Shell脚本文件的第一行通常指定一个Shebang（解释器指令），用于告诉系统用哪个Shell解释器来执行脚本。例如，<code>#!/bin/bash</code>表示使用Bash解释器执行脚本。</p></li><li><p><strong>变量</strong>：在Shell中使用变量来存储数据。定义变量时不需要声明类型，直接赋值即可。例如：<code>name=&quot;John&quot;</code>，然后可以通过<code>$name</code>来引用变量的值。</p></li><li><p><strong>输出</strong>：使用<code>echo</code>命令来输出文本或变量的值到终端。例如：<code>echo &quot;Hello, World!&quot;</code>。</p></li><li><p><strong>输入</strong>：使用<code>read</code>命令从用户获取输入，并将输入保存到变量中。例如：<code>read name</code>。</p></li><li><p><strong>条件语句</strong>：使用条件语句来根据条件执行不同的代码块。常见的条件语句有<code>if</code>、<code>else</code>、<code>elif</code>。例如：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$age</span> -gt 18 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You are an adult.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You are a minor.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p><strong>循环</strong>：使用循环结构来重复执行代码块。常见的循环有<code>for</code>循环和<code>while</code>循环。例如：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 4 5; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p><strong>函数</strong>：使用函数将一系列命令封装起来，方便在不同地方多次使用。例如：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$1</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">&quot;John&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注释</strong>：使用<code>#</code>符号来添加注释，注释内容将被解释器忽略。</p></li><li><p><strong>执行脚本</strong>：执行Shell脚本需要给予执行权限，使用<code>chmod +x script.sh</code>命令添加执行权限，然后通过<code>./script.sh</code>来执行脚本。</p></li></ol><p>这些是Shell编程的基础知识，通过学习这些知识，你可以编写简单的Shell脚本来完成各种任务，提高工作效率并简化重复性工作。随着经验的增加，你还可以学习更多高级的Shell编程技巧和工具，以及掌握更多系统管理和自动化的能力。</p>]]></content>
    
    
    <summary type="html">🥧本文汇总Shell编程的基础</summary>
    
    
    
    <category term="编程" scheme="https://momoao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Shell" scheme="https://momoao.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://momoao.github.io/posts/202308242004.html"/>
    <id>https://momoao.github.io/posts/202308242004.html</id>
    <published>2023-07-10T10:19:03.000Z</published>
    <updated>2023-08-25T12:44:29.174Z</updated>
    
    <content type="html"><![CDATA[<h1>正则表达式</h1>]]></content>
    
    
    <summary type="html">🥧本文汇总正则表达式的写法和常用的正则表达式</summary>
    
    
    
    <category term="正则表达式" scheme="https://momoao.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
    <category term="正则" scheme="https://momoao.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
</feed>
